
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model RegisterForm
 * 
 */
export type RegisterForm = $Result.DefaultSelection<Prisma.$RegisterFormPayload>
/**
 * Model ApiList
 * 
 */
export type ApiList = $Result.DefaultSelection<Prisma.$ApiListPayload>
/**
 * Model FacebookPixel
 * 
 */
export type FacebookPixel = $Result.DefaultSelection<Prisma.$FacebookPixelPayload>
/**
 * Model SiteIdentity
 * 
 */
export type SiteIdentity = $Result.DefaultSelection<Prisma.$SiteIdentityPayload>
/**
 * Model SocialLinks
 * 
 */
export type SocialLinks = $Result.DefaultSelection<Prisma.$SocialLinksPayload>
/**
 * Model Page
 * 
 */
export type Page = $Result.DefaultSelection<Prisma.$PagePayload>
/**
 * Model Section
 * 
 */
export type Section = $Result.DefaultSelection<Prisma.$SectionPayload>
/**
 * Model ListItem
 * 
 */
export type ListItem = $Result.DefaultSelection<Prisma.$ListItemPayload>
/**
 * Model ListEntry
 * 
 */
export type ListEntry = $Result.DefaultSelection<Prisma.$ListEntryPayload>
/**
 * Model Product
 * 
 */
export type Product = $Result.DefaultSelection<Prisma.$ProductPayload>
/**
 * Model Category
 * 
 */
export type Category = $Result.DefaultSelection<Prisma.$CategoryPayload>
/**
 * Model Tag
 * 
 */
export type Tag = $Result.DefaultSelection<Prisma.$TagPayload>
/**
 * Model ProductGallery
 * 
 */
export type ProductGallery = $Result.DefaultSelection<Prisma.$ProductGalleryPayload>
/**
 * Model Benefit
 * 
 */
export type Benefit = $Result.DefaultSelection<Prisma.$BenefitPayload>
/**
 * Model ProductBenefit
 * 
 */
export type ProductBenefit = $Result.DefaultSelection<Prisma.$ProductBenefitPayload>
/**
 * Model ProductBenefitPoint
 * 
 */
export type ProductBenefitPoint = $Result.DefaultSelection<Prisma.$ProductBenefitPointPayload>
/**
 * Model Promotion
 * 
 */
export type Promotion = $Result.DefaultSelection<Prisma.$PromotionPayload>
/**
 * Model Voucher
 * 
 */
export type Voucher = $Result.DefaultSelection<Prisma.$VoucherPayload>
/**
 * Model VoucherUsage
 * 
 */
export type VoucherUsage = $Result.DefaultSelection<Prisma.$VoucherUsagePayload>
/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Authenticator
 * 
 */
export type Authenticator = $Result.DefaultSelection<Prisma.$AuthenticatorPayload>
/**
 * Model Order
 * 
 */
export type Order = $Result.DefaultSelection<Prisma.$OrderPayload>
/**
 * Model Menu
 * 
 */
export type Menu = $Result.DefaultSelection<Prisma.$MenuPayload>
/**
 * Model FooterInfo
 * 
 */
export type FooterInfo = $Result.DefaultSelection<Prisma.$FooterInfoPayload>
/**
 * Model Account
 * 
 */
export type Account = $Result.DefaultSelection<Prisma.$AccountPayload>
/**
 * Model Session
 * 
 */
export type Session = $Result.DefaultSelection<Prisma.$SessionPayload>
/**
 * Model VerificationToken
 * 
 */
export type VerificationToken = $Result.DefaultSelection<Prisma.$VerificationTokenPayload>
/**
 * Model LandingPage
 * 
 */
export type LandingPage = $Result.DefaultSelection<Prisma.$LandingPagePayload>
/**
 * Model LpFor
 * 
 */
export type LpFor = $Result.DefaultSelection<Prisma.$LpForPayload>
/**
 * Model LpContentType
 * 
 */
export type LpContentType = $Result.DefaultSelection<Prisma.$LpContentTypePayload>
/**
 * Model LpDesignStyle
 * 
 */
export type LpDesignStyle = $Result.DefaultSelection<Prisma.$LpDesignStylePayload>

/**
 * Enums
 */
export namespace $Enums {
  export const ListItemType: {
  BASIC: 'BASIC',
  DETAILED: 'DETAILED'
};

export type ListItemType = (typeof ListItemType)[keyof typeof ListItemType]


export const SectionType: {
  NORMAL: 'NORMAL',
  HERO: 'HERO',
  IMAGE: 'IMAGE',
  VIDEO: 'VIDEO',
  LIST: 'LIST',
  CTA: 'CTA',
  CUSTOM: 'CUSTOM'
};

export type SectionType = (typeof SectionType)[keyof typeof SectionType]


export const ProductStatus: {
  ACTIVE: 'ACTIVE',
  SUSPENDED: 'SUSPENDED',
  INACTIVE: 'INACTIVE'
};

export type ProductStatus = (typeof ProductStatus)[keyof typeof ProductStatus]


export const PromoType: {
  PERCENTAGE: 'PERCENTAGE',
  FIXED: 'FIXED',
  BONUS_ITEM: 'BONUS_ITEM',
  FREE_SHIPPING: 'FREE_SHIPPING',
  CUSTOM: 'CUSTOM'
};

export type PromoType = (typeof PromoType)[keyof typeof PromoType]


export const MenuType: {
  HEADER: 'HEADER',
  FOOTER: 'FOOTER',
  SIDEBAR: 'SIDEBAR'
};

export type MenuType = (typeof MenuType)[keyof typeof MenuType]


export const FooterInfoType: {
  CONTACT: 'CONTACT',
  SOCIAL: 'SOCIAL',
  LEGAL: 'LEGAL',
  CUSTOM: 'CUSTOM'
};

export type FooterInfoType = (typeof FooterInfoType)[keyof typeof FooterInfoType]


export const UserRole: {
  CUSTOMER: 'CUSTOMER',
  ADMIN: 'ADMIN'
};

export type UserRole = (typeof UserRole)[keyof typeof UserRole]


export const OrderStatus: {
  PENDING: 'PENDING',
  PAID: 'PAID',
  SHIPPED: 'SHIPPED',
  COMPLETED: 'COMPLETED',
  CANCELLED: 'CANCELLED'
};

export type OrderStatus = (typeof OrderStatus)[keyof typeof OrderStatus]

}

export type ListItemType = $Enums.ListItemType

export const ListItemType: typeof $Enums.ListItemType

export type SectionType = $Enums.SectionType

export const SectionType: typeof $Enums.SectionType

export type ProductStatus = $Enums.ProductStatus

export const ProductStatus: typeof $Enums.ProductStatus

export type PromoType = $Enums.PromoType

export const PromoType: typeof $Enums.PromoType

export type MenuType = $Enums.MenuType

export const MenuType: typeof $Enums.MenuType

export type FooterInfoType = $Enums.FooterInfoType

export const FooterInfoType: typeof $Enums.FooterInfoType

export type UserRole = $Enums.UserRole

export const UserRole: typeof $Enums.UserRole

export type OrderStatus = $Enums.OrderStatus

export const OrderStatus: typeof $Enums.OrderStatus

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more RegisterForms
 * const registerForms = await prisma.registerForm.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more RegisterForms
   * const registerForms = await prisma.registerForm.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.registerForm`: Exposes CRUD operations for the **RegisterForm** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RegisterForms
    * const registerForms = await prisma.registerForm.findMany()
    * ```
    */
  get registerForm(): Prisma.RegisterFormDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.apiList`: Exposes CRUD operations for the **ApiList** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ApiLists
    * const apiLists = await prisma.apiList.findMany()
    * ```
    */
  get apiList(): Prisma.ApiListDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.facebookPixel`: Exposes CRUD operations for the **FacebookPixel** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FacebookPixels
    * const facebookPixels = await prisma.facebookPixel.findMany()
    * ```
    */
  get facebookPixel(): Prisma.FacebookPixelDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.siteIdentity`: Exposes CRUD operations for the **SiteIdentity** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SiteIdentities
    * const siteIdentities = await prisma.siteIdentity.findMany()
    * ```
    */
  get siteIdentity(): Prisma.SiteIdentityDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.socialLinks`: Exposes CRUD operations for the **SocialLinks** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SocialLinks
    * const socialLinks = await prisma.socialLinks.findMany()
    * ```
    */
  get socialLinks(): Prisma.SocialLinksDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.page`: Exposes CRUD operations for the **Page** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Pages
    * const pages = await prisma.page.findMany()
    * ```
    */
  get page(): Prisma.PageDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.section`: Exposes CRUD operations for the **Section** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sections
    * const sections = await prisma.section.findMany()
    * ```
    */
  get section(): Prisma.SectionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.listItem`: Exposes CRUD operations for the **ListItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ListItems
    * const listItems = await prisma.listItem.findMany()
    * ```
    */
  get listItem(): Prisma.ListItemDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.listEntry`: Exposes CRUD operations for the **ListEntry** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ListEntries
    * const listEntries = await prisma.listEntry.findMany()
    * ```
    */
  get listEntry(): Prisma.ListEntryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.product`: Exposes CRUD operations for the **Product** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Products
    * const products = await prisma.product.findMany()
    * ```
    */
  get product(): Prisma.ProductDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.category`: Exposes CRUD operations for the **Category** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Categories
    * const categories = await prisma.category.findMany()
    * ```
    */
  get category(): Prisma.CategoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tag`: Exposes CRUD operations for the **Tag** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tags
    * const tags = await prisma.tag.findMany()
    * ```
    */
  get tag(): Prisma.TagDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.productGallery`: Exposes CRUD operations for the **ProductGallery** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProductGalleries
    * const productGalleries = await prisma.productGallery.findMany()
    * ```
    */
  get productGallery(): Prisma.ProductGalleryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.benefit`: Exposes CRUD operations for the **Benefit** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Benefits
    * const benefits = await prisma.benefit.findMany()
    * ```
    */
  get benefit(): Prisma.BenefitDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.productBenefit`: Exposes CRUD operations for the **ProductBenefit** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProductBenefits
    * const productBenefits = await prisma.productBenefit.findMany()
    * ```
    */
  get productBenefit(): Prisma.ProductBenefitDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.productBenefitPoint`: Exposes CRUD operations for the **ProductBenefitPoint** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProductBenefitPoints
    * const productBenefitPoints = await prisma.productBenefitPoint.findMany()
    * ```
    */
  get productBenefitPoint(): Prisma.ProductBenefitPointDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.promotion`: Exposes CRUD operations for the **Promotion** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Promotions
    * const promotions = await prisma.promotion.findMany()
    * ```
    */
  get promotion(): Prisma.PromotionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.voucher`: Exposes CRUD operations for the **Voucher** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Vouchers
    * const vouchers = await prisma.voucher.findMany()
    * ```
    */
  get voucher(): Prisma.VoucherDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.voucherUsage`: Exposes CRUD operations for the **VoucherUsage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more VoucherUsages
    * const voucherUsages = await prisma.voucherUsage.findMany()
    * ```
    */
  get voucherUsage(): Prisma.VoucherUsageDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.authenticator`: Exposes CRUD operations for the **Authenticator** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Authenticators
    * const authenticators = await prisma.authenticator.findMany()
    * ```
    */
  get authenticator(): Prisma.AuthenticatorDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.order`: Exposes CRUD operations for the **Order** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Orders
    * const orders = await prisma.order.findMany()
    * ```
    */
  get order(): Prisma.OrderDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.menu`: Exposes CRUD operations for the **Menu** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Menus
    * const menus = await prisma.menu.findMany()
    * ```
    */
  get menu(): Prisma.MenuDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.footerInfo`: Exposes CRUD operations for the **FooterInfo** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FooterInfos
    * const footerInfos = await prisma.footerInfo.findMany()
    * ```
    */
  get footerInfo(): Prisma.FooterInfoDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.account`: Exposes CRUD operations for the **Account** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Accounts
    * const accounts = await prisma.account.findMany()
    * ```
    */
  get account(): Prisma.AccountDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.session`: Exposes CRUD operations for the **Session** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sessions
    * const sessions = await prisma.session.findMany()
    * ```
    */
  get session(): Prisma.SessionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.verificationToken`: Exposes CRUD operations for the **VerificationToken** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more VerificationTokens
    * const verificationTokens = await prisma.verificationToken.findMany()
    * ```
    */
  get verificationToken(): Prisma.VerificationTokenDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.landingPage`: Exposes CRUD operations for the **LandingPage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LandingPages
    * const landingPages = await prisma.landingPage.findMany()
    * ```
    */
  get landingPage(): Prisma.LandingPageDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.lpFor`: Exposes CRUD operations for the **LpFor** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LpFors
    * const lpFors = await prisma.lpFor.findMany()
    * ```
    */
  get lpFor(): Prisma.LpForDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.lpContentType`: Exposes CRUD operations for the **LpContentType** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LpContentTypes
    * const lpContentTypes = await prisma.lpContentType.findMany()
    * ```
    */
  get lpContentType(): Prisma.LpContentTypeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.lpDesignStyle`: Exposes CRUD operations for the **LpDesignStyle** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LpDesignStyles
    * const lpDesignStyles = await prisma.lpDesignStyle.findMany()
    * ```
    */
  get lpDesignStyle(): Prisma.LpDesignStyleDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.8.2
   * Query Engine version: 2060c79ba17c6bb9f5823312b6f6b7f4a845738e
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    RegisterForm: 'RegisterForm',
    ApiList: 'ApiList',
    FacebookPixel: 'FacebookPixel',
    SiteIdentity: 'SiteIdentity',
    SocialLinks: 'SocialLinks',
    Page: 'Page',
    Section: 'Section',
    ListItem: 'ListItem',
    ListEntry: 'ListEntry',
    Product: 'Product',
    Category: 'Category',
    Tag: 'Tag',
    ProductGallery: 'ProductGallery',
    Benefit: 'Benefit',
    ProductBenefit: 'ProductBenefit',
    ProductBenefitPoint: 'ProductBenefitPoint',
    Promotion: 'Promotion',
    Voucher: 'Voucher',
    VoucherUsage: 'VoucherUsage',
    User: 'User',
    Authenticator: 'Authenticator',
    Order: 'Order',
    Menu: 'Menu',
    FooterInfo: 'FooterInfo',
    Account: 'Account',
    Session: 'Session',
    VerificationToken: 'VerificationToken',
    LandingPage: 'LandingPage',
    LpFor: 'LpFor',
    LpContentType: 'LpContentType',
    LpDesignStyle: 'LpDesignStyle'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "registerForm" | "apiList" | "facebookPixel" | "siteIdentity" | "socialLinks" | "page" | "section" | "listItem" | "listEntry" | "product" | "category" | "tag" | "productGallery" | "benefit" | "productBenefit" | "productBenefitPoint" | "promotion" | "voucher" | "voucherUsage" | "user" | "authenticator" | "order" | "menu" | "footerInfo" | "account" | "session" | "verificationToken" | "landingPage" | "lpFor" | "lpContentType" | "lpDesignStyle"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      RegisterForm: {
        payload: Prisma.$RegisterFormPayload<ExtArgs>
        fields: Prisma.RegisterFormFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RegisterFormFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegisterFormPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RegisterFormFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegisterFormPayload>
          }
          findFirst: {
            args: Prisma.RegisterFormFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegisterFormPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RegisterFormFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegisterFormPayload>
          }
          findMany: {
            args: Prisma.RegisterFormFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegisterFormPayload>[]
          }
          create: {
            args: Prisma.RegisterFormCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegisterFormPayload>
          }
          createMany: {
            args: Prisma.RegisterFormCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RegisterFormCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegisterFormPayload>[]
          }
          delete: {
            args: Prisma.RegisterFormDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegisterFormPayload>
          }
          update: {
            args: Prisma.RegisterFormUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegisterFormPayload>
          }
          deleteMany: {
            args: Prisma.RegisterFormDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RegisterFormUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RegisterFormUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegisterFormPayload>[]
          }
          upsert: {
            args: Prisma.RegisterFormUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegisterFormPayload>
          }
          aggregate: {
            args: Prisma.RegisterFormAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRegisterForm>
          }
          groupBy: {
            args: Prisma.RegisterFormGroupByArgs<ExtArgs>
            result: $Utils.Optional<RegisterFormGroupByOutputType>[]
          }
          count: {
            args: Prisma.RegisterFormCountArgs<ExtArgs>
            result: $Utils.Optional<RegisterFormCountAggregateOutputType> | number
          }
        }
      }
      ApiList: {
        payload: Prisma.$ApiListPayload<ExtArgs>
        fields: Prisma.ApiListFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ApiListFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiListPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ApiListFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiListPayload>
          }
          findFirst: {
            args: Prisma.ApiListFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiListPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ApiListFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiListPayload>
          }
          findMany: {
            args: Prisma.ApiListFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiListPayload>[]
          }
          create: {
            args: Prisma.ApiListCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiListPayload>
          }
          createMany: {
            args: Prisma.ApiListCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ApiListCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiListPayload>[]
          }
          delete: {
            args: Prisma.ApiListDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiListPayload>
          }
          update: {
            args: Prisma.ApiListUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiListPayload>
          }
          deleteMany: {
            args: Prisma.ApiListDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ApiListUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ApiListUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiListPayload>[]
          }
          upsert: {
            args: Prisma.ApiListUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiListPayload>
          }
          aggregate: {
            args: Prisma.ApiListAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateApiList>
          }
          groupBy: {
            args: Prisma.ApiListGroupByArgs<ExtArgs>
            result: $Utils.Optional<ApiListGroupByOutputType>[]
          }
          count: {
            args: Prisma.ApiListCountArgs<ExtArgs>
            result: $Utils.Optional<ApiListCountAggregateOutputType> | number
          }
        }
      }
      FacebookPixel: {
        payload: Prisma.$FacebookPixelPayload<ExtArgs>
        fields: Prisma.FacebookPixelFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FacebookPixelFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FacebookPixelPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FacebookPixelFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FacebookPixelPayload>
          }
          findFirst: {
            args: Prisma.FacebookPixelFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FacebookPixelPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FacebookPixelFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FacebookPixelPayload>
          }
          findMany: {
            args: Prisma.FacebookPixelFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FacebookPixelPayload>[]
          }
          create: {
            args: Prisma.FacebookPixelCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FacebookPixelPayload>
          }
          createMany: {
            args: Prisma.FacebookPixelCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FacebookPixelCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FacebookPixelPayload>[]
          }
          delete: {
            args: Prisma.FacebookPixelDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FacebookPixelPayload>
          }
          update: {
            args: Prisma.FacebookPixelUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FacebookPixelPayload>
          }
          deleteMany: {
            args: Prisma.FacebookPixelDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FacebookPixelUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FacebookPixelUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FacebookPixelPayload>[]
          }
          upsert: {
            args: Prisma.FacebookPixelUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FacebookPixelPayload>
          }
          aggregate: {
            args: Prisma.FacebookPixelAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFacebookPixel>
          }
          groupBy: {
            args: Prisma.FacebookPixelGroupByArgs<ExtArgs>
            result: $Utils.Optional<FacebookPixelGroupByOutputType>[]
          }
          count: {
            args: Prisma.FacebookPixelCountArgs<ExtArgs>
            result: $Utils.Optional<FacebookPixelCountAggregateOutputType> | number
          }
        }
      }
      SiteIdentity: {
        payload: Prisma.$SiteIdentityPayload<ExtArgs>
        fields: Prisma.SiteIdentityFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SiteIdentityFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SiteIdentityPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SiteIdentityFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SiteIdentityPayload>
          }
          findFirst: {
            args: Prisma.SiteIdentityFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SiteIdentityPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SiteIdentityFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SiteIdentityPayload>
          }
          findMany: {
            args: Prisma.SiteIdentityFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SiteIdentityPayload>[]
          }
          create: {
            args: Prisma.SiteIdentityCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SiteIdentityPayload>
          }
          createMany: {
            args: Prisma.SiteIdentityCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SiteIdentityCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SiteIdentityPayload>[]
          }
          delete: {
            args: Prisma.SiteIdentityDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SiteIdentityPayload>
          }
          update: {
            args: Prisma.SiteIdentityUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SiteIdentityPayload>
          }
          deleteMany: {
            args: Prisma.SiteIdentityDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SiteIdentityUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SiteIdentityUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SiteIdentityPayload>[]
          }
          upsert: {
            args: Prisma.SiteIdentityUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SiteIdentityPayload>
          }
          aggregate: {
            args: Prisma.SiteIdentityAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSiteIdentity>
          }
          groupBy: {
            args: Prisma.SiteIdentityGroupByArgs<ExtArgs>
            result: $Utils.Optional<SiteIdentityGroupByOutputType>[]
          }
          count: {
            args: Prisma.SiteIdentityCountArgs<ExtArgs>
            result: $Utils.Optional<SiteIdentityCountAggregateOutputType> | number
          }
        }
      }
      SocialLinks: {
        payload: Prisma.$SocialLinksPayload<ExtArgs>
        fields: Prisma.SocialLinksFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SocialLinksFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SocialLinksPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SocialLinksFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SocialLinksPayload>
          }
          findFirst: {
            args: Prisma.SocialLinksFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SocialLinksPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SocialLinksFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SocialLinksPayload>
          }
          findMany: {
            args: Prisma.SocialLinksFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SocialLinksPayload>[]
          }
          create: {
            args: Prisma.SocialLinksCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SocialLinksPayload>
          }
          createMany: {
            args: Prisma.SocialLinksCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SocialLinksCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SocialLinksPayload>[]
          }
          delete: {
            args: Prisma.SocialLinksDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SocialLinksPayload>
          }
          update: {
            args: Prisma.SocialLinksUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SocialLinksPayload>
          }
          deleteMany: {
            args: Prisma.SocialLinksDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SocialLinksUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SocialLinksUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SocialLinksPayload>[]
          }
          upsert: {
            args: Prisma.SocialLinksUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SocialLinksPayload>
          }
          aggregate: {
            args: Prisma.SocialLinksAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSocialLinks>
          }
          groupBy: {
            args: Prisma.SocialLinksGroupByArgs<ExtArgs>
            result: $Utils.Optional<SocialLinksGroupByOutputType>[]
          }
          count: {
            args: Prisma.SocialLinksCountArgs<ExtArgs>
            result: $Utils.Optional<SocialLinksCountAggregateOutputType> | number
          }
        }
      }
      Page: {
        payload: Prisma.$PagePayload<ExtArgs>
        fields: Prisma.PageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PagePayload>
          }
          findFirst: {
            args: Prisma.PageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PagePayload>
          }
          findMany: {
            args: Prisma.PageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PagePayload>[]
          }
          create: {
            args: Prisma.PageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PagePayload>
          }
          createMany: {
            args: Prisma.PageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PagePayload>[]
          }
          delete: {
            args: Prisma.PageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PagePayload>
          }
          update: {
            args: Prisma.PageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PagePayload>
          }
          deleteMany: {
            args: Prisma.PageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PageUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PagePayload>[]
          }
          upsert: {
            args: Prisma.PageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PagePayload>
          }
          aggregate: {
            args: Prisma.PageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePage>
          }
          groupBy: {
            args: Prisma.PageGroupByArgs<ExtArgs>
            result: $Utils.Optional<PageGroupByOutputType>[]
          }
          count: {
            args: Prisma.PageCountArgs<ExtArgs>
            result: $Utils.Optional<PageCountAggregateOutputType> | number
          }
        }
      }
      Section: {
        payload: Prisma.$SectionPayload<ExtArgs>
        fields: Prisma.SectionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SectionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SectionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SectionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SectionPayload>
          }
          findFirst: {
            args: Prisma.SectionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SectionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SectionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SectionPayload>
          }
          findMany: {
            args: Prisma.SectionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SectionPayload>[]
          }
          create: {
            args: Prisma.SectionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SectionPayload>
          }
          createMany: {
            args: Prisma.SectionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SectionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SectionPayload>[]
          }
          delete: {
            args: Prisma.SectionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SectionPayload>
          }
          update: {
            args: Prisma.SectionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SectionPayload>
          }
          deleteMany: {
            args: Prisma.SectionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SectionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SectionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SectionPayload>[]
          }
          upsert: {
            args: Prisma.SectionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SectionPayload>
          }
          aggregate: {
            args: Prisma.SectionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSection>
          }
          groupBy: {
            args: Prisma.SectionGroupByArgs<ExtArgs>
            result: $Utils.Optional<SectionGroupByOutputType>[]
          }
          count: {
            args: Prisma.SectionCountArgs<ExtArgs>
            result: $Utils.Optional<SectionCountAggregateOutputType> | number
          }
        }
      }
      ListItem: {
        payload: Prisma.$ListItemPayload<ExtArgs>
        fields: Prisma.ListItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ListItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ListItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ListItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ListItemPayload>
          }
          findFirst: {
            args: Prisma.ListItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ListItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ListItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ListItemPayload>
          }
          findMany: {
            args: Prisma.ListItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ListItemPayload>[]
          }
          create: {
            args: Prisma.ListItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ListItemPayload>
          }
          createMany: {
            args: Prisma.ListItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ListItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ListItemPayload>[]
          }
          delete: {
            args: Prisma.ListItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ListItemPayload>
          }
          update: {
            args: Prisma.ListItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ListItemPayload>
          }
          deleteMany: {
            args: Prisma.ListItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ListItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ListItemUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ListItemPayload>[]
          }
          upsert: {
            args: Prisma.ListItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ListItemPayload>
          }
          aggregate: {
            args: Prisma.ListItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateListItem>
          }
          groupBy: {
            args: Prisma.ListItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<ListItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.ListItemCountArgs<ExtArgs>
            result: $Utils.Optional<ListItemCountAggregateOutputType> | number
          }
        }
      }
      ListEntry: {
        payload: Prisma.$ListEntryPayload<ExtArgs>
        fields: Prisma.ListEntryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ListEntryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ListEntryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ListEntryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ListEntryPayload>
          }
          findFirst: {
            args: Prisma.ListEntryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ListEntryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ListEntryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ListEntryPayload>
          }
          findMany: {
            args: Prisma.ListEntryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ListEntryPayload>[]
          }
          create: {
            args: Prisma.ListEntryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ListEntryPayload>
          }
          createMany: {
            args: Prisma.ListEntryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ListEntryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ListEntryPayload>[]
          }
          delete: {
            args: Prisma.ListEntryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ListEntryPayload>
          }
          update: {
            args: Prisma.ListEntryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ListEntryPayload>
          }
          deleteMany: {
            args: Prisma.ListEntryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ListEntryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ListEntryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ListEntryPayload>[]
          }
          upsert: {
            args: Prisma.ListEntryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ListEntryPayload>
          }
          aggregate: {
            args: Prisma.ListEntryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateListEntry>
          }
          groupBy: {
            args: Prisma.ListEntryGroupByArgs<ExtArgs>
            result: $Utils.Optional<ListEntryGroupByOutputType>[]
          }
          count: {
            args: Prisma.ListEntryCountArgs<ExtArgs>
            result: $Utils.Optional<ListEntryCountAggregateOutputType> | number
          }
        }
      }
      Product: {
        payload: Prisma.$ProductPayload<ExtArgs>
        fields: Prisma.ProductFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProductFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProductFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          findFirst: {
            args: Prisma.ProductFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProductFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          findMany: {
            args: Prisma.ProductFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>[]
          }
          create: {
            args: Prisma.ProductCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          createMany: {
            args: Prisma.ProductCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProductCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>[]
          }
          delete: {
            args: Prisma.ProductDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          update: {
            args: Prisma.ProductUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          deleteMany: {
            args: Prisma.ProductDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProductUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProductUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>[]
          }
          upsert: {
            args: Prisma.ProductUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          aggregate: {
            args: Prisma.ProductAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProduct>
          }
          groupBy: {
            args: Prisma.ProductGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProductGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProductCountArgs<ExtArgs>
            result: $Utils.Optional<ProductCountAggregateOutputType> | number
          }
        }
      }
      Category: {
        payload: Prisma.$CategoryPayload<ExtArgs>
        fields: Prisma.CategoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CategoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CategoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          findFirst: {
            args: Prisma.CategoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CategoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          findMany: {
            args: Prisma.CategoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>[]
          }
          create: {
            args: Prisma.CategoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          createMany: {
            args: Prisma.CategoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CategoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>[]
          }
          delete: {
            args: Prisma.CategoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          update: {
            args: Prisma.CategoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          deleteMany: {
            args: Prisma.CategoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CategoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CategoryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>[]
          }
          upsert: {
            args: Prisma.CategoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          aggregate: {
            args: Prisma.CategoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCategory>
          }
          groupBy: {
            args: Prisma.CategoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<CategoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.CategoryCountArgs<ExtArgs>
            result: $Utils.Optional<CategoryCountAggregateOutputType> | number
          }
        }
      }
      Tag: {
        payload: Prisma.$TagPayload<ExtArgs>
        fields: Prisma.TagFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TagFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TagFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          findFirst: {
            args: Prisma.TagFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TagFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          findMany: {
            args: Prisma.TagFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>[]
          }
          create: {
            args: Prisma.TagCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          createMany: {
            args: Prisma.TagCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TagCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>[]
          }
          delete: {
            args: Prisma.TagDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          update: {
            args: Prisma.TagUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          deleteMany: {
            args: Prisma.TagDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TagUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TagUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>[]
          }
          upsert: {
            args: Prisma.TagUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          aggregate: {
            args: Prisma.TagAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTag>
          }
          groupBy: {
            args: Prisma.TagGroupByArgs<ExtArgs>
            result: $Utils.Optional<TagGroupByOutputType>[]
          }
          count: {
            args: Prisma.TagCountArgs<ExtArgs>
            result: $Utils.Optional<TagCountAggregateOutputType> | number
          }
        }
      }
      ProductGallery: {
        payload: Prisma.$ProductGalleryPayload<ExtArgs>
        fields: Prisma.ProductGalleryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProductGalleryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductGalleryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProductGalleryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductGalleryPayload>
          }
          findFirst: {
            args: Prisma.ProductGalleryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductGalleryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProductGalleryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductGalleryPayload>
          }
          findMany: {
            args: Prisma.ProductGalleryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductGalleryPayload>[]
          }
          create: {
            args: Prisma.ProductGalleryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductGalleryPayload>
          }
          createMany: {
            args: Prisma.ProductGalleryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProductGalleryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductGalleryPayload>[]
          }
          delete: {
            args: Prisma.ProductGalleryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductGalleryPayload>
          }
          update: {
            args: Prisma.ProductGalleryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductGalleryPayload>
          }
          deleteMany: {
            args: Prisma.ProductGalleryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProductGalleryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProductGalleryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductGalleryPayload>[]
          }
          upsert: {
            args: Prisma.ProductGalleryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductGalleryPayload>
          }
          aggregate: {
            args: Prisma.ProductGalleryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProductGallery>
          }
          groupBy: {
            args: Prisma.ProductGalleryGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProductGalleryGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProductGalleryCountArgs<ExtArgs>
            result: $Utils.Optional<ProductGalleryCountAggregateOutputType> | number
          }
        }
      }
      Benefit: {
        payload: Prisma.$BenefitPayload<ExtArgs>
        fields: Prisma.BenefitFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BenefitFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BenefitPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BenefitFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BenefitPayload>
          }
          findFirst: {
            args: Prisma.BenefitFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BenefitPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BenefitFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BenefitPayload>
          }
          findMany: {
            args: Prisma.BenefitFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BenefitPayload>[]
          }
          create: {
            args: Prisma.BenefitCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BenefitPayload>
          }
          createMany: {
            args: Prisma.BenefitCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BenefitCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BenefitPayload>[]
          }
          delete: {
            args: Prisma.BenefitDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BenefitPayload>
          }
          update: {
            args: Prisma.BenefitUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BenefitPayload>
          }
          deleteMany: {
            args: Prisma.BenefitDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BenefitUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BenefitUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BenefitPayload>[]
          }
          upsert: {
            args: Prisma.BenefitUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BenefitPayload>
          }
          aggregate: {
            args: Prisma.BenefitAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBenefit>
          }
          groupBy: {
            args: Prisma.BenefitGroupByArgs<ExtArgs>
            result: $Utils.Optional<BenefitGroupByOutputType>[]
          }
          count: {
            args: Prisma.BenefitCountArgs<ExtArgs>
            result: $Utils.Optional<BenefitCountAggregateOutputType> | number
          }
        }
      }
      ProductBenefit: {
        payload: Prisma.$ProductBenefitPayload<ExtArgs>
        fields: Prisma.ProductBenefitFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProductBenefitFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductBenefitPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProductBenefitFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductBenefitPayload>
          }
          findFirst: {
            args: Prisma.ProductBenefitFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductBenefitPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProductBenefitFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductBenefitPayload>
          }
          findMany: {
            args: Prisma.ProductBenefitFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductBenefitPayload>[]
          }
          create: {
            args: Prisma.ProductBenefitCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductBenefitPayload>
          }
          createMany: {
            args: Prisma.ProductBenefitCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProductBenefitCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductBenefitPayload>[]
          }
          delete: {
            args: Prisma.ProductBenefitDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductBenefitPayload>
          }
          update: {
            args: Prisma.ProductBenefitUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductBenefitPayload>
          }
          deleteMany: {
            args: Prisma.ProductBenefitDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProductBenefitUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProductBenefitUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductBenefitPayload>[]
          }
          upsert: {
            args: Prisma.ProductBenefitUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductBenefitPayload>
          }
          aggregate: {
            args: Prisma.ProductBenefitAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProductBenefit>
          }
          groupBy: {
            args: Prisma.ProductBenefitGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProductBenefitGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProductBenefitCountArgs<ExtArgs>
            result: $Utils.Optional<ProductBenefitCountAggregateOutputType> | number
          }
        }
      }
      ProductBenefitPoint: {
        payload: Prisma.$ProductBenefitPointPayload<ExtArgs>
        fields: Prisma.ProductBenefitPointFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProductBenefitPointFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductBenefitPointPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProductBenefitPointFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductBenefitPointPayload>
          }
          findFirst: {
            args: Prisma.ProductBenefitPointFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductBenefitPointPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProductBenefitPointFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductBenefitPointPayload>
          }
          findMany: {
            args: Prisma.ProductBenefitPointFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductBenefitPointPayload>[]
          }
          create: {
            args: Prisma.ProductBenefitPointCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductBenefitPointPayload>
          }
          createMany: {
            args: Prisma.ProductBenefitPointCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProductBenefitPointCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductBenefitPointPayload>[]
          }
          delete: {
            args: Prisma.ProductBenefitPointDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductBenefitPointPayload>
          }
          update: {
            args: Prisma.ProductBenefitPointUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductBenefitPointPayload>
          }
          deleteMany: {
            args: Prisma.ProductBenefitPointDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProductBenefitPointUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProductBenefitPointUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductBenefitPointPayload>[]
          }
          upsert: {
            args: Prisma.ProductBenefitPointUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductBenefitPointPayload>
          }
          aggregate: {
            args: Prisma.ProductBenefitPointAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProductBenefitPoint>
          }
          groupBy: {
            args: Prisma.ProductBenefitPointGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProductBenefitPointGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProductBenefitPointCountArgs<ExtArgs>
            result: $Utils.Optional<ProductBenefitPointCountAggregateOutputType> | number
          }
        }
      }
      Promotion: {
        payload: Prisma.$PromotionPayload<ExtArgs>
        fields: Prisma.PromotionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PromotionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromotionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PromotionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromotionPayload>
          }
          findFirst: {
            args: Prisma.PromotionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromotionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PromotionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromotionPayload>
          }
          findMany: {
            args: Prisma.PromotionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromotionPayload>[]
          }
          create: {
            args: Prisma.PromotionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromotionPayload>
          }
          createMany: {
            args: Prisma.PromotionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PromotionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromotionPayload>[]
          }
          delete: {
            args: Prisma.PromotionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromotionPayload>
          }
          update: {
            args: Prisma.PromotionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromotionPayload>
          }
          deleteMany: {
            args: Prisma.PromotionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PromotionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PromotionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromotionPayload>[]
          }
          upsert: {
            args: Prisma.PromotionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromotionPayload>
          }
          aggregate: {
            args: Prisma.PromotionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePromotion>
          }
          groupBy: {
            args: Prisma.PromotionGroupByArgs<ExtArgs>
            result: $Utils.Optional<PromotionGroupByOutputType>[]
          }
          count: {
            args: Prisma.PromotionCountArgs<ExtArgs>
            result: $Utils.Optional<PromotionCountAggregateOutputType> | number
          }
        }
      }
      Voucher: {
        payload: Prisma.$VoucherPayload<ExtArgs>
        fields: Prisma.VoucherFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VoucherFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VoucherPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VoucherFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VoucherPayload>
          }
          findFirst: {
            args: Prisma.VoucherFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VoucherPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VoucherFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VoucherPayload>
          }
          findMany: {
            args: Prisma.VoucherFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VoucherPayload>[]
          }
          create: {
            args: Prisma.VoucherCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VoucherPayload>
          }
          createMany: {
            args: Prisma.VoucherCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VoucherCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VoucherPayload>[]
          }
          delete: {
            args: Prisma.VoucherDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VoucherPayload>
          }
          update: {
            args: Prisma.VoucherUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VoucherPayload>
          }
          deleteMany: {
            args: Prisma.VoucherDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VoucherUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.VoucherUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VoucherPayload>[]
          }
          upsert: {
            args: Prisma.VoucherUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VoucherPayload>
          }
          aggregate: {
            args: Prisma.VoucherAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVoucher>
          }
          groupBy: {
            args: Prisma.VoucherGroupByArgs<ExtArgs>
            result: $Utils.Optional<VoucherGroupByOutputType>[]
          }
          count: {
            args: Prisma.VoucherCountArgs<ExtArgs>
            result: $Utils.Optional<VoucherCountAggregateOutputType> | number
          }
        }
      }
      VoucherUsage: {
        payload: Prisma.$VoucherUsagePayload<ExtArgs>
        fields: Prisma.VoucherUsageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VoucherUsageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VoucherUsagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VoucherUsageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VoucherUsagePayload>
          }
          findFirst: {
            args: Prisma.VoucherUsageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VoucherUsagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VoucherUsageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VoucherUsagePayload>
          }
          findMany: {
            args: Prisma.VoucherUsageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VoucherUsagePayload>[]
          }
          create: {
            args: Prisma.VoucherUsageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VoucherUsagePayload>
          }
          createMany: {
            args: Prisma.VoucherUsageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VoucherUsageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VoucherUsagePayload>[]
          }
          delete: {
            args: Prisma.VoucherUsageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VoucherUsagePayload>
          }
          update: {
            args: Prisma.VoucherUsageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VoucherUsagePayload>
          }
          deleteMany: {
            args: Prisma.VoucherUsageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VoucherUsageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.VoucherUsageUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VoucherUsagePayload>[]
          }
          upsert: {
            args: Prisma.VoucherUsageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VoucherUsagePayload>
          }
          aggregate: {
            args: Prisma.VoucherUsageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVoucherUsage>
          }
          groupBy: {
            args: Prisma.VoucherUsageGroupByArgs<ExtArgs>
            result: $Utils.Optional<VoucherUsageGroupByOutputType>[]
          }
          count: {
            args: Prisma.VoucherUsageCountArgs<ExtArgs>
            result: $Utils.Optional<VoucherUsageCountAggregateOutputType> | number
          }
        }
      }
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Authenticator: {
        payload: Prisma.$AuthenticatorPayload<ExtArgs>
        fields: Prisma.AuthenticatorFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AuthenticatorFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuthenticatorPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AuthenticatorFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuthenticatorPayload>
          }
          findFirst: {
            args: Prisma.AuthenticatorFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuthenticatorPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AuthenticatorFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuthenticatorPayload>
          }
          findMany: {
            args: Prisma.AuthenticatorFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuthenticatorPayload>[]
          }
          create: {
            args: Prisma.AuthenticatorCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuthenticatorPayload>
          }
          createMany: {
            args: Prisma.AuthenticatorCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AuthenticatorCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuthenticatorPayload>[]
          }
          delete: {
            args: Prisma.AuthenticatorDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuthenticatorPayload>
          }
          update: {
            args: Prisma.AuthenticatorUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuthenticatorPayload>
          }
          deleteMany: {
            args: Prisma.AuthenticatorDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AuthenticatorUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AuthenticatorUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuthenticatorPayload>[]
          }
          upsert: {
            args: Prisma.AuthenticatorUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuthenticatorPayload>
          }
          aggregate: {
            args: Prisma.AuthenticatorAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAuthenticator>
          }
          groupBy: {
            args: Prisma.AuthenticatorGroupByArgs<ExtArgs>
            result: $Utils.Optional<AuthenticatorGroupByOutputType>[]
          }
          count: {
            args: Prisma.AuthenticatorCountArgs<ExtArgs>
            result: $Utils.Optional<AuthenticatorCountAggregateOutputType> | number
          }
        }
      }
      Order: {
        payload: Prisma.$OrderPayload<ExtArgs>
        fields: Prisma.OrderFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OrderFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OrderFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          findFirst: {
            args: Prisma.OrderFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OrderFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          findMany: {
            args: Prisma.OrderFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>[]
          }
          create: {
            args: Prisma.OrderCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          createMany: {
            args: Prisma.OrderCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OrderCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>[]
          }
          delete: {
            args: Prisma.OrderDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          update: {
            args: Prisma.OrderUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          deleteMany: {
            args: Prisma.OrderDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OrderUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.OrderUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>[]
          }
          upsert: {
            args: Prisma.OrderUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          aggregate: {
            args: Prisma.OrderAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOrder>
          }
          groupBy: {
            args: Prisma.OrderGroupByArgs<ExtArgs>
            result: $Utils.Optional<OrderGroupByOutputType>[]
          }
          count: {
            args: Prisma.OrderCountArgs<ExtArgs>
            result: $Utils.Optional<OrderCountAggregateOutputType> | number
          }
        }
      }
      Menu: {
        payload: Prisma.$MenuPayload<ExtArgs>
        fields: Prisma.MenuFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MenuFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenuPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MenuFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenuPayload>
          }
          findFirst: {
            args: Prisma.MenuFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenuPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MenuFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenuPayload>
          }
          findMany: {
            args: Prisma.MenuFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenuPayload>[]
          }
          create: {
            args: Prisma.MenuCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenuPayload>
          }
          createMany: {
            args: Prisma.MenuCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MenuCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenuPayload>[]
          }
          delete: {
            args: Prisma.MenuDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenuPayload>
          }
          update: {
            args: Prisma.MenuUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenuPayload>
          }
          deleteMany: {
            args: Prisma.MenuDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MenuUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MenuUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenuPayload>[]
          }
          upsert: {
            args: Prisma.MenuUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenuPayload>
          }
          aggregate: {
            args: Prisma.MenuAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMenu>
          }
          groupBy: {
            args: Prisma.MenuGroupByArgs<ExtArgs>
            result: $Utils.Optional<MenuGroupByOutputType>[]
          }
          count: {
            args: Prisma.MenuCountArgs<ExtArgs>
            result: $Utils.Optional<MenuCountAggregateOutputType> | number
          }
        }
      }
      FooterInfo: {
        payload: Prisma.$FooterInfoPayload<ExtArgs>
        fields: Prisma.FooterInfoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FooterInfoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FooterInfoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FooterInfoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FooterInfoPayload>
          }
          findFirst: {
            args: Prisma.FooterInfoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FooterInfoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FooterInfoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FooterInfoPayload>
          }
          findMany: {
            args: Prisma.FooterInfoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FooterInfoPayload>[]
          }
          create: {
            args: Prisma.FooterInfoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FooterInfoPayload>
          }
          createMany: {
            args: Prisma.FooterInfoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FooterInfoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FooterInfoPayload>[]
          }
          delete: {
            args: Prisma.FooterInfoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FooterInfoPayload>
          }
          update: {
            args: Prisma.FooterInfoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FooterInfoPayload>
          }
          deleteMany: {
            args: Prisma.FooterInfoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FooterInfoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FooterInfoUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FooterInfoPayload>[]
          }
          upsert: {
            args: Prisma.FooterInfoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FooterInfoPayload>
          }
          aggregate: {
            args: Prisma.FooterInfoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFooterInfo>
          }
          groupBy: {
            args: Prisma.FooterInfoGroupByArgs<ExtArgs>
            result: $Utils.Optional<FooterInfoGroupByOutputType>[]
          }
          count: {
            args: Prisma.FooterInfoCountArgs<ExtArgs>
            result: $Utils.Optional<FooterInfoCountAggregateOutputType> | number
          }
        }
      }
      Account: {
        payload: Prisma.$AccountPayload<ExtArgs>
        fields: Prisma.AccountFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AccountFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AccountFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          findFirst: {
            args: Prisma.AccountFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AccountFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          findMany: {
            args: Prisma.AccountFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          create: {
            args: Prisma.AccountCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          createMany: {
            args: Prisma.AccountCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AccountCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          delete: {
            args: Prisma.AccountDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          update: {
            args: Prisma.AccountUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          deleteMany: {
            args: Prisma.AccountDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AccountUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AccountUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          upsert: {
            args: Prisma.AccountUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          aggregate: {
            args: Prisma.AccountAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAccount>
          }
          groupBy: {
            args: Prisma.AccountGroupByArgs<ExtArgs>
            result: $Utils.Optional<AccountGroupByOutputType>[]
          }
          count: {
            args: Prisma.AccountCountArgs<ExtArgs>
            result: $Utils.Optional<AccountCountAggregateOutputType> | number
          }
        }
      }
      Session: {
        payload: Prisma.$SessionPayload<ExtArgs>
        fields: Prisma.SessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findFirst: {
            args: Prisma.SessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findMany: {
            args: Prisma.SessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          create: {
            args: Prisma.SessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          createMany: {
            args: Prisma.SessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SessionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          delete: {
            args: Prisma.SessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          update: {
            args: Prisma.SessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          deleteMany: {
            args: Prisma.SessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SessionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          upsert: {
            args: Prisma.SessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          aggregate: {
            args: Prisma.SessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSession>
          }
          groupBy: {
            args: Prisma.SessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<SessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.SessionCountArgs<ExtArgs>
            result: $Utils.Optional<SessionCountAggregateOutputType> | number
          }
        }
      }
      VerificationToken: {
        payload: Prisma.$VerificationTokenPayload<ExtArgs>
        fields: Prisma.VerificationTokenFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VerificationTokenFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VerificationTokenFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          findFirst: {
            args: Prisma.VerificationTokenFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VerificationTokenFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          findMany: {
            args: Prisma.VerificationTokenFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>[]
          }
          create: {
            args: Prisma.VerificationTokenCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          createMany: {
            args: Prisma.VerificationTokenCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VerificationTokenCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>[]
          }
          delete: {
            args: Prisma.VerificationTokenDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          update: {
            args: Prisma.VerificationTokenUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          deleteMany: {
            args: Prisma.VerificationTokenDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VerificationTokenUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.VerificationTokenUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>[]
          }
          upsert: {
            args: Prisma.VerificationTokenUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          aggregate: {
            args: Prisma.VerificationTokenAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVerificationToken>
          }
          groupBy: {
            args: Prisma.VerificationTokenGroupByArgs<ExtArgs>
            result: $Utils.Optional<VerificationTokenGroupByOutputType>[]
          }
          count: {
            args: Prisma.VerificationTokenCountArgs<ExtArgs>
            result: $Utils.Optional<VerificationTokenCountAggregateOutputType> | number
          }
        }
      }
      LandingPage: {
        payload: Prisma.$LandingPagePayload<ExtArgs>
        fields: Prisma.LandingPageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LandingPageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LandingPagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LandingPageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LandingPagePayload>
          }
          findFirst: {
            args: Prisma.LandingPageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LandingPagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LandingPageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LandingPagePayload>
          }
          findMany: {
            args: Prisma.LandingPageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LandingPagePayload>[]
          }
          create: {
            args: Prisma.LandingPageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LandingPagePayload>
          }
          createMany: {
            args: Prisma.LandingPageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LandingPageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LandingPagePayload>[]
          }
          delete: {
            args: Prisma.LandingPageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LandingPagePayload>
          }
          update: {
            args: Prisma.LandingPageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LandingPagePayload>
          }
          deleteMany: {
            args: Prisma.LandingPageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LandingPageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LandingPageUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LandingPagePayload>[]
          }
          upsert: {
            args: Prisma.LandingPageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LandingPagePayload>
          }
          aggregate: {
            args: Prisma.LandingPageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLandingPage>
          }
          groupBy: {
            args: Prisma.LandingPageGroupByArgs<ExtArgs>
            result: $Utils.Optional<LandingPageGroupByOutputType>[]
          }
          count: {
            args: Prisma.LandingPageCountArgs<ExtArgs>
            result: $Utils.Optional<LandingPageCountAggregateOutputType> | number
          }
        }
      }
      LpFor: {
        payload: Prisma.$LpForPayload<ExtArgs>
        fields: Prisma.LpForFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LpForFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LpForPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LpForFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LpForPayload>
          }
          findFirst: {
            args: Prisma.LpForFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LpForPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LpForFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LpForPayload>
          }
          findMany: {
            args: Prisma.LpForFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LpForPayload>[]
          }
          create: {
            args: Prisma.LpForCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LpForPayload>
          }
          createMany: {
            args: Prisma.LpForCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LpForCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LpForPayload>[]
          }
          delete: {
            args: Prisma.LpForDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LpForPayload>
          }
          update: {
            args: Prisma.LpForUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LpForPayload>
          }
          deleteMany: {
            args: Prisma.LpForDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LpForUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LpForUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LpForPayload>[]
          }
          upsert: {
            args: Prisma.LpForUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LpForPayload>
          }
          aggregate: {
            args: Prisma.LpForAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLpFor>
          }
          groupBy: {
            args: Prisma.LpForGroupByArgs<ExtArgs>
            result: $Utils.Optional<LpForGroupByOutputType>[]
          }
          count: {
            args: Prisma.LpForCountArgs<ExtArgs>
            result: $Utils.Optional<LpForCountAggregateOutputType> | number
          }
        }
      }
      LpContentType: {
        payload: Prisma.$LpContentTypePayload<ExtArgs>
        fields: Prisma.LpContentTypeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LpContentTypeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LpContentTypePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LpContentTypeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LpContentTypePayload>
          }
          findFirst: {
            args: Prisma.LpContentTypeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LpContentTypePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LpContentTypeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LpContentTypePayload>
          }
          findMany: {
            args: Prisma.LpContentTypeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LpContentTypePayload>[]
          }
          create: {
            args: Prisma.LpContentTypeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LpContentTypePayload>
          }
          createMany: {
            args: Prisma.LpContentTypeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LpContentTypeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LpContentTypePayload>[]
          }
          delete: {
            args: Prisma.LpContentTypeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LpContentTypePayload>
          }
          update: {
            args: Prisma.LpContentTypeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LpContentTypePayload>
          }
          deleteMany: {
            args: Prisma.LpContentTypeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LpContentTypeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LpContentTypeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LpContentTypePayload>[]
          }
          upsert: {
            args: Prisma.LpContentTypeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LpContentTypePayload>
          }
          aggregate: {
            args: Prisma.LpContentTypeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLpContentType>
          }
          groupBy: {
            args: Prisma.LpContentTypeGroupByArgs<ExtArgs>
            result: $Utils.Optional<LpContentTypeGroupByOutputType>[]
          }
          count: {
            args: Prisma.LpContentTypeCountArgs<ExtArgs>
            result: $Utils.Optional<LpContentTypeCountAggregateOutputType> | number
          }
        }
      }
      LpDesignStyle: {
        payload: Prisma.$LpDesignStylePayload<ExtArgs>
        fields: Prisma.LpDesignStyleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LpDesignStyleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LpDesignStylePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LpDesignStyleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LpDesignStylePayload>
          }
          findFirst: {
            args: Prisma.LpDesignStyleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LpDesignStylePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LpDesignStyleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LpDesignStylePayload>
          }
          findMany: {
            args: Prisma.LpDesignStyleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LpDesignStylePayload>[]
          }
          create: {
            args: Prisma.LpDesignStyleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LpDesignStylePayload>
          }
          createMany: {
            args: Prisma.LpDesignStyleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LpDesignStyleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LpDesignStylePayload>[]
          }
          delete: {
            args: Prisma.LpDesignStyleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LpDesignStylePayload>
          }
          update: {
            args: Prisma.LpDesignStyleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LpDesignStylePayload>
          }
          deleteMany: {
            args: Prisma.LpDesignStyleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LpDesignStyleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LpDesignStyleUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LpDesignStylePayload>[]
          }
          upsert: {
            args: Prisma.LpDesignStyleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LpDesignStylePayload>
          }
          aggregate: {
            args: Prisma.LpDesignStyleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLpDesignStyle>
          }
          groupBy: {
            args: Prisma.LpDesignStyleGroupByArgs<ExtArgs>
            result: $Utils.Optional<LpDesignStyleGroupByOutputType>[]
          }
          count: {
            args: Prisma.LpDesignStyleCountArgs<ExtArgs>
            result: $Utils.Optional<LpDesignStyleCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    registerForm?: RegisterFormOmit
    apiList?: ApiListOmit
    facebookPixel?: FacebookPixelOmit
    siteIdentity?: SiteIdentityOmit
    socialLinks?: SocialLinksOmit
    page?: PageOmit
    section?: SectionOmit
    listItem?: ListItemOmit
    listEntry?: ListEntryOmit
    product?: ProductOmit
    category?: CategoryOmit
    tag?: TagOmit
    productGallery?: ProductGalleryOmit
    benefit?: BenefitOmit
    productBenefit?: ProductBenefitOmit
    productBenefitPoint?: ProductBenefitPointOmit
    promotion?: PromotionOmit
    voucher?: VoucherOmit
    voucherUsage?: VoucherUsageOmit
    user?: UserOmit
    authenticator?: AuthenticatorOmit
    order?: OrderOmit
    menu?: MenuOmit
    footerInfo?: FooterInfoOmit
    account?: AccountOmit
    session?: SessionOmit
    verificationToken?: VerificationTokenOmit
    landingPage?: LandingPageOmit
    lpFor?: LpForOmit
    lpContentType?: LpContentTypeOmit
    lpDesignStyle?: LpDesignStyleOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type SiteIdentityCountOutputType
   */

  export type SiteIdentityCountOutputType = {
    socialLinks: number
  }

  export type SiteIdentityCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    socialLinks?: boolean | SiteIdentityCountOutputTypeCountSocialLinksArgs
  }

  // Custom InputTypes
  /**
   * SiteIdentityCountOutputType without action
   */
  export type SiteIdentityCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SiteIdentityCountOutputType
     */
    select?: SiteIdentityCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SiteIdentityCountOutputType without action
   */
  export type SiteIdentityCountOutputTypeCountSocialLinksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SocialLinksWhereInput
  }


  /**
   * Count Type PageCountOutputType
   */

  export type PageCountOutputType = {
    sections: number
  }

  export type PageCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sections?: boolean | PageCountOutputTypeCountSectionsArgs
  }

  // Custom InputTypes
  /**
   * PageCountOutputType without action
   */
  export type PageCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PageCountOutputType
     */
    select?: PageCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PageCountOutputType without action
   */
  export type PageCountOutputTypeCountSectionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SectionWhereInput
  }


  /**
   * Count Type SectionCountOutputType
   */

  export type SectionCountOutputType = {
    listItems: number
  }

  export type SectionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    listItems?: boolean | SectionCountOutputTypeCountListItemsArgs
  }

  // Custom InputTypes
  /**
   * SectionCountOutputType without action
   */
  export type SectionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SectionCountOutputType
     */
    select?: SectionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SectionCountOutputType without action
   */
  export type SectionCountOutputTypeCountListItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ListItemWhereInput
  }


  /**
   * Count Type ListItemCountOutputType
   */

  export type ListItemCountOutputType = {
    entries: number
  }

  export type ListItemCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    entries?: boolean | ListItemCountOutputTypeCountEntriesArgs
  }

  // Custom InputTypes
  /**
   * ListItemCountOutputType without action
   */
  export type ListItemCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ListItemCountOutputType
     */
    select?: ListItemCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ListItemCountOutputType without action
   */
  export type ListItemCountOutputTypeCountEntriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ListEntryWhereInput
  }


  /**
   * Count Type ProductCountOutputType
   */

  export type ProductCountOutputType = {
    tags: number
    gallery: number
    benefits: number
    benefitPoints: number
    promotions: number
    vouchers: number
    orders: number
  }

  export type ProductCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tags?: boolean | ProductCountOutputTypeCountTagsArgs
    gallery?: boolean | ProductCountOutputTypeCountGalleryArgs
    benefits?: boolean | ProductCountOutputTypeCountBenefitsArgs
    benefitPoints?: boolean | ProductCountOutputTypeCountBenefitPointsArgs
    promotions?: boolean | ProductCountOutputTypeCountPromotionsArgs
    vouchers?: boolean | ProductCountOutputTypeCountVouchersArgs
    orders?: boolean | ProductCountOutputTypeCountOrdersArgs
  }

  // Custom InputTypes
  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCountOutputType
     */
    select?: ProductCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountTagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TagWhereInput
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountGalleryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductGalleryWhereInput
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountBenefitsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductBenefitWhereInput
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountBenefitPointsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductBenefitPointWhereInput
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountPromotionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PromotionWhereInput
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountVouchersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VoucherWhereInput
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderWhereInput
  }


  /**
   * Count Type CategoryCountOutputType
   */

  export type CategoryCountOutputType = {
    products: number
  }

  export type CategoryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    products?: boolean | CategoryCountOutputTypeCountProductsArgs
  }

  // Custom InputTypes
  /**
   * CategoryCountOutputType without action
   */
  export type CategoryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoryCountOutputType
     */
    select?: CategoryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CategoryCountOutputType without action
   */
  export type CategoryCountOutputTypeCountProductsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductWhereInput
  }


  /**
   * Count Type TagCountOutputType
   */

  export type TagCountOutputType = {
    products: number
  }

  export type TagCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    products?: boolean | TagCountOutputTypeCountProductsArgs
  }

  // Custom InputTypes
  /**
   * TagCountOutputType without action
   */
  export type TagCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TagCountOutputType
     */
    select?: TagCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TagCountOutputType without action
   */
  export type TagCountOutputTypeCountProductsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductWhereInput
  }


  /**
   * Count Type BenefitCountOutputType
   */

  export type BenefitCountOutputType = {
    products: number
  }

  export type BenefitCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    products?: boolean | BenefitCountOutputTypeCountProductsArgs
  }

  // Custom InputTypes
  /**
   * BenefitCountOutputType without action
   */
  export type BenefitCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BenefitCountOutputType
     */
    select?: BenefitCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BenefitCountOutputType without action
   */
  export type BenefitCountOutputTypeCountProductsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductBenefitWhereInput
  }


  /**
   * Count Type PromotionCountOutputType
   */

  export type PromotionCountOutputType = {
    products: number
  }

  export type PromotionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    products?: boolean | PromotionCountOutputTypeCountProductsArgs
  }

  // Custom InputTypes
  /**
   * PromotionCountOutputType without action
   */
  export type PromotionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromotionCountOutputType
     */
    select?: PromotionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PromotionCountOutputType without action
   */
  export type PromotionCountOutputTypeCountProductsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductWhereInput
  }


  /**
   * Count Type VoucherCountOutputType
   */

  export type VoucherCountOutputType = {
    products: number
    usages: number
    orders: number
  }

  export type VoucherCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    products?: boolean | VoucherCountOutputTypeCountProductsArgs
    usages?: boolean | VoucherCountOutputTypeCountUsagesArgs
    orders?: boolean | VoucherCountOutputTypeCountOrdersArgs
  }

  // Custom InputTypes
  /**
   * VoucherCountOutputType without action
   */
  export type VoucherCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VoucherCountOutputType
     */
    select?: VoucherCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * VoucherCountOutputType without action
   */
  export type VoucherCountOutputTypeCountProductsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductWhereInput
  }

  /**
   * VoucherCountOutputType without action
   */
  export type VoucherCountOutputTypeCountUsagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VoucherUsageWhereInput
  }

  /**
   * VoucherCountOutputType without action
   */
  export type VoucherCountOutputTypeCountOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderWhereInput
  }


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    orders: number
    accounts: number
    sessions: number
    vouchers: number
    Authenticator: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    orders?: boolean | UserCountOutputTypeCountOrdersArgs
    accounts?: boolean | UserCountOutputTypeCountAccountsArgs
    sessions?: boolean | UserCountOutputTypeCountSessionsArgs
    vouchers?: boolean | UserCountOutputTypeCountVouchersArgs
    Authenticator?: boolean | UserCountOutputTypeCountAuthenticatorArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAccountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountVouchersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VoucherUsageWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAuthenticatorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuthenticatorWhereInput
  }


  /**
   * Count Type OrderCountOutputType
   */

  export type OrderCountOutputType = {
    products: number
  }

  export type OrderCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    products?: boolean | OrderCountOutputTypeCountProductsArgs
  }

  // Custom InputTypes
  /**
   * OrderCountOutputType without action
   */
  export type OrderCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderCountOutputType
     */
    select?: OrderCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * OrderCountOutputType without action
   */
  export type OrderCountOutputTypeCountProductsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductWhereInput
  }


  /**
   * Count Type MenuCountOutputType
   */

  export type MenuCountOutputType = {
    children: number
  }

  export type MenuCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    children?: boolean | MenuCountOutputTypeCountChildrenArgs
  }

  // Custom InputTypes
  /**
   * MenuCountOutputType without action
   */
  export type MenuCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MenuCountOutputType
     */
    select?: MenuCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MenuCountOutputType without action
   */
  export type MenuCountOutputTypeCountChildrenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MenuWhereInput
  }


  /**
   * Count Type LandingPageCountOutputType
   */

  export type LandingPageCountOutputType = {
    lpFor: number
    lpContentTypes: number
  }

  export type LandingPageCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lpFor?: boolean | LandingPageCountOutputTypeCountLpForArgs
    lpContentTypes?: boolean | LandingPageCountOutputTypeCountLpContentTypesArgs
  }

  // Custom InputTypes
  /**
   * LandingPageCountOutputType without action
   */
  export type LandingPageCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LandingPageCountOutputType
     */
    select?: LandingPageCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * LandingPageCountOutputType without action
   */
  export type LandingPageCountOutputTypeCountLpForArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LpForWhereInput
  }

  /**
   * LandingPageCountOutputType without action
   */
  export type LandingPageCountOutputTypeCountLpContentTypesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LpContentTypeWhereInput
  }


  /**
   * Count Type LpForCountOutputType
   */

  export type LpForCountOutputType = {
    landingPages: number
  }

  export type LpForCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    landingPages?: boolean | LpForCountOutputTypeCountLandingPagesArgs
  }

  // Custom InputTypes
  /**
   * LpForCountOutputType without action
   */
  export type LpForCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LpForCountOutputType
     */
    select?: LpForCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * LpForCountOutputType without action
   */
  export type LpForCountOutputTypeCountLandingPagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LandingPageWhereInput
  }


  /**
   * Count Type LpContentTypeCountOutputType
   */

  export type LpContentTypeCountOutputType = {
    landingPages: number
  }

  export type LpContentTypeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    landingPages?: boolean | LpContentTypeCountOutputTypeCountLandingPagesArgs
  }

  // Custom InputTypes
  /**
   * LpContentTypeCountOutputType without action
   */
  export type LpContentTypeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LpContentTypeCountOutputType
     */
    select?: LpContentTypeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * LpContentTypeCountOutputType without action
   */
  export type LpContentTypeCountOutputTypeCountLandingPagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LandingPageWhereInput
  }


  /**
   * Count Type LpDesignStyleCountOutputType
   */

  export type LpDesignStyleCountOutputType = {
    templates: number
  }

  export type LpDesignStyleCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    templates?: boolean | LpDesignStyleCountOutputTypeCountTemplatesArgs
  }

  // Custom InputTypes
  /**
   * LpDesignStyleCountOutputType without action
   */
  export type LpDesignStyleCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LpDesignStyleCountOutputType
     */
    select?: LpDesignStyleCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * LpDesignStyleCountOutputType without action
   */
  export type LpDesignStyleCountOutputTypeCountTemplatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LandingPageWhereInput
  }


  /**
   * Models
   */

  /**
   * Model RegisterForm
   */

  export type AggregateRegisterForm = {
    _count: RegisterFormCountAggregateOutputType | null
    _avg: RegisterFormAvgAggregateOutputType | null
    _sum: RegisterFormSumAggregateOutputType | null
    _min: RegisterFormMinAggregateOutputType | null
    _max: RegisterFormMaxAggregateOutputType | null
  }

  export type RegisterFormAvgAggregateOutputType = {
    id: number | null
    position: number | null
    row: number | null
  }

  export type RegisterFormSumAggregateOutputType = {
    id: number | null
    position: number | null
    row: number | null
  }

  export type RegisterFormMinAggregateOutputType = {
    id: number | null
    name: string | null
    type: string | null
    placeholder: string | null
    position: number | null
    row: number | null
    options: string | null
    required: boolean | null
    hint: string | null
    hintTrue: string | null
    hintFalse: string | null
    isActive: boolean | null
    createDate: Date | null
    updateDate: Date | null
  }

  export type RegisterFormMaxAggregateOutputType = {
    id: number | null
    name: string | null
    type: string | null
    placeholder: string | null
    position: number | null
    row: number | null
    options: string | null
    required: boolean | null
    hint: string | null
    hintTrue: string | null
    hintFalse: string | null
    isActive: boolean | null
    createDate: Date | null
    updateDate: Date | null
  }

  export type RegisterFormCountAggregateOutputType = {
    id: number
    name: number
    type: number
    placeholder: number
    position: number
    row: number
    options: number
    required: number
    hint: number
    hintTrue: number
    hintFalse: number
    isActive: number
    createDate: number
    updateDate: number
    _all: number
  }


  export type RegisterFormAvgAggregateInputType = {
    id?: true
    position?: true
    row?: true
  }

  export type RegisterFormSumAggregateInputType = {
    id?: true
    position?: true
    row?: true
  }

  export type RegisterFormMinAggregateInputType = {
    id?: true
    name?: true
    type?: true
    placeholder?: true
    position?: true
    row?: true
    options?: true
    required?: true
    hint?: true
    hintTrue?: true
    hintFalse?: true
    isActive?: true
    createDate?: true
    updateDate?: true
  }

  export type RegisterFormMaxAggregateInputType = {
    id?: true
    name?: true
    type?: true
    placeholder?: true
    position?: true
    row?: true
    options?: true
    required?: true
    hint?: true
    hintTrue?: true
    hintFalse?: true
    isActive?: true
    createDate?: true
    updateDate?: true
  }

  export type RegisterFormCountAggregateInputType = {
    id?: true
    name?: true
    type?: true
    placeholder?: true
    position?: true
    row?: true
    options?: true
    required?: true
    hint?: true
    hintTrue?: true
    hintFalse?: true
    isActive?: true
    createDate?: true
    updateDate?: true
    _all?: true
  }

  export type RegisterFormAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RegisterForm to aggregate.
     */
    where?: RegisterFormWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RegisterForms to fetch.
     */
    orderBy?: RegisterFormOrderByWithRelationInput | RegisterFormOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RegisterFormWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RegisterForms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RegisterForms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RegisterForms
    **/
    _count?: true | RegisterFormCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RegisterFormAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RegisterFormSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RegisterFormMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RegisterFormMaxAggregateInputType
  }

  export type GetRegisterFormAggregateType<T extends RegisterFormAggregateArgs> = {
        [P in keyof T & keyof AggregateRegisterForm]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRegisterForm[P]>
      : GetScalarType<T[P], AggregateRegisterForm[P]>
  }




  export type RegisterFormGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RegisterFormWhereInput
    orderBy?: RegisterFormOrderByWithAggregationInput | RegisterFormOrderByWithAggregationInput[]
    by: RegisterFormScalarFieldEnum[] | RegisterFormScalarFieldEnum
    having?: RegisterFormScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RegisterFormCountAggregateInputType | true
    _avg?: RegisterFormAvgAggregateInputType
    _sum?: RegisterFormSumAggregateInputType
    _min?: RegisterFormMinAggregateInputType
    _max?: RegisterFormMaxAggregateInputType
  }

  export type RegisterFormGroupByOutputType = {
    id: number
    name: string
    type: string
    placeholder: string
    position: number
    row: number
    options: string | null
    required: boolean
    hint: string | null
    hintTrue: string
    hintFalse: string
    isActive: boolean
    createDate: Date
    updateDate: Date
    _count: RegisterFormCountAggregateOutputType | null
    _avg: RegisterFormAvgAggregateOutputType | null
    _sum: RegisterFormSumAggregateOutputType | null
    _min: RegisterFormMinAggregateOutputType | null
    _max: RegisterFormMaxAggregateOutputType | null
  }

  type GetRegisterFormGroupByPayload<T extends RegisterFormGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RegisterFormGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RegisterFormGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RegisterFormGroupByOutputType[P]>
            : GetScalarType<T[P], RegisterFormGroupByOutputType[P]>
        }
      >
    >


  export type RegisterFormSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    placeholder?: boolean
    position?: boolean
    row?: boolean
    options?: boolean
    required?: boolean
    hint?: boolean
    hintTrue?: boolean
    hintFalse?: boolean
    isActive?: boolean
    createDate?: boolean
    updateDate?: boolean
  }, ExtArgs["result"]["registerForm"]>

  export type RegisterFormSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    placeholder?: boolean
    position?: boolean
    row?: boolean
    options?: boolean
    required?: boolean
    hint?: boolean
    hintTrue?: boolean
    hintFalse?: boolean
    isActive?: boolean
    createDate?: boolean
    updateDate?: boolean
  }, ExtArgs["result"]["registerForm"]>

  export type RegisterFormSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    placeholder?: boolean
    position?: boolean
    row?: boolean
    options?: boolean
    required?: boolean
    hint?: boolean
    hintTrue?: boolean
    hintFalse?: boolean
    isActive?: boolean
    createDate?: boolean
    updateDate?: boolean
  }, ExtArgs["result"]["registerForm"]>

  export type RegisterFormSelectScalar = {
    id?: boolean
    name?: boolean
    type?: boolean
    placeholder?: boolean
    position?: boolean
    row?: boolean
    options?: boolean
    required?: boolean
    hint?: boolean
    hintTrue?: boolean
    hintFalse?: boolean
    isActive?: boolean
    createDate?: boolean
    updateDate?: boolean
  }

  export type RegisterFormOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "type" | "placeholder" | "position" | "row" | "options" | "required" | "hint" | "hintTrue" | "hintFalse" | "isActive" | "createDate" | "updateDate", ExtArgs["result"]["registerForm"]>

  export type $RegisterFormPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RegisterForm"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      type: string
      placeholder: string
      position: number
      row: number
      options: string | null
      required: boolean
      hint: string | null
      hintTrue: string
      hintFalse: string
      isActive: boolean
      createDate: Date
      updateDate: Date
    }, ExtArgs["result"]["registerForm"]>
    composites: {}
  }

  type RegisterFormGetPayload<S extends boolean | null | undefined | RegisterFormDefaultArgs> = $Result.GetResult<Prisma.$RegisterFormPayload, S>

  type RegisterFormCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RegisterFormFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RegisterFormCountAggregateInputType | true
    }

  export interface RegisterFormDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RegisterForm'], meta: { name: 'RegisterForm' } }
    /**
     * Find zero or one RegisterForm that matches the filter.
     * @param {RegisterFormFindUniqueArgs} args - Arguments to find a RegisterForm
     * @example
     * // Get one RegisterForm
     * const registerForm = await prisma.registerForm.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RegisterFormFindUniqueArgs>(args: SelectSubset<T, RegisterFormFindUniqueArgs<ExtArgs>>): Prisma__RegisterFormClient<$Result.GetResult<Prisma.$RegisterFormPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RegisterForm that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RegisterFormFindUniqueOrThrowArgs} args - Arguments to find a RegisterForm
     * @example
     * // Get one RegisterForm
     * const registerForm = await prisma.registerForm.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RegisterFormFindUniqueOrThrowArgs>(args: SelectSubset<T, RegisterFormFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RegisterFormClient<$Result.GetResult<Prisma.$RegisterFormPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RegisterForm that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegisterFormFindFirstArgs} args - Arguments to find a RegisterForm
     * @example
     * // Get one RegisterForm
     * const registerForm = await prisma.registerForm.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RegisterFormFindFirstArgs>(args?: SelectSubset<T, RegisterFormFindFirstArgs<ExtArgs>>): Prisma__RegisterFormClient<$Result.GetResult<Prisma.$RegisterFormPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RegisterForm that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegisterFormFindFirstOrThrowArgs} args - Arguments to find a RegisterForm
     * @example
     * // Get one RegisterForm
     * const registerForm = await prisma.registerForm.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RegisterFormFindFirstOrThrowArgs>(args?: SelectSubset<T, RegisterFormFindFirstOrThrowArgs<ExtArgs>>): Prisma__RegisterFormClient<$Result.GetResult<Prisma.$RegisterFormPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RegisterForms that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegisterFormFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RegisterForms
     * const registerForms = await prisma.registerForm.findMany()
     * 
     * // Get first 10 RegisterForms
     * const registerForms = await prisma.registerForm.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const registerFormWithIdOnly = await prisma.registerForm.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RegisterFormFindManyArgs>(args?: SelectSubset<T, RegisterFormFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RegisterFormPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RegisterForm.
     * @param {RegisterFormCreateArgs} args - Arguments to create a RegisterForm.
     * @example
     * // Create one RegisterForm
     * const RegisterForm = await prisma.registerForm.create({
     *   data: {
     *     // ... data to create a RegisterForm
     *   }
     * })
     * 
     */
    create<T extends RegisterFormCreateArgs>(args: SelectSubset<T, RegisterFormCreateArgs<ExtArgs>>): Prisma__RegisterFormClient<$Result.GetResult<Prisma.$RegisterFormPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RegisterForms.
     * @param {RegisterFormCreateManyArgs} args - Arguments to create many RegisterForms.
     * @example
     * // Create many RegisterForms
     * const registerForm = await prisma.registerForm.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RegisterFormCreateManyArgs>(args?: SelectSubset<T, RegisterFormCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RegisterForms and returns the data saved in the database.
     * @param {RegisterFormCreateManyAndReturnArgs} args - Arguments to create many RegisterForms.
     * @example
     * // Create many RegisterForms
     * const registerForm = await prisma.registerForm.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RegisterForms and only return the `id`
     * const registerFormWithIdOnly = await prisma.registerForm.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RegisterFormCreateManyAndReturnArgs>(args?: SelectSubset<T, RegisterFormCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RegisterFormPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a RegisterForm.
     * @param {RegisterFormDeleteArgs} args - Arguments to delete one RegisterForm.
     * @example
     * // Delete one RegisterForm
     * const RegisterForm = await prisma.registerForm.delete({
     *   where: {
     *     // ... filter to delete one RegisterForm
     *   }
     * })
     * 
     */
    delete<T extends RegisterFormDeleteArgs>(args: SelectSubset<T, RegisterFormDeleteArgs<ExtArgs>>): Prisma__RegisterFormClient<$Result.GetResult<Prisma.$RegisterFormPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RegisterForm.
     * @param {RegisterFormUpdateArgs} args - Arguments to update one RegisterForm.
     * @example
     * // Update one RegisterForm
     * const registerForm = await prisma.registerForm.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RegisterFormUpdateArgs>(args: SelectSubset<T, RegisterFormUpdateArgs<ExtArgs>>): Prisma__RegisterFormClient<$Result.GetResult<Prisma.$RegisterFormPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RegisterForms.
     * @param {RegisterFormDeleteManyArgs} args - Arguments to filter RegisterForms to delete.
     * @example
     * // Delete a few RegisterForms
     * const { count } = await prisma.registerForm.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RegisterFormDeleteManyArgs>(args?: SelectSubset<T, RegisterFormDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RegisterForms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegisterFormUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RegisterForms
     * const registerForm = await prisma.registerForm.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RegisterFormUpdateManyArgs>(args: SelectSubset<T, RegisterFormUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RegisterForms and returns the data updated in the database.
     * @param {RegisterFormUpdateManyAndReturnArgs} args - Arguments to update many RegisterForms.
     * @example
     * // Update many RegisterForms
     * const registerForm = await prisma.registerForm.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more RegisterForms and only return the `id`
     * const registerFormWithIdOnly = await prisma.registerForm.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RegisterFormUpdateManyAndReturnArgs>(args: SelectSubset<T, RegisterFormUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RegisterFormPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one RegisterForm.
     * @param {RegisterFormUpsertArgs} args - Arguments to update or create a RegisterForm.
     * @example
     * // Update or create a RegisterForm
     * const registerForm = await prisma.registerForm.upsert({
     *   create: {
     *     // ... data to create a RegisterForm
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RegisterForm we want to update
     *   }
     * })
     */
    upsert<T extends RegisterFormUpsertArgs>(args: SelectSubset<T, RegisterFormUpsertArgs<ExtArgs>>): Prisma__RegisterFormClient<$Result.GetResult<Prisma.$RegisterFormPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of RegisterForms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegisterFormCountArgs} args - Arguments to filter RegisterForms to count.
     * @example
     * // Count the number of RegisterForms
     * const count = await prisma.registerForm.count({
     *   where: {
     *     // ... the filter for the RegisterForms we want to count
     *   }
     * })
    **/
    count<T extends RegisterFormCountArgs>(
      args?: Subset<T, RegisterFormCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RegisterFormCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RegisterForm.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegisterFormAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RegisterFormAggregateArgs>(args: Subset<T, RegisterFormAggregateArgs>): Prisma.PrismaPromise<GetRegisterFormAggregateType<T>>

    /**
     * Group by RegisterForm.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegisterFormGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RegisterFormGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RegisterFormGroupByArgs['orderBy'] }
        : { orderBy?: RegisterFormGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RegisterFormGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRegisterFormGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RegisterForm model
   */
  readonly fields: RegisterFormFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RegisterForm.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RegisterFormClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RegisterForm model
   */
  interface RegisterFormFieldRefs {
    readonly id: FieldRef<"RegisterForm", 'Int'>
    readonly name: FieldRef<"RegisterForm", 'String'>
    readonly type: FieldRef<"RegisterForm", 'String'>
    readonly placeholder: FieldRef<"RegisterForm", 'String'>
    readonly position: FieldRef<"RegisterForm", 'Int'>
    readonly row: FieldRef<"RegisterForm", 'Int'>
    readonly options: FieldRef<"RegisterForm", 'String'>
    readonly required: FieldRef<"RegisterForm", 'Boolean'>
    readonly hint: FieldRef<"RegisterForm", 'String'>
    readonly hintTrue: FieldRef<"RegisterForm", 'String'>
    readonly hintFalse: FieldRef<"RegisterForm", 'String'>
    readonly isActive: FieldRef<"RegisterForm", 'Boolean'>
    readonly createDate: FieldRef<"RegisterForm", 'DateTime'>
    readonly updateDate: FieldRef<"RegisterForm", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * RegisterForm findUnique
   */
  export type RegisterFormFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RegisterForm
     */
    select?: RegisterFormSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RegisterForm
     */
    omit?: RegisterFormOmit<ExtArgs> | null
    /**
     * Filter, which RegisterForm to fetch.
     */
    where: RegisterFormWhereUniqueInput
  }

  /**
   * RegisterForm findUniqueOrThrow
   */
  export type RegisterFormFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RegisterForm
     */
    select?: RegisterFormSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RegisterForm
     */
    omit?: RegisterFormOmit<ExtArgs> | null
    /**
     * Filter, which RegisterForm to fetch.
     */
    where: RegisterFormWhereUniqueInput
  }

  /**
   * RegisterForm findFirst
   */
  export type RegisterFormFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RegisterForm
     */
    select?: RegisterFormSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RegisterForm
     */
    omit?: RegisterFormOmit<ExtArgs> | null
    /**
     * Filter, which RegisterForm to fetch.
     */
    where?: RegisterFormWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RegisterForms to fetch.
     */
    orderBy?: RegisterFormOrderByWithRelationInput | RegisterFormOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RegisterForms.
     */
    cursor?: RegisterFormWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RegisterForms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RegisterForms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RegisterForms.
     */
    distinct?: RegisterFormScalarFieldEnum | RegisterFormScalarFieldEnum[]
  }

  /**
   * RegisterForm findFirstOrThrow
   */
  export type RegisterFormFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RegisterForm
     */
    select?: RegisterFormSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RegisterForm
     */
    omit?: RegisterFormOmit<ExtArgs> | null
    /**
     * Filter, which RegisterForm to fetch.
     */
    where?: RegisterFormWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RegisterForms to fetch.
     */
    orderBy?: RegisterFormOrderByWithRelationInput | RegisterFormOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RegisterForms.
     */
    cursor?: RegisterFormWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RegisterForms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RegisterForms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RegisterForms.
     */
    distinct?: RegisterFormScalarFieldEnum | RegisterFormScalarFieldEnum[]
  }

  /**
   * RegisterForm findMany
   */
  export type RegisterFormFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RegisterForm
     */
    select?: RegisterFormSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RegisterForm
     */
    omit?: RegisterFormOmit<ExtArgs> | null
    /**
     * Filter, which RegisterForms to fetch.
     */
    where?: RegisterFormWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RegisterForms to fetch.
     */
    orderBy?: RegisterFormOrderByWithRelationInput | RegisterFormOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RegisterForms.
     */
    cursor?: RegisterFormWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RegisterForms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RegisterForms.
     */
    skip?: number
    distinct?: RegisterFormScalarFieldEnum | RegisterFormScalarFieldEnum[]
  }

  /**
   * RegisterForm create
   */
  export type RegisterFormCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RegisterForm
     */
    select?: RegisterFormSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RegisterForm
     */
    omit?: RegisterFormOmit<ExtArgs> | null
    /**
     * The data needed to create a RegisterForm.
     */
    data: XOR<RegisterFormCreateInput, RegisterFormUncheckedCreateInput>
  }

  /**
   * RegisterForm createMany
   */
  export type RegisterFormCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RegisterForms.
     */
    data: RegisterFormCreateManyInput | RegisterFormCreateManyInput[]
  }

  /**
   * RegisterForm createManyAndReturn
   */
  export type RegisterFormCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RegisterForm
     */
    select?: RegisterFormSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RegisterForm
     */
    omit?: RegisterFormOmit<ExtArgs> | null
    /**
     * The data used to create many RegisterForms.
     */
    data: RegisterFormCreateManyInput | RegisterFormCreateManyInput[]
  }

  /**
   * RegisterForm update
   */
  export type RegisterFormUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RegisterForm
     */
    select?: RegisterFormSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RegisterForm
     */
    omit?: RegisterFormOmit<ExtArgs> | null
    /**
     * The data needed to update a RegisterForm.
     */
    data: XOR<RegisterFormUpdateInput, RegisterFormUncheckedUpdateInput>
    /**
     * Choose, which RegisterForm to update.
     */
    where: RegisterFormWhereUniqueInput
  }

  /**
   * RegisterForm updateMany
   */
  export type RegisterFormUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RegisterForms.
     */
    data: XOR<RegisterFormUpdateManyMutationInput, RegisterFormUncheckedUpdateManyInput>
    /**
     * Filter which RegisterForms to update
     */
    where?: RegisterFormWhereInput
    /**
     * Limit how many RegisterForms to update.
     */
    limit?: number
  }

  /**
   * RegisterForm updateManyAndReturn
   */
  export type RegisterFormUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RegisterForm
     */
    select?: RegisterFormSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RegisterForm
     */
    omit?: RegisterFormOmit<ExtArgs> | null
    /**
     * The data used to update RegisterForms.
     */
    data: XOR<RegisterFormUpdateManyMutationInput, RegisterFormUncheckedUpdateManyInput>
    /**
     * Filter which RegisterForms to update
     */
    where?: RegisterFormWhereInput
    /**
     * Limit how many RegisterForms to update.
     */
    limit?: number
  }

  /**
   * RegisterForm upsert
   */
  export type RegisterFormUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RegisterForm
     */
    select?: RegisterFormSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RegisterForm
     */
    omit?: RegisterFormOmit<ExtArgs> | null
    /**
     * The filter to search for the RegisterForm to update in case it exists.
     */
    where: RegisterFormWhereUniqueInput
    /**
     * In case the RegisterForm found by the `where` argument doesn't exist, create a new RegisterForm with this data.
     */
    create: XOR<RegisterFormCreateInput, RegisterFormUncheckedCreateInput>
    /**
     * In case the RegisterForm was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RegisterFormUpdateInput, RegisterFormUncheckedUpdateInput>
  }

  /**
   * RegisterForm delete
   */
  export type RegisterFormDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RegisterForm
     */
    select?: RegisterFormSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RegisterForm
     */
    omit?: RegisterFormOmit<ExtArgs> | null
    /**
     * Filter which RegisterForm to delete.
     */
    where: RegisterFormWhereUniqueInput
  }

  /**
   * RegisterForm deleteMany
   */
  export type RegisterFormDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RegisterForms to delete
     */
    where?: RegisterFormWhereInput
    /**
     * Limit how many RegisterForms to delete.
     */
    limit?: number
  }

  /**
   * RegisterForm without action
   */
  export type RegisterFormDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RegisterForm
     */
    select?: RegisterFormSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RegisterForm
     */
    omit?: RegisterFormOmit<ExtArgs> | null
  }


  /**
   * Model ApiList
   */

  export type AggregateApiList = {
    _count: ApiListCountAggregateOutputType | null
    _avg: ApiListAvgAggregateOutputType | null
    _sum: ApiListSumAggregateOutputType | null
    _min: ApiListMinAggregateOutputType | null
    _max: ApiListMaxAggregateOutputType | null
  }

  export type ApiListAvgAggregateOutputType = {
    id: number | null
  }

  export type ApiListSumAggregateOutputType = {
    id: number | null
  }

  export type ApiListMinAggregateOutputType = {
    id: number | null
    name: string | null
    createDate: Date | null
    updateDate: Date | null
  }

  export type ApiListMaxAggregateOutputType = {
    id: number | null
    name: string | null
    createDate: Date | null
    updateDate: Date | null
  }

  export type ApiListCountAggregateOutputType = {
    id: number
    name: number
    createDate: number
    updateDate: number
    _all: number
  }


  export type ApiListAvgAggregateInputType = {
    id?: true
  }

  export type ApiListSumAggregateInputType = {
    id?: true
  }

  export type ApiListMinAggregateInputType = {
    id?: true
    name?: true
    createDate?: true
    updateDate?: true
  }

  export type ApiListMaxAggregateInputType = {
    id?: true
    name?: true
    createDate?: true
    updateDate?: true
  }

  export type ApiListCountAggregateInputType = {
    id?: true
    name?: true
    createDate?: true
    updateDate?: true
    _all?: true
  }

  export type ApiListAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ApiList to aggregate.
     */
    where?: ApiListWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ApiLists to fetch.
     */
    orderBy?: ApiListOrderByWithRelationInput | ApiListOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ApiListWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ApiLists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ApiLists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ApiLists
    **/
    _count?: true | ApiListCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ApiListAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ApiListSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ApiListMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ApiListMaxAggregateInputType
  }

  export type GetApiListAggregateType<T extends ApiListAggregateArgs> = {
        [P in keyof T & keyof AggregateApiList]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateApiList[P]>
      : GetScalarType<T[P], AggregateApiList[P]>
  }




  export type ApiListGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ApiListWhereInput
    orderBy?: ApiListOrderByWithAggregationInput | ApiListOrderByWithAggregationInput[]
    by: ApiListScalarFieldEnum[] | ApiListScalarFieldEnum
    having?: ApiListScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ApiListCountAggregateInputType | true
    _avg?: ApiListAvgAggregateInputType
    _sum?: ApiListSumAggregateInputType
    _min?: ApiListMinAggregateInputType
    _max?: ApiListMaxAggregateInputType
  }

  export type ApiListGroupByOutputType = {
    id: number
    name: string
    createDate: Date
    updateDate: Date
    _count: ApiListCountAggregateOutputType | null
    _avg: ApiListAvgAggregateOutputType | null
    _sum: ApiListSumAggregateOutputType | null
    _min: ApiListMinAggregateOutputType | null
    _max: ApiListMaxAggregateOutputType | null
  }

  type GetApiListGroupByPayload<T extends ApiListGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ApiListGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ApiListGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ApiListGroupByOutputType[P]>
            : GetScalarType<T[P], ApiListGroupByOutputType[P]>
        }
      >
    >


  export type ApiListSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    createDate?: boolean
    updateDate?: boolean
  }, ExtArgs["result"]["apiList"]>

  export type ApiListSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    createDate?: boolean
    updateDate?: boolean
  }, ExtArgs["result"]["apiList"]>

  export type ApiListSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    createDate?: boolean
    updateDate?: boolean
  }, ExtArgs["result"]["apiList"]>

  export type ApiListSelectScalar = {
    id?: boolean
    name?: boolean
    createDate?: boolean
    updateDate?: boolean
  }

  export type ApiListOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "createDate" | "updateDate", ExtArgs["result"]["apiList"]>

  export type $ApiListPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ApiList"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      createDate: Date
      updateDate: Date
    }, ExtArgs["result"]["apiList"]>
    composites: {}
  }

  type ApiListGetPayload<S extends boolean | null | undefined | ApiListDefaultArgs> = $Result.GetResult<Prisma.$ApiListPayload, S>

  type ApiListCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ApiListFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ApiListCountAggregateInputType | true
    }

  export interface ApiListDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ApiList'], meta: { name: 'ApiList' } }
    /**
     * Find zero or one ApiList that matches the filter.
     * @param {ApiListFindUniqueArgs} args - Arguments to find a ApiList
     * @example
     * // Get one ApiList
     * const apiList = await prisma.apiList.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ApiListFindUniqueArgs>(args: SelectSubset<T, ApiListFindUniqueArgs<ExtArgs>>): Prisma__ApiListClient<$Result.GetResult<Prisma.$ApiListPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ApiList that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ApiListFindUniqueOrThrowArgs} args - Arguments to find a ApiList
     * @example
     * // Get one ApiList
     * const apiList = await prisma.apiList.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ApiListFindUniqueOrThrowArgs>(args: SelectSubset<T, ApiListFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ApiListClient<$Result.GetResult<Prisma.$ApiListPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ApiList that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiListFindFirstArgs} args - Arguments to find a ApiList
     * @example
     * // Get one ApiList
     * const apiList = await prisma.apiList.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ApiListFindFirstArgs>(args?: SelectSubset<T, ApiListFindFirstArgs<ExtArgs>>): Prisma__ApiListClient<$Result.GetResult<Prisma.$ApiListPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ApiList that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiListFindFirstOrThrowArgs} args - Arguments to find a ApiList
     * @example
     * // Get one ApiList
     * const apiList = await prisma.apiList.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ApiListFindFirstOrThrowArgs>(args?: SelectSubset<T, ApiListFindFirstOrThrowArgs<ExtArgs>>): Prisma__ApiListClient<$Result.GetResult<Prisma.$ApiListPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ApiLists that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiListFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ApiLists
     * const apiLists = await prisma.apiList.findMany()
     * 
     * // Get first 10 ApiLists
     * const apiLists = await prisma.apiList.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const apiListWithIdOnly = await prisma.apiList.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ApiListFindManyArgs>(args?: SelectSubset<T, ApiListFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApiListPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ApiList.
     * @param {ApiListCreateArgs} args - Arguments to create a ApiList.
     * @example
     * // Create one ApiList
     * const ApiList = await prisma.apiList.create({
     *   data: {
     *     // ... data to create a ApiList
     *   }
     * })
     * 
     */
    create<T extends ApiListCreateArgs>(args: SelectSubset<T, ApiListCreateArgs<ExtArgs>>): Prisma__ApiListClient<$Result.GetResult<Prisma.$ApiListPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ApiLists.
     * @param {ApiListCreateManyArgs} args - Arguments to create many ApiLists.
     * @example
     * // Create many ApiLists
     * const apiList = await prisma.apiList.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ApiListCreateManyArgs>(args?: SelectSubset<T, ApiListCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ApiLists and returns the data saved in the database.
     * @param {ApiListCreateManyAndReturnArgs} args - Arguments to create many ApiLists.
     * @example
     * // Create many ApiLists
     * const apiList = await prisma.apiList.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ApiLists and only return the `id`
     * const apiListWithIdOnly = await prisma.apiList.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ApiListCreateManyAndReturnArgs>(args?: SelectSubset<T, ApiListCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApiListPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ApiList.
     * @param {ApiListDeleteArgs} args - Arguments to delete one ApiList.
     * @example
     * // Delete one ApiList
     * const ApiList = await prisma.apiList.delete({
     *   where: {
     *     // ... filter to delete one ApiList
     *   }
     * })
     * 
     */
    delete<T extends ApiListDeleteArgs>(args: SelectSubset<T, ApiListDeleteArgs<ExtArgs>>): Prisma__ApiListClient<$Result.GetResult<Prisma.$ApiListPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ApiList.
     * @param {ApiListUpdateArgs} args - Arguments to update one ApiList.
     * @example
     * // Update one ApiList
     * const apiList = await prisma.apiList.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ApiListUpdateArgs>(args: SelectSubset<T, ApiListUpdateArgs<ExtArgs>>): Prisma__ApiListClient<$Result.GetResult<Prisma.$ApiListPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ApiLists.
     * @param {ApiListDeleteManyArgs} args - Arguments to filter ApiLists to delete.
     * @example
     * // Delete a few ApiLists
     * const { count } = await prisma.apiList.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ApiListDeleteManyArgs>(args?: SelectSubset<T, ApiListDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ApiLists.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiListUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ApiLists
     * const apiList = await prisma.apiList.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ApiListUpdateManyArgs>(args: SelectSubset<T, ApiListUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ApiLists and returns the data updated in the database.
     * @param {ApiListUpdateManyAndReturnArgs} args - Arguments to update many ApiLists.
     * @example
     * // Update many ApiLists
     * const apiList = await prisma.apiList.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ApiLists and only return the `id`
     * const apiListWithIdOnly = await prisma.apiList.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ApiListUpdateManyAndReturnArgs>(args: SelectSubset<T, ApiListUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApiListPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ApiList.
     * @param {ApiListUpsertArgs} args - Arguments to update or create a ApiList.
     * @example
     * // Update or create a ApiList
     * const apiList = await prisma.apiList.upsert({
     *   create: {
     *     // ... data to create a ApiList
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ApiList we want to update
     *   }
     * })
     */
    upsert<T extends ApiListUpsertArgs>(args: SelectSubset<T, ApiListUpsertArgs<ExtArgs>>): Prisma__ApiListClient<$Result.GetResult<Prisma.$ApiListPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ApiLists.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiListCountArgs} args - Arguments to filter ApiLists to count.
     * @example
     * // Count the number of ApiLists
     * const count = await prisma.apiList.count({
     *   where: {
     *     // ... the filter for the ApiLists we want to count
     *   }
     * })
    **/
    count<T extends ApiListCountArgs>(
      args?: Subset<T, ApiListCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ApiListCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ApiList.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiListAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ApiListAggregateArgs>(args: Subset<T, ApiListAggregateArgs>): Prisma.PrismaPromise<GetApiListAggregateType<T>>

    /**
     * Group by ApiList.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiListGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ApiListGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ApiListGroupByArgs['orderBy'] }
        : { orderBy?: ApiListGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ApiListGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetApiListGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ApiList model
   */
  readonly fields: ApiListFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ApiList.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ApiListClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ApiList model
   */
  interface ApiListFieldRefs {
    readonly id: FieldRef<"ApiList", 'Int'>
    readonly name: FieldRef<"ApiList", 'String'>
    readonly createDate: FieldRef<"ApiList", 'DateTime'>
    readonly updateDate: FieldRef<"ApiList", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ApiList findUnique
   */
  export type ApiListFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiList
     */
    select?: ApiListSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApiList
     */
    omit?: ApiListOmit<ExtArgs> | null
    /**
     * Filter, which ApiList to fetch.
     */
    where: ApiListWhereUniqueInput
  }

  /**
   * ApiList findUniqueOrThrow
   */
  export type ApiListFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiList
     */
    select?: ApiListSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApiList
     */
    omit?: ApiListOmit<ExtArgs> | null
    /**
     * Filter, which ApiList to fetch.
     */
    where: ApiListWhereUniqueInput
  }

  /**
   * ApiList findFirst
   */
  export type ApiListFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiList
     */
    select?: ApiListSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApiList
     */
    omit?: ApiListOmit<ExtArgs> | null
    /**
     * Filter, which ApiList to fetch.
     */
    where?: ApiListWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ApiLists to fetch.
     */
    orderBy?: ApiListOrderByWithRelationInput | ApiListOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ApiLists.
     */
    cursor?: ApiListWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ApiLists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ApiLists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ApiLists.
     */
    distinct?: ApiListScalarFieldEnum | ApiListScalarFieldEnum[]
  }

  /**
   * ApiList findFirstOrThrow
   */
  export type ApiListFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiList
     */
    select?: ApiListSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApiList
     */
    omit?: ApiListOmit<ExtArgs> | null
    /**
     * Filter, which ApiList to fetch.
     */
    where?: ApiListWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ApiLists to fetch.
     */
    orderBy?: ApiListOrderByWithRelationInput | ApiListOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ApiLists.
     */
    cursor?: ApiListWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ApiLists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ApiLists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ApiLists.
     */
    distinct?: ApiListScalarFieldEnum | ApiListScalarFieldEnum[]
  }

  /**
   * ApiList findMany
   */
  export type ApiListFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiList
     */
    select?: ApiListSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApiList
     */
    omit?: ApiListOmit<ExtArgs> | null
    /**
     * Filter, which ApiLists to fetch.
     */
    where?: ApiListWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ApiLists to fetch.
     */
    orderBy?: ApiListOrderByWithRelationInput | ApiListOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ApiLists.
     */
    cursor?: ApiListWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ApiLists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ApiLists.
     */
    skip?: number
    distinct?: ApiListScalarFieldEnum | ApiListScalarFieldEnum[]
  }

  /**
   * ApiList create
   */
  export type ApiListCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiList
     */
    select?: ApiListSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApiList
     */
    omit?: ApiListOmit<ExtArgs> | null
    /**
     * The data needed to create a ApiList.
     */
    data: XOR<ApiListCreateInput, ApiListUncheckedCreateInput>
  }

  /**
   * ApiList createMany
   */
  export type ApiListCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ApiLists.
     */
    data: ApiListCreateManyInput | ApiListCreateManyInput[]
  }

  /**
   * ApiList createManyAndReturn
   */
  export type ApiListCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiList
     */
    select?: ApiListSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ApiList
     */
    omit?: ApiListOmit<ExtArgs> | null
    /**
     * The data used to create many ApiLists.
     */
    data: ApiListCreateManyInput | ApiListCreateManyInput[]
  }

  /**
   * ApiList update
   */
  export type ApiListUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiList
     */
    select?: ApiListSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApiList
     */
    omit?: ApiListOmit<ExtArgs> | null
    /**
     * The data needed to update a ApiList.
     */
    data: XOR<ApiListUpdateInput, ApiListUncheckedUpdateInput>
    /**
     * Choose, which ApiList to update.
     */
    where: ApiListWhereUniqueInput
  }

  /**
   * ApiList updateMany
   */
  export type ApiListUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ApiLists.
     */
    data: XOR<ApiListUpdateManyMutationInput, ApiListUncheckedUpdateManyInput>
    /**
     * Filter which ApiLists to update
     */
    where?: ApiListWhereInput
    /**
     * Limit how many ApiLists to update.
     */
    limit?: number
  }

  /**
   * ApiList updateManyAndReturn
   */
  export type ApiListUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiList
     */
    select?: ApiListSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ApiList
     */
    omit?: ApiListOmit<ExtArgs> | null
    /**
     * The data used to update ApiLists.
     */
    data: XOR<ApiListUpdateManyMutationInput, ApiListUncheckedUpdateManyInput>
    /**
     * Filter which ApiLists to update
     */
    where?: ApiListWhereInput
    /**
     * Limit how many ApiLists to update.
     */
    limit?: number
  }

  /**
   * ApiList upsert
   */
  export type ApiListUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiList
     */
    select?: ApiListSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApiList
     */
    omit?: ApiListOmit<ExtArgs> | null
    /**
     * The filter to search for the ApiList to update in case it exists.
     */
    where: ApiListWhereUniqueInput
    /**
     * In case the ApiList found by the `where` argument doesn't exist, create a new ApiList with this data.
     */
    create: XOR<ApiListCreateInput, ApiListUncheckedCreateInput>
    /**
     * In case the ApiList was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ApiListUpdateInput, ApiListUncheckedUpdateInput>
  }

  /**
   * ApiList delete
   */
  export type ApiListDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiList
     */
    select?: ApiListSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApiList
     */
    omit?: ApiListOmit<ExtArgs> | null
    /**
     * Filter which ApiList to delete.
     */
    where: ApiListWhereUniqueInput
  }

  /**
   * ApiList deleteMany
   */
  export type ApiListDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ApiLists to delete
     */
    where?: ApiListWhereInput
    /**
     * Limit how many ApiLists to delete.
     */
    limit?: number
  }

  /**
   * ApiList without action
   */
  export type ApiListDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiList
     */
    select?: ApiListSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApiList
     */
    omit?: ApiListOmit<ExtArgs> | null
  }


  /**
   * Model FacebookPixel
   */

  export type AggregateFacebookPixel = {
    _count: FacebookPixelCountAggregateOutputType | null
    _avg: FacebookPixelAvgAggregateOutputType | null
    _sum: FacebookPixelSumAggregateOutputType | null
    _min: FacebookPixelMinAggregateOutputType | null
    _max: FacebookPixelMaxAggregateOutputType | null
  }

  export type FacebookPixelAvgAggregateOutputType = {
    id: number | null
  }

  export type FacebookPixelSumAggregateOutputType = {
    id: number | null
  }

  export type FacebookPixelMinAggregateOutputType = {
    id: number | null
    pixelId: string | null
    campaignName: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FacebookPixelMaxAggregateOutputType = {
    id: number | null
    pixelId: string | null
    campaignName: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FacebookPixelCountAggregateOutputType = {
    id: number
    pixelId: number
    campaignName: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type FacebookPixelAvgAggregateInputType = {
    id?: true
  }

  export type FacebookPixelSumAggregateInputType = {
    id?: true
  }

  export type FacebookPixelMinAggregateInputType = {
    id?: true
    pixelId?: true
    campaignName?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FacebookPixelMaxAggregateInputType = {
    id?: true
    pixelId?: true
    campaignName?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FacebookPixelCountAggregateInputType = {
    id?: true
    pixelId?: true
    campaignName?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type FacebookPixelAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FacebookPixel to aggregate.
     */
    where?: FacebookPixelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FacebookPixels to fetch.
     */
    orderBy?: FacebookPixelOrderByWithRelationInput | FacebookPixelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FacebookPixelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FacebookPixels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FacebookPixels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FacebookPixels
    **/
    _count?: true | FacebookPixelCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FacebookPixelAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FacebookPixelSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FacebookPixelMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FacebookPixelMaxAggregateInputType
  }

  export type GetFacebookPixelAggregateType<T extends FacebookPixelAggregateArgs> = {
        [P in keyof T & keyof AggregateFacebookPixel]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFacebookPixel[P]>
      : GetScalarType<T[P], AggregateFacebookPixel[P]>
  }




  export type FacebookPixelGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FacebookPixelWhereInput
    orderBy?: FacebookPixelOrderByWithAggregationInput | FacebookPixelOrderByWithAggregationInput[]
    by: FacebookPixelScalarFieldEnum[] | FacebookPixelScalarFieldEnum
    having?: FacebookPixelScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FacebookPixelCountAggregateInputType | true
    _avg?: FacebookPixelAvgAggregateInputType
    _sum?: FacebookPixelSumAggregateInputType
    _min?: FacebookPixelMinAggregateInputType
    _max?: FacebookPixelMaxAggregateInputType
  }

  export type FacebookPixelGroupByOutputType = {
    id: number
    pixelId: string
    campaignName: string
    createdAt: Date
    updatedAt: Date
    _count: FacebookPixelCountAggregateOutputType | null
    _avg: FacebookPixelAvgAggregateOutputType | null
    _sum: FacebookPixelSumAggregateOutputType | null
    _min: FacebookPixelMinAggregateOutputType | null
    _max: FacebookPixelMaxAggregateOutputType | null
  }

  type GetFacebookPixelGroupByPayload<T extends FacebookPixelGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FacebookPixelGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FacebookPixelGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FacebookPixelGroupByOutputType[P]>
            : GetScalarType<T[P], FacebookPixelGroupByOutputType[P]>
        }
      >
    >


  export type FacebookPixelSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    pixelId?: boolean
    campaignName?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["facebookPixel"]>

  export type FacebookPixelSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    pixelId?: boolean
    campaignName?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["facebookPixel"]>

  export type FacebookPixelSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    pixelId?: boolean
    campaignName?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["facebookPixel"]>

  export type FacebookPixelSelectScalar = {
    id?: boolean
    pixelId?: boolean
    campaignName?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type FacebookPixelOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "pixelId" | "campaignName" | "createdAt" | "updatedAt", ExtArgs["result"]["facebookPixel"]>

  export type $FacebookPixelPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FacebookPixel"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      pixelId: string
      campaignName: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["facebookPixel"]>
    composites: {}
  }

  type FacebookPixelGetPayload<S extends boolean | null | undefined | FacebookPixelDefaultArgs> = $Result.GetResult<Prisma.$FacebookPixelPayload, S>

  type FacebookPixelCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FacebookPixelFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FacebookPixelCountAggregateInputType | true
    }

  export interface FacebookPixelDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FacebookPixel'], meta: { name: 'FacebookPixel' } }
    /**
     * Find zero or one FacebookPixel that matches the filter.
     * @param {FacebookPixelFindUniqueArgs} args - Arguments to find a FacebookPixel
     * @example
     * // Get one FacebookPixel
     * const facebookPixel = await prisma.facebookPixel.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FacebookPixelFindUniqueArgs>(args: SelectSubset<T, FacebookPixelFindUniqueArgs<ExtArgs>>): Prisma__FacebookPixelClient<$Result.GetResult<Prisma.$FacebookPixelPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one FacebookPixel that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FacebookPixelFindUniqueOrThrowArgs} args - Arguments to find a FacebookPixel
     * @example
     * // Get one FacebookPixel
     * const facebookPixel = await prisma.facebookPixel.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FacebookPixelFindUniqueOrThrowArgs>(args: SelectSubset<T, FacebookPixelFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FacebookPixelClient<$Result.GetResult<Prisma.$FacebookPixelPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FacebookPixel that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacebookPixelFindFirstArgs} args - Arguments to find a FacebookPixel
     * @example
     * // Get one FacebookPixel
     * const facebookPixel = await prisma.facebookPixel.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FacebookPixelFindFirstArgs>(args?: SelectSubset<T, FacebookPixelFindFirstArgs<ExtArgs>>): Prisma__FacebookPixelClient<$Result.GetResult<Prisma.$FacebookPixelPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FacebookPixel that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacebookPixelFindFirstOrThrowArgs} args - Arguments to find a FacebookPixel
     * @example
     * // Get one FacebookPixel
     * const facebookPixel = await prisma.facebookPixel.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FacebookPixelFindFirstOrThrowArgs>(args?: SelectSubset<T, FacebookPixelFindFirstOrThrowArgs<ExtArgs>>): Prisma__FacebookPixelClient<$Result.GetResult<Prisma.$FacebookPixelPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more FacebookPixels that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacebookPixelFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FacebookPixels
     * const facebookPixels = await prisma.facebookPixel.findMany()
     * 
     * // Get first 10 FacebookPixels
     * const facebookPixels = await prisma.facebookPixel.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const facebookPixelWithIdOnly = await prisma.facebookPixel.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FacebookPixelFindManyArgs>(args?: SelectSubset<T, FacebookPixelFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FacebookPixelPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a FacebookPixel.
     * @param {FacebookPixelCreateArgs} args - Arguments to create a FacebookPixel.
     * @example
     * // Create one FacebookPixel
     * const FacebookPixel = await prisma.facebookPixel.create({
     *   data: {
     *     // ... data to create a FacebookPixel
     *   }
     * })
     * 
     */
    create<T extends FacebookPixelCreateArgs>(args: SelectSubset<T, FacebookPixelCreateArgs<ExtArgs>>): Prisma__FacebookPixelClient<$Result.GetResult<Prisma.$FacebookPixelPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many FacebookPixels.
     * @param {FacebookPixelCreateManyArgs} args - Arguments to create many FacebookPixels.
     * @example
     * // Create many FacebookPixels
     * const facebookPixel = await prisma.facebookPixel.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FacebookPixelCreateManyArgs>(args?: SelectSubset<T, FacebookPixelCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FacebookPixels and returns the data saved in the database.
     * @param {FacebookPixelCreateManyAndReturnArgs} args - Arguments to create many FacebookPixels.
     * @example
     * // Create many FacebookPixels
     * const facebookPixel = await prisma.facebookPixel.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many FacebookPixels and only return the `id`
     * const facebookPixelWithIdOnly = await prisma.facebookPixel.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FacebookPixelCreateManyAndReturnArgs>(args?: SelectSubset<T, FacebookPixelCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FacebookPixelPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a FacebookPixel.
     * @param {FacebookPixelDeleteArgs} args - Arguments to delete one FacebookPixel.
     * @example
     * // Delete one FacebookPixel
     * const FacebookPixel = await prisma.facebookPixel.delete({
     *   where: {
     *     // ... filter to delete one FacebookPixel
     *   }
     * })
     * 
     */
    delete<T extends FacebookPixelDeleteArgs>(args: SelectSubset<T, FacebookPixelDeleteArgs<ExtArgs>>): Prisma__FacebookPixelClient<$Result.GetResult<Prisma.$FacebookPixelPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one FacebookPixel.
     * @param {FacebookPixelUpdateArgs} args - Arguments to update one FacebookPixel.
     * @example
     * // Update one FacebookPixel
     * const facebookPixel = await prisma.facebookPixel.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FacebookPixelUpdateArgs>(args: SelectSubset<T, FacebookPixelUpdateArgs<ExtArgs>>): Prisma__FacebookPixelClient<$Result.GetResult<Prisma.$FacebookPixelPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more FacebookPixels.
     * @param {FacebookPixelDeleteManyArgs} args - Arguments to filter FacebookPixels to delete.
     * @example
     * // Delete a few FacebookPixels
     * const { count } = await prisma.facebookPixel.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FacebookPixelDeleteManyArgs>(args?: SelectSubset<T, FacebookPixelDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FacebookPixels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacebookPixelUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FacebookPixels
     * const facebookPixel = await prisma.facebookPixel.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FacebookPixelUpdateManyArgs>(args: SelectSubset<T, FacebookPixelUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FacebookPixels and returns the data updated in the database.
     * @param {FacebookPixelUpdateManyAndReturnArgs} args - Arguments to update many FacebookPixels.
     * @example
     * // Update many FacebookPixels
     * const facebookPixel = await prisma.facebookPixel.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more FacebookPixels and only return the `id`
     * const facebookPixelWithIdOnly = await prisma.facebookPixel.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FacebookPixelUpdateManyAndReturnArgs>(args: SelectSubset<T, FacebookPixelUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FacebookPixelPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one FacebookPixel.
     * @param {FacebookPixelUpsertArgs} args - Arguments to update or create a FacebookPixel.
     * @example
     * // Update or create a FacebookPixel
     * const facebookPixel = await prisma.facebookPixel.upsert({
     *   create: {
     *     // ... data to create a FacebookPixel
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FacebookPixel we want to update
     *   }
     * })
     */
    upsert<T extends FacebookPixelUpsertArgs>(args: SelectSubset<T, FacebookPixelUpsertArgs<ExtArgs>>): Prisma__FacebookPixelClient<$Result.GetResult<Prisma.$FacebookPixelPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of FacebookPixels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacebookPixelCountArgs} args - Arguments to filter FacebookPixels to count.
     * @example
     * // Count the number of FacebookPixels
     * const count = await prisma.facebookPixel.count({
     *   where: {
     *     // ... the filter for the FacebookPixels we want to count
     *   }
     * })
    **/
    count<T extends FacebookPixelCountArgs>(
      args?: Subset<T, FacebookPixelCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FacebookPixelCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FacebookPixel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacebookPixelAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FacebookPixelAggregateArgs>(args: Subset<T, FacebookPixelAggregateArgs>): Prisma.PrismaPromise<GetFacebookPixelAggregateType<T>>

    /**
     * Group by FacebookPixel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacebookPixelGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FacebookPixelGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FacebookPixelGroupByArgs['orderBy'] }
        : { orderBy?: FacebookPixelGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FacebookPixelGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFacebookPixelGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FacebookPixel model
   */
  readonly fields: FacebookPixelFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FacebookPixel.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FacebookPixelClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FacebookPixel model
   */
  interface FacebookPixelFieldRefs {
    readonly id: FieldRef<"FacebookPixel", 'Int'>
    readonly pixelId: FieldRef<"FacebookPixel", 'String'>
    readonly campaignName: FieldRef<"FacebookPixel", 'String'>
    readonly createdAt: FieldRef<"FacebookPixel", 'DateTime'>
    readonly updatedAt: FieldRef<"FacebookPixel", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * FacebookPixel findUnique
   */
  export type FacebookPixelFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FacebookPixel
     */
    select?: FacebookPixelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FacebookPixel
     */
    omit?: FacebookPixelOmit<ExtArgs> | null
    /**
     * Filter, which FacebookPixel to fetch.
     */
    where: FacebookPixelWhereUniqueInput
  }

  /**
   * FacebookPixel findUniqueOrThrow
   */
  export type FacebookPixelFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FacebookPixel
     */
    select?: FacebookPixelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FacebookPixel
     */
    omit?: FacebookPixelOmit<ExtArgs> | null
    /**
     * Filter, which FacebookPixel to fetch.
     */
    where: FacebookPixelWhereUniqueInput
  }

  /**
   * FacebookPixel findFirst
   */
  export type FacebookPixelFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FacebookPixel
     */
    select?: FacebookPixelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FacebookPixel
     */
    omit?: FacebookPixelOmit<ExtArgs> | null
    /**
     * Filter, which FacebookPixel to fetch.
     */
    where?: FacebookPixelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FacebookPixels to fetch.
     */
    orderBy?: FacebookPixelOrderByWithRelationInput | FacebookPixelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FacebookPixels.
     */
    cursor?: FacebookPixelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FacebookPixels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FacebookPixels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FacebookPixels.
     */
    distinct?: FacebookPixelScalarFieldEnum | FacebookPixelScalarFieldEnum[]
  }

  /**
   * FacebookPixel findFirstOrThrow
   */
  export type FacebookPixelFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FacebookPixel
     */
    select?: FacebookPixelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FacebookPixel
     */
    omit?: FacebookPixelOmit<ExtArgs> | null
    /**
     * Filter, which FacebookPixel to fetch.
     */
    where?: FacebookPixelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FacebookPixels to fetch.
     */
    orderBy?: FacebookPixelOrderByWithRelationInput | FacebookPixelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FacebookPixels.
     */
    cursor?: FacebookPixelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FacebookPixels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FacebookPixels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FacebookPixels.
     */
    distinct?: FacebookPixelScalarFieldEnum | FacebookPixelScalarFieldEnum[]
  }

  /**
   * FacebookPixel findMany
   */
  export type FacebookPixelFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FacebookPixel
     */
    select?: FacebookPixelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FacebookPixel
     */
    omit?: FacebookPixelOmit<ExtArgs> | null
    /**
     * Filter, which FacebookPixels to fetch.
     */
    where?: FacebookPixelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FacebookPixels to fetch.
     */
    orderBy?: FacebookPixelOrderByWithRelationInput | FacebookPixelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FacebookPixels.
     */
    cursor?: FacebookPixelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FacebookPixels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FacebookPixels.
     */
    skip?: number
    distinct?: FacebookPixelScalarFieldEnum | FacebookPixelScalarFieldEnum[]
  }

  /**
   * FacebookPixel create
   */
  export type FacebookPixelCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FacebookPixel
     */
    select?: FacebookPixelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FacebookPixel
     */
    omit?: FacebookPixelOmit<ExtArgs> | null
    /**
     * The data needed to create a FacebookPixel.
     */
    data: XOR<FacebookPixelCreateInput, FacebookPixelUncheckedCreateInput>
  }

  /**
   * FacebookPixel createMany
   */
  export type FacebookPixelCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FacebookPixels.
     */
    data: FacebookPixelCreateManyInput | FacebookPixelCreateManyInput[]
  }

  /**
   * FacebookPixel createManyAndReturn
   */
  export type FacebookPixelCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FacebookPixel
     */
    select?: FacebookPixelSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FacebookPixel
     */
    omit?: FacebookPixelOmit<ExtArgs> | null
    /**
     * The data used to create many FacebookPixels.
     */
    data: FacebookPixelCreateManyInput | FacebookPixelCreateManyInput[]
  }

  /**
   * FacebookPixel update
   */
  export type FacebookPixelUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FacebookPixel
     */
    select?: FacebookPixelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FacebookPixel
     */
    omit?: FacebookPixelOmit<ExtArgs> | null
    /**
     * The data needed to update a FacebookPixel.
     */
    data: XOR<FacebookPixelUpdateInput, FacebookPixelUncheckedUpdateInput>
    /**
     * Choose, which FacebookPixel to update.
     */
    where: FacebookPixelWhereUniqueInput
  }

  /**
   * FacebookPixel updateMany
   */
  export type FacebookPixelUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FacebookPixels.
     */
    data: XOR<FacebookPixelUpdateManyMutationInput, FacebookPixelUncheckedUpdateManyInput>
    /**
     * Filter which FacebookPixels to update
     */
    where?: FacebookPixelWhereInput
    /**
     * Limit how many FacebookPixels to update.
     */
    limit?: number
  }

  /**
   * FacebookPixel updateManyAndReturn
   */
  export type FacebookPixelUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FacebookPixel
     */
    select?: FacebookPixelSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FacebookPixel
     */
    omit?: FacebookPixelOmit<ExtArgs> | null
    /**
     * The data used to update FacebookPixels.
     */
    data: XOR<FacebookPixelUpdateManyMutationInput, FacebookPixelUncheckedUpdateManyInput>
    /**
     * Filter which FacebookPixels to update
     */
    where?: FacebookPixelWhereInput
    /**
     * Limit how many FacebookPixels to update.
     */
    limit?: number
  }

  /**
   * FacebookPixel upsert
   */
  export type FacebookPixelUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FacebookPixel
     */
    select?: FacebookPixelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FacebookPixel
     */
    omit?: FacebookPixelOmit<ExtArgs> | null
    /**
     * The filter to search for the FacebookPixel to update in case it exists.
     */
    where: FacebookPixelWhereUniqueInput
    /**
     * In case the FacebookPixel found by the `where` argument doesn't exist, create a new FacebookPixel with this data.
     */
    create: XOR<FacebookPixelCreateInput, FacebookPixelUncheckedCreateInput>
    /**
     * In case the FacebookPixel was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FacebookPixelUpdateInput, FacebookPixelUncheckedUpdateInput>
  }

  /**
   * FacebookPixel delete
   */
  export type FacebookPixelDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FacebookPixel
     */
    select?: FacebookPixelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FacebookPixel
     */
    omit?: FacebookPixelOmit<ExtArgs> | null
    /**
     * Filter which FacebookPixel to delete.
     */
    where: FacebookPixelWhereUniqueInput
  }

  /**
   * FacebookPixel deleteMany
   */
  export type FacebookPixelDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FacebookPixels to delete
     */
    where?: FacebookPixelWhereInput
    /**
     * Limit how many FacebookPixels to delete.
     */
    limit?: number
  }

  /**
   * FacebookPixel without action
   */
  export type FacebookPixelDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FacebookPixel
     */
    select?: FacebookPixelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FacebookPixel
     */
    omit?: FacebookPixelOmit<ExtArgs> | null
  }


  /**
   * Model SiteIdentity
   */

  export type AggregateSiteIdentity = {
    _count: SiteIdentityCountAggregateOutputType | null
    _min: SiteIdentityMinAggregateOutputType | null
    _max: SiteIdentityMaxAggregateOutputType | null
  }

  export type SiteIdentityMinAggregateOutputType = {
    id: string | null
    siteName: string | null
    tagline: string | null
    description: string | null
    logoUrl: string | null
    ogImage: string | null
    faviconUrl: string | null
    email: string | null
    phone: string | null
    address: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SiteIdentityMaxAggregateOutputType = {
    id: string | null
    siteName: string | null
    tagline: string | null
    description: string | null
    logoUrl: string | null
    ogImage: string | null
    faviconUrl: string | null
    email: string | null
    phone: string | null
    address: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SiteIdentityCountAggregateOutputType = {
    id: number
    siteName: number
    tagline: number
    description: number
    keywords: number
    logoUrl: number
    ogImage: number
    faviconUrl: number
    email: number
    phone: number
    address: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SiteIdentityMinAggregateInputType = {
    id?: true
    siteName?: true
    tagline?: true
    description?: true
    logoUrl?: true
    ogImage?: true
    faviconUrl?: true
    email?: true
    phone?: true
    address?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SiteIdentityMaxAggregateInputType = {
    id?: true
    siteName?: true
    tagline?: true
    description?: true
    logoUrl?: true
    ogImage?: true
    faviconUrl?: true
    email?: true
    phone?: true
    address?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SiteIdentityCountAggregateInputType = {
    id?: true
    siteName?: true
    tagline?: true
    description?: true
    keywords?: true
    logoUrl?: true
    ogImage?: true
    faviconUrl?: true
    email?: true
    phone?: true
    address?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SiteIdentityAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SiteIdentity to aggregate.
     */
    where?: SiteIdentityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SiteIdentities to fetch.
     */
    orderBy?: SiteIdentityOrderByWithRelationInput | SiteIdentityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SiteIdentityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SiteIdentities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SiteIdentities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SiteIdentities
    **/
    _count?: true | SiteIdentityCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SiteIdentityMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SiteIdentityMaxAggregateInputType
  }

  export type GetSiteIdentityAggregateType<T extends SiteIdentityAggregateArgs> = {
        [P in keyof T & keyof AggregateSiteIdentity]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSiteIdentity[P]>
      : GetScalarType<T[P], AggregateSiteIdentity[P]>
  }




  export type SiteIdentityGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SiteIdentityWhereInput
    orderBy?: SiteIdentityOrderByWithAggregationInput | SiteIdentityOrderByWithAggregationInput[]
    by: SiteIdentityScalarFieldEnum[] | SiteIdentityScalarFieldEnum
    having?: SiteIdentityScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SiteIdentityCountAggregateInputType | true
    _min?: SiteIdentityMinAggregateInputType
    _max?: SiteIdentityMaxAggregateInputType
  }

  export type SiteIdentityGroupByOutputType = {
    id: string
    siteName: string
    tagline: string | null
    description: string | null
    keywords: JsonValue | null
    logoUrl: string
    ogImage: string | null
    faviconUrl: string
    email: string | null
    phone: string | null
    address: string | null
    createdAt: Date
    updatedAt: Date
    _count: SiteIdentityCountAggregateOutputType | null
    _min: SiteIdentityMinAggregateOutputType | null
    _max: SiteIdentityMaxAggregateOutputType | null
  }

  type GetSiteIdentityGroupByPayload<T extends SiteIdentityGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SiteIdentityGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SiteIdentityGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SiteIdentityGroupByOutputType[P]>
            : GetScalarType<T[P], SiteIdentityGroupByOutputType[P]>
        }
      >
    >


  export type SiteIdentitySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    siteName?: boolean
    tagline?: boolean
    description?: boolean
    keywords?: boolean
    logoUrl?: boolean
    ogImage?: boolean
    faviconUrl?: boolean
    email?: boolean
    phone?: boolean
    address?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    socialLinks?: boolean | SiteIdentity$socialLinksArgs<ExtArgs>
    _count?: boolean | SiteIdentityCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["siteIdentity"]>

  export type SiteIdentitySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    siteName?: boolean
    tagline?: boolean
    description?: boolean
    keywords?: boolean
    logoUrl?: boolean
    ogImage?: boolean
    faviconUrl?: boolean
    email?: boolean
    phone?: boolean
    address?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["siteIdentity"]>

  export type SiteIdentitySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    siteName?: boolean
    tagline?: boolean
    description?: boolean
    keywords?: boolean
    logoUrl?: boolean
    ogImage?: boolean
    faviconUrl?: boolean
    email?: boolean
    phone?: boolean
    address?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["siteIdentity"]>

  export type SiteIdentitySelectScalar = {
    id?: boolean
    siteName?: boolean
    tagline?: boolean
    description?: boolean
    keywords?: boolean
    logoUrl?: boolean
    ogImage?: boolean
    faviconUrl?: boolean
    email?: boolean
    phone?: boolean
    address?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SiteIdentityOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "siteName" | "tagline" | "description" | "keywords" | "logoUrl" | "ogImage" | "faviconUrl" | "email" | "phone" | "address" | "createdAt" | "updatedAt", ExtArgs["result"]["siteIdentity"]>
  export type SiteIdentityInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    socialLinks?: boolean | SiteIdentity$socialLinksArgs<ExtArgs>
    _count?: boolean | SiteIdentityCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SiteIdentityIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type SiteIdentityIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $SiteIdentityPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SiteIdentity"
    objects: {
      socialLinks: Prisma.$SocialLinksPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      siteName: string
      tagline: string | null
      description: string | null
      keywords: Prisma.JsonValue | null
      logoUrl: string
      ogImage: string | null
      faviconUrl: string
      email: string | null
      phone: string | null
      address: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["siteIdentity"]>
    composites: {}
  }

  type SiteIdentityGetPayload<S extends boolean | null | undefined | SiteIdentityDefaultArgs> = $Result.GetResult<Prisma.$SiteIdentityPayload, S>

  type SiteIdentityCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SiteIdentityFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SiteIdentityCountAggregateInputType | true
    }

  export interface SiteIdentityDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SiteIdentity'], meta: { name: 'SiteIdentity' } }
    /**
     * Find zero or one SiteIdentity that matches the filter.
     * @param {SiteIdentityFindUniqueArgs} args - Arguments to find a SiteIdentity
     * @example
     * // Get one SiteIdentity
     * const siteIdentity = await prisma.siteIdentity.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SiteIdentityFindUniqueArgs>(args: SelectSubset<T, SiteIdentityFindUniqueArgs<ExtArgs>>): Prisma__SiteIdentityClient<$Result.GetResult<Prisma.$SiteIdentityPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SiteIdentity that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SiteIdentityFindUniqueOrThrowArgs} args - Arguments to find a SiteIdentity
     * @example
     * // Get one SiteIdentity
     * const siteIdentity = await prisma.siteIdentity.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SiteIdentityFindUniqueOrThrowArgs>(args: SelectSubset<T, SiteIdentityFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SiteIdentityClient<$Result.GetResult<Prisma.$SiteIdentityPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SiteIdentity that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SiteIdentityFindFirstArgs} args - Arguments to find a SiteIdentity
     * @example
     * // Get one SiteIdentity
     * const siteIdentity = await prisma.siteIdentity.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SiteIdentityFindFirstArgs>(args?: SelectSubset<T, SiteIdentityFindFirstArgs<ExtArgs>>): Prisma__SiteIdentityClient<$Result.GetResult<Prisma.$SiteIdentityPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SiteIdentity that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SiteIdentityFindFirstOrThrowArgs} args - Arguments to find a SiteIdentity
     * @example
     * // Get one SiteIdentity
     * const siteIdentity = await prisma.siteIdentity.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SiteIdentityFindFirstOrThrowArgs>(args?: SelectSubset<T, SiteIdentityFindFirstOrThrowArgs<ExtArgs>>): Prisma__SiteIdentityClient<$Result.GetResult<Prisma.$SiteIdentityPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SiteIdentities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SiteIdentityFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SiteIdentities
     * const siteIdentities = await prisma.siteIdentity.findMany()
     * 
     * // Get first 10 SiteIdentities
     * const siteIdentities = await prisma.siteIdentity.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const siteIdentityWithIdOnly = await prisma.siteIdentity.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SiteIdentityFindManyArgs>(args?: SelectSubset<T, SiteIdentityFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SiteIdentityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SiteIdentity.
     * @param {SiteIdentityCreateArgs} args - Arguments to create a SiteIdentity.
     * @example
     * // Create one SiteIdentity
     * const SiteIdentity = await prisma.siteIdentity.create({
     *   data: {
     *     // ... data to create a SiteIdentity
     *   }
     * })
     * 
     */
    create<T extends SiteIdentityCreateArgs>(args: SelectSubset<T, SiteIdentityCreateArgs<ExtArgs>>): Prisma__SiteIdentityClient<$Result.GetResult<Prisma.$SiteIdentityPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SiteIdentities.
     * @param {SiteIdentityCreateManyArgs} args - Arguments to create many SiteIdentities.
     * @example
     * // Create many SiteIdentities
     * const siteIdentity = await prisma.siteIdentity.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SiteIdentityCreateManyArgs>(args?: SelectSubset<T, SiteIdentityCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SiteIdentities and returns the data saved in the database.
     * @param {SiteIdentityCreateManyAndReturnArgs} args - Arguments to create many SiteIdentities.
     * @example
     * // Create many SiteIdentities
     * const siteIdentity = await prisma.siteIdentity.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SiteIdentities and only return the `id`
     * const siteIdentityWithIdOnly = await prisma.siteIdentity.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SiteIdentityCreateManyAndReturnArgs>(args?: SelectSubset<T, SiteIdentityCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SiteIdentityPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SiteIdentity.
     * @param {SiteIdentityDeleteArgs} args - Arguments to delete one SiteIdentity.
     * @example
     * // Delete one SiteIdentity
     * const SiteIdentity = await prisma.siteIdentity.delete({
     *   where: {
     *     // ... filter to delete one SiteIdentity
     *   }
     * })
     * 
     */
    delete<T extends SiteIdentityDeleteArgs>(args: SelectSubset<T, SiteIdentityDeleteArgs<ExtArgs>>): Prisma__SiteIdentityClient<$Result.GetResult<Prisma.$SiteIdentityPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SiteIdentity.
     * @param {SiteIdentityUpdateArgs} args - Arguments to update one SiteIdentity.
     * @example
     * // Update one SiteIdentity
     * const siteIdentity = await prisma.siteIdentity.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SiteIdentityUpdateArgs>(args: SelectSubset<T, SiteIdentityUpdateArgs<ExtArgs>>): Prisma__SiteIdentityClient<$Result.GetResult<Prisma.$SiteIdentityPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SiteIdentities.
     * @param {SiteIdentityDeleteManyArgs} args - Arguments to filter SiteIdentities to delete.
     * @example
     * // Delete a few SiteIdentities
     * const { count } = await prisma.siteIdentity.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SiteIdentityDeleteManyArgs>(args?: SelectSubset<T, SiteIdentityDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SiteIdentities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SiteIdentityUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SiteIdentities
     * const siteIdentity = await prisma.siteIdentity.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SiteIdentityUpdateManyArgs>(args: SelectSubset<T, SiteIdentityUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SiteIdentities and returns the data updated in the database.
     * @param {SiteIdentityUpdateManyAndReturnArgs} args - Arguments to update many SiteIdentities.
     * @example
     * // Update many SiteIdentities
     * const siteIdentity = await prisma.siteIdentity.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SiteIdentities and only return the `id`
     * const siteIdentityWithIdOnly = await prisma.siteIdentity.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SiteIdentityUpdateManyAndReturnArgs>(args: SelectSubset<T, SiteIdentityUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SiteIdentityPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SiteIdentity.
     * @param {SiteIdentityUpsertArgs} args - Arguments to update or create a SiteIdentity.
     * @example
     * // Update or create a SiteIdentity
     * const siteIdentity = await prisma.siteIdentity.upsert({
     *   create: {
     *     // ... data to create a SiteIdentity
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SiteIdentity we want to update
     *   }
     * })
     */
    upsert<T extends SiteIdentityUpsertArgs>(args: SelectSubset<T, SiteIdentityUpsertArgs<ExtArgs>>): Prisma__SiteIdentityClient<$Result.GetResult<Prisma.$SiteIdentityPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SiteIdentities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SiteIdentityCountArgs} args - Arguments to filter SiteIdentities to count.
     * @example
     * // Count the number of SiteIdentities
     * const count = await prisma.siteIdentity.count({
     *   where: {
     *     // ... the filter for the SiteIdentities we want to count
     *   }
     * })
    **/
    count<T extends SiteIdentityCountArgs>(
      args?: Subset<T, SiteIdentityCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SiteIdentityCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SiteIdentity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SiteIdentityAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SiteIdentityAggregateArgs>(args: Subset<T, SiteIdentityAggregateArgs>): Prisma.PrismaPromise<GetSiteIdentityAggregateType<T>>

    /**
     * Group by SiteIdentity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SiteIdentityGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SiteIdentityGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SiteIdentityGroupByArgs['orderBy'] }
        : { orderBy?: SiteIdentityGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SiteIdentityGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSiteIdentityGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SiteIdentity model
   */
  readonly fields: SiteIdentityFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SiteIdentity.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SiteIdentityClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    socialLinks<T extends SiteIdentity$socialLinksArgs<ExtArgs> = {}>(args?: Subset<T, SiteIdentity$socialLinksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SocialLinksPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SiteIdentity model
   */
  interface SiteIdentityFieldRefs {
    readonly id: FieldRef<"SiteIdentity", 'String'>
    readonly siteName: FieldRef<"SiteIdentity", 'String'>
    readonly tagline: FieldRef<"SiteIdentity", 'String'>
    readonly description: FieldRef<"SiteIdentity", 'String'>
    readonly keywords: FieldRef<"SiteIdentity", 'Json'>
    readonly logoUrl: FieldRef<"SiteIdentity", 'String'>
    readonly ogImage: FieldRef<"SiteIdentity", 'String'>
    readonly faviconUrl: FieldRef<"SiteIdentity", 'String'>
    readonly email: FieldRef<"SiteIdentity", 'String'>
    readonly phone: FieldRef<"SiteIdentity", 'String'>
    readonly address: FieldRef<"SiteIdentity", 'String'>
    readonly createdAt: FieldRef<"SiteIdentity", 'DateTime'>
    readonly updatedAt: FieldRef<"SiteIdentity", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SiteIdentity findUnique
   */
  export type SiteIdentityFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SiteIdentity
     */
    select?: SiteIdentitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SiteIdentity
     */
    omit?: SiteIdentityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SiteIdentityInclude<ExtArgs> | null
    /**
     * Filter, which SiteIdentity to fetch.
     */
    where: SiteIdentityWhereUniqueInput
  }

  /**
   * SiteIdentity findUniqueOrThrow
   */
  export type SiteIdentityFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SiteIdentity
     */
    select?: SiteIdentitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SiteIdentity
     */
    omit?: SiteIdentityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SiteIdentityInclude<ExtArgs> | null
    /**
     * Filter, which SiteIdentity to fetch.
     */
    where: SiteIdentityWhereUniqueInput
  }

  /**
   * SiteIdentity findFirst
   */
  export type SiteIdentityFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SiteIdentity
     */
    select?: SiteIdentitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SiteIdentity
     */
    omit?: SiteIdentityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SiteIdentityInclude<ExtArgs> | null
    /**
     * Filter, which SiteIdentity to fetch.
     */
    where?: SiteIdentityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SiteIdentities to fetch.
     */
    orderBy?: SiteIdentityOrderByWithRelationInput | SiteIdentityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SiteIdentities.
     */
    cursor?: SiteIdentityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SiteIdentities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SiteIdentities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SiteIdentities.
     */
    distinct?: SiteIdentityScalarFieldEnum | SiteIdentityScalarFieldEnum[]
  }

  /**
   * SiteIdentity findFirstOrThrow
   */
  export type SiteIdentityFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SiteIdentity
     */
    select?: SiteIdentitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SiteIdentity
     */
    omit?: SiteIdentityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SiteIdentityInclude<ExtArgs> | null
    /**
     * Filter, which SiteIdentity to fetch.
     */
    where?: SiteIdentityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SiteIdentities to fetch.
     */
    orderBy?: SiteIdentityOrderByWithRelationInput | SiteIdentityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SiteIdentities.
     */
    cursor?: SiteIdentityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SiteIdentities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SiteIdentities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SiteIdentities.
     */
    distinct?: SiteIdentityScalarFieldEnum | SiteIdentityScalarFieldEnum[]
  }

  /**
   * SiteIdentity findMany
   */
  export type SiteIdentityFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SiteIdentity
     */
    select?: SiteIdentitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SiteIdentity
     */
    omit?: SiteIdentityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SiteIdentityInclude<ExtArgs> | null
    /**
     * Filter, which SiteIdentities to fetch.
     */
    where?: SiteIdentityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SiteIdentities to fetch.
     */
    orderBy?: SiteIdentityOrderByWithRelationInput | SiteIdentityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SiteIdentities.
     */
    cursor?: SiteIdentityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SiteIdentities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SiteIdentities.
     */
    skip?: number
    distinct?: SiteIdentityScalarFieldEnum | SiteIdentityScalarFieldEnum[]
  }

  /**
   * SiteIdentity create
   */
  export type SiteIdentityCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SiteIdentity
     */
    select?: SiteIdentitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SiteIdentity
     */
    omit?: SiteIdentityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SiteIdentityInclude<ExtArgs> | null
    /**
     * The data needed to create a SiteIdentity.
     */
    data: XOR<SiteIdentityCreateInput, SiteIdentityUncheckedCreateInput>
  }

  /**
   * SiteIdentity createMany
   */
  export type SiteIdentityCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SiteIdentities.
     */
    data: SiteIdentityCreateManyInput | SiteIdentityCreateManyInput[]
  }

  /**
   * SiteIdentity createManyAndReturn
   */
  export type SiteIdentityCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SiteIdentity
     */
    select?: SiteIdentitySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SiteIdentity
     */
    omit?: SiteIdentityOmit<ExtArgs> | null
    /**
     * The data used to create many SiteIdentities.
     */
    data: SiteIdentityCreateManyInput | SiteIdentityCreateManyInput[]
  }

  /**
   * SiteIdentity update
   */
  export type SiteIdentityUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SiteIdentity
     */
    select?: SiteIdentitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SiteIdentity
     */
    omit?: SiteIdentityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SiteIdentityInclude<ExtArgs> | null
    /**
     * The data needed to update a SiteIdentity.
     */
    data: XOR<SiteIdentityUpdateInput, SiteIdentityUncheckedUpdateInput>
    /**
     * Choose, which SiteIdentity to update.
     */
    where: SiteIdentityWhereUniqueInput
  }

  /**
   * SiteIdentity updateMany
   */
  export type SiteIdentityUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SiteIdentities.
     */
    data: XOR<SiteIdentityUpdateManyMutationInput, SiteIdentityUncheckedUpdateManyInput>
    /**
     * Filter which SiteIdentities to update
     */
    where?: SiteIdentityWhereInput
    /**
     * Limit how many SiteIdentities to update.
     */
    limit?: number
  }

  /**
   * SiteIdentity updateManyAndReturn
   */
  export type SiteIdentityUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SiteIdentity
     */
    select?: SiteIdentitySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SiteIdentity
     */
    omit?: SiteIdentityOmit<ExtArgs> | null
    /**
     * The data used to update SiteIdentities.
     */
    data: XOR<SiteIdentityUpdateManyMutationInput, SiteIdentityUncheckedUpdateManyInput>
    /**
     * Filter which SiteIdentities to update
     */
    where?: SiteIdentityWhereInput
    /**
     * Limit how many SiteIdentities to update.
     */
    limit?: number
  }

  /**
   * SiteIdentity upsert
   */
  export type SiteIdentityUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SiteIdentity
     */
    select?: SiteIdentitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SiteIdentity
     */
    omit?: SiteIdentityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SiteIdentityInclude<ExtArgs> | null
    /**
     * The filter to search for the SiteIdentity to update in case it exists.
     */
    where: SiteIdentityWhereUniqueInput
    /**
     * In case the SiteIdentity found by the `where` argument doesn't exist, create a new SiteIdentity with this data.
     */
    create: XOR<SiteIdentityCreateInput, SiteIdentityUncheckedCreateInput>
    /**
     * In case the SiteIdentity was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SiteIdentityUpdateInput, SiteIdentityUncheckedUpdateInput>
  }

  /**
   * SiteIdentity delete
   */
  export type SiteIdentityDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SiteIdentity
     */
    select?: SiteIdentitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SiteIdentity
     */
    omit?: SiteIdentityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SiteIdentityInclude<ExtArgs> | null
    /**
     * Filter which SiteIdentity to delete.
     */
    where: SiteIdentityWhereUniqueInput
  }

  /**
   * SiteIdentity deleteMany
   */
  export type SiteIdentityDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SiteIdentities to delete
     */
    where?: SiteIdentityWhereInput
    /**
     * Limit how many SiteIdentities to delete.
     */
    limit?: number
  }

  /**
   * SiteIdentity.socialLinks
   */
  export type SiteIdentity$socialLinksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialLinks
     */
    select?: SocialLinksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SocialLinks
     */
    omit?: SocialLinksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SocialLinksInclude<ExtArgs> | null
    where?: SocialLinksWhereInput
    orderBy?: SocialLinksOrderByWithRelationInput | SocialLinksOrderByWithRelationInput[]
    cursor?: SocialLinksWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SocialLinksScalarFieldEnum | SocialLinksScalarFieldEnum[]
  }

  /**
   * SiteIdentity without action
   */
  export type SiteIdentityDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SiteIdentity
     */
    select?: SiteIdentitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SiteIdentity
     */
    omit?: SiteIdentityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SiteIdentityInclude<ExtArgs> | null
  }


  /**
   * Model SocialLinks
   */

  export type AggregateSocialLinks = {
    _count: SocialLinksCountAggregateOutputType | null
    _min: SocialLinksMinAggregateOutputType | null
    _max: SocialLinksMaxAggregateOutputType | null
  }

  export type SocialLinksMinAggregateOutputType = {
    id: string | null
    platform: string | null
    url: string | null
    platformUsername: string | null
    identityId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SocialLinksMaxAggregateOutputType = {
    id: string | null
    platform: string | null
    url: string | null
    platformUsername: string | null
    identityId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SocialLinksCountAggregateOutputType = {
    id: number
    platform: number
    url: number
    platformUsername: number
    identityId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SocialLinksMinAggregateInputType = {
    id?: true
    platform?: true
    url?: true
    platformUsername?: true
    identityId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SocialLinksMaxAggregateInputType = {
    id?: true
    platform?: true
    url?: true
    platformUsername?: true
    identityId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SocialLinksCountAggregateInputType = {
    id?: true
    platform?: true
    url?: true
    platformUsername?: true
    identityId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SocialLinksAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SocialLinks to aggregate.
     */
    where?: SocialLinksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SocialLinks to fetch.
     */
    orderBy?: SocialLinksOrderByWithRelationInput | SocialLinksOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SocialLinksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SocialLinks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SocialLinks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SocialLinks
    **/
    _count?: true | SocialLinksCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SocialLinksMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SocialLinksMaxAggregateInputType
  }

  export type GetSocialLinksAggregateType<T extends SocialLinksAggregateArgs> = {
        [P in keyof T & keyof AggregateSocialLinks]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSocialLinks[P]>
      : GetScalarType<T[P], AggregateSocialLinks[P]>
  }




  export type SocialLinksGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SocialLinksWhereInput
    orderBy?: SocialLinksOrderByWithAggregationInput | SocialLinksOrderByWithAggregationInput[]
    by: SocialLinksScalarFieldEnum[] | SocialLinksScalarFieldEnum
    having?: SocialLinksScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SocialLinksCountAggregateInputType | true
    _min?: SocialLinksMinAggregateInputType
    _max?: SocialLinksMaxAggregateInputType
  }

  export type SocialLinksGroupByOutputType = {
    id: string
    platform: string | null
    url: string | null
    platformUsername: string | null
    identityId: string | null
    createdAt: Date
    updatedAt: Date
    _count: SocialLinksCountAggregateOutputType | null
    _min: SocialLinksMinAggregateOutputType | null
    _max: SocialLinksMaxAggregateOutputType | null
  }

  type GetSocialLinksGroupByPayload<T extends SocialLinksGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SocialLinksGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SocialLinksGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SocialLinksGroupByOutputType[P]>
            : GetScalarType<T[P], SocialLinksGroupByOutputType[P]>
        }
      >
    >


  export type SocialLinksSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    platform?: boolean
    url?: boolean
    platformUsername?: boolean
    identityId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    identity?: boolean | SocialLinks$identityArgs<ExtArgs>
  }, ExtArgs["result"]["socialLinks"]>

  export type SocialLinksSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    platform?: boolean
    url?: boolean
    platformUsername?: boolean
    identityId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    identity?: boolean | SocialLinks$identityArgs<ExtArgs>
  }, ExtArgs["result"]["socialLinks"]>

  export type SocialLinksSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    platform?: boolean
    url?: boolean
    platformUsername?: boolean
    identityId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    identity?: boolean | SocialLinks$identityArgs<ExtArgs>
  }, ExtArgs["result"]["socialLinks"]>

  export type SocialLinksSelectScalar = {
    id?: boolean
    platform?: boolean
    url?: boolean
    platformUsername?: boolean
    identityId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SocialLinksOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "platform" | "url" | "platformUsername" | "identityId" | "createdAt" | "updatedAt", ExtArgs["result"]["socialLinks"]>
  export type SocialLinksInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    identity?: boolean | SocialLinks$identityArgs<ExtArgs>
  }
  export type SocialLinksIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    identity?: boolean | SocialLinks$identityArgs<ExtArgs>
  }
  export type SocialLinksIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    identity?: boolean | SocialLinks$identityArgs<ExtArgs>
  }

  export type $SocialLinksPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SocialLinks"
    objects: {
      identity: Prisma.$SiteIdentityPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      platform: string | null
      url: string | null
      platformUsername: string | null
      identityId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["socialLinks"]>
    composites: {}
  }

  type SocialLinksGetPayload<S extends boolean | null | undefined | SocialLinksDefaultArgs> = $Result.GetResult<Prisma.$SocialLinksPayload, S>

  type SocialLinksCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SocialLinksFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SocialLinksCountAggregateInputType | true
    }

  export interface SocialLinksDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SocialLinks'], meta: { name: 'SocialLinks' } }
    /**
     * Find zero or one SocialLinks that matches the filter.
     * @param {SocialLinksFindUniqueArgs} args - Arguments to find a SocialLinks
     * @example
     * // Get one SocialLinks
     * const socialLinks = await prisma.socialLinks.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SocialLinksFindUniqueArgs>(args: SelectSubset<T, SocialLinksFindUniqueArgs<ExtArgs>>): Prisma__SocialLinksClient<$Result.GetResult<Prisma.$SocialLinksPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SocialLinks that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SocialLinksFindUniqueOrThrowArgs} args - Arguments to find a SocialLinks
     * @example
     * // Get one SocialLinks
     * const socialLinks = await prisma.socialLinks.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SocialLinksFindUniqueOrThrowArgs>(args: SelectSubset<T, SocialLinksFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SocialLinksClient<$Result.GetResult<Prisma.$SocialLinksPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SocialLinks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SocialLinksFindFirstArgs} args - Arguments to find a SocialLinks
     * @example
     * // Get one SocialLinks
     * const socialLinks = await prisma.socialLinks.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SocialLinksFindFirstArgs>(args?: SelectSubset<T, SocialLinksFindFirstArgs<ExtArgs>>): Prisma__SocialLinksClient<$Result.GetResult<Prisma.$SocialLinksPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SocialLinks that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SocialLinksFindFirstOrThrowArgs} args - Arguments to find a SocialLinks
     * @example
     * // Get one SocialLinks
     * const socialLinks = await prisma.socialLinks.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SocialLinksFindFirstOrThrowArgs>(args?: SelectSubset<T, SocialLinksFindFirstOrThrowArgs<ExtArgs>>): Prisma__SocialLinksClient<$Result.GetResult<Prisma.$SocialLinksPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SocialLinks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SocialLinksFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SocialLinks
     * const socialLinks = await prisma.socialLinks.findMany()
     * 
     * // Get first 10 SocialLinks
     * const socialLinks = await prisma.socialLinks.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const socialLinksWithIdOnly = await prisma.socialLinks.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SocialLinksFindManyArgs>(args?: SelectSubset<T, SocialLinksFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SocialLinksPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SocialLinks.
     * @param {SocialLinksCreateArgs} args - Arguments to create a SocialLinks.
     * @example
     * // Create one SocialLinks
     * const SocialLinks = await prisma.socialLinks.create({
     *   data: {
     *     // ... data to create a SocialLinks
     *   }
     * })
     * 
     */
    create<T extends SocialLinksCreateArgs>(args: SelectSubset<T, SocialLinksCreateArgs<ExtArgs>>): Prisma__SocialLinksClient<$Result.GetResult<Prisma.$SocialLinksPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SocialLinks.
     * @param {SocialLinksCreateManyArgs} args - Arguments to create many SocialLinks.
     * @example
     * // Create many SocialLinks
     * const socialLinks = await prisma.socialLinks.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SocialLinksCreateManyArgs>(args?: SelectSubset<T, SocialLinksCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SocialLinks and returns the data saved in the database.
     * @param {SocialLinksCreateManyAndReturnArgs} args - Arguments to create many SocialLinks.
     * @example
     * // Create many SocialLinks
     * const socialLinks = await prisma.socialLinks.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SocialLinks and only return the `id`
     * const socialLinksWithIdOnly = await prisma.socialLinks.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SocialLinksCreateManyAndReturnArgs>(args?: SelectSubset<T, SocialLinksCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SocialLinksPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SocialLinks.
     * @param {SocialLinksDeleteArgs} args - Arguments to delete one SocialLinks.
     * @example
     * // Delete one SocialLinks
     * const SocialLinks = await prisma.socialLinks.delete({
     *   where: {
     *     // ... filter to delete one SocialLinks
     *   }
     * })
     * 
     */
    delete<T extends SocialLinksDeleteArgs>(args: SelectSubset<T, SocialLinksDeleteArgs<ExtArgs>>): Prisma__SocialLinksClient<$Result.GetResult<Prisma.$SocialLinksPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SocialLinks.
     * @param {SocialLinksUpdateArgs} args - Arguments to update one SocialLinks.
     * @example
     * // Update one SocialLinks
     * const socialLinks = await prisma.socialLinks.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SocialLinksUpdateArgs>(args: SelectSubset<T, SocialLinksUpdateArgs<ExtArgs>>): Prisma__SocialLinksClient<$Result.GetResult<Prisma.$SocialLinksPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SocialLinks.
     * @param {SocialLinksDeleteManyArgs} args - Arguments to filter SocialLinks to delete.
     * @example
     * // Delete a few SocialLinks
     * const { count } = await prisma.socialLinks.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SocialLinksDeleteManyArgs>(args?: SelectSubset<T, SocialLinksDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SocialLinks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SocialLinksUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SocialLinks
     * const socialLinks = await prisma.socialLinks.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SocialLinksUpdateManyArgs>(args: SelectSubset<T, SocialLinksUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SocialLinks and returns the data updated in the database.
     * @param {SocialLinksUpdateManyAndReturnArgs} args - Arguments to update many SocialLinks.
     * @example
     * // Update many SocialLinks
     * const socialLinks = await prisma.socialLinks.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SocialLinks and only return the `id`
     * const socialLinksWithIdOnly = await prisma.socialLinks.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SocialLinksUpdateManyAndReturnArgs>(args: SelectSubset<T, SocialLinksUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SocialLinksPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SocialLinks.
     * @param {SocialLinksUpsertArgs} args - Arguments to update or create a SocialLinks.
     * @example
     * // Update or create a SocialLinks
     * const socialLinks = await prisma.socialLinks.upsert({
     *   create: {
     *     // ... data to create a SocialLinks
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SocialLinks we want to update
     *   }
     * })
     */
    upsert<T extends SocialLinksUpsertArgs>(args: SelectSubset<T, SocialLinksUpsertArgs<ExtArgs>>): Prisma__SocialLinksClient<$Result.GetResult<Prisma.$SocialLinksPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SocialLinks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SocialLinksCountArgs} args - Arguments to filter SocialLinks to count.
     * @example
     * // Count the number of SocialLinks
     * const count = await prisma.socialLinks.count({
     *   where: {
     *     // ... the filter for the SocialLinks we want to count
     *   }
     * })
    **/
    count<T extends SocialLinksCountArgs>(
      args?: Subset<T, SocialLinksCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SocialLinksCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SocialLinks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SocialLinksAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SocialLinksAggregateArgs>(args: Subset<T, SocialLinksAggregateArgs>): Prisma.PrismaPromise<GetSocialLinksAggregateType<T>>

    /**
     * Group by SocialLinks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SocialLinksGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SocialLinksGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SocialLinksGroupByArgs['orderBy'] }
        : { orderBy?: SocialLinksGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SocialLinksGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSocialLinksGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SocialLinks model
   */
  readonly fields: SocialLinksFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SocialLinks.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SocialLinksClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    identity<T extends SocialLinks$identityArgs<ExtArgs> = {}>(args?: Subset<T, SocialLinks$identityArgs<ExtArgs>>): Prisma__SiteIdentityClient<$Result.GetResult<Prisma.$SiteIdentityPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SocialLinks model
   */
  interface SocialLinksFieldRefs {
    readonly id: FieldRef<"SocialLinks", 'String'>
    readonly platform: FieldRef<"SocialLinks", 'String'>
    readonly url: FieldRef<"SocialLinks", 'String'>
    readonly platformUsername: FieldRef<"SocialLinks", 'String'>
    readonly identityId: FieldRef<"SocialLinks", 'String'>
    readonly createdAt: FieldRef<"SocialLinks", 'DateTime'>
    readonly updatedAt: FieldRef<"SocialLinks", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SocialLinks findUnique
   */
  export type SocialLinksFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialLinks
     */
    select?: SocialLinksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SocialLinks
     */
    omit?: SocialLinksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SocialLinksInclude<ExtArgs> | null
    /**
     * Filter, which SocialLinks to fetch.
     */
    where: SocialLinksWhereUniqueInput
  }

  /**
   * SocialLinks findUniqueOrThrow
   */
  export type SocialLinksFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialLinks
     */
    select?: SocialLinksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SocialLinks
     */
    omit?: SocialLinksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SocialLinksInclude<ExtArgs> | null
    /**
     * Filter, which SocialLinks to fetch.
     */
    where: SocialLinksWhereUniqueInput
  }

  /**
   * SocialLinks findFirst
   */
  export type SocialLinksFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialLinks
     */
    select?: SocialLinksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SocialLinks
     */
    omit?: SocialLinksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SocialLinksInclude<ExtArgs> | null
    /**
     * Filter, which SocialLinks to fetch.
     */
    where?: SocialLinksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SocialLinks to fetch.
     */
    orderBy?: SocialLinksOrderByWithRelationInput | SocialLinksOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SocialLinks.
     */
    cursor?: SocialLinksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SocialLinks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SocialLinks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SocialLinks.
     */
    distinct?: SocialLinksScalarFieldEnum | SocialLinksScalarFieldEnum[]
  }

  /**
   * SocialLinks findFirstOrThrow
   */
  export type SocialLinksFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialLinks
     */
    select?: SocialLinksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SocialLinks
     */
    omit?: SocialLinksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SocialLinksInclude<ExtArgs> | null
    /**
     * Filter, which SocialLinks to fetch.
     */
    where?: SocialLinksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SocialLinks to fetch.
     */
    orderBy?: SocialLinksOrderByWithRelationInput | SocialLinksOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SocialLinks.
     */
    cursor?: SocialLinksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SocialLinks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SocialLinks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SocialLinks.
     */
    distinct?: SocialLinksScalarFieldEnum | SocialLinksScalarFieldEnum[]
  }

  /**
   * SocialLinks findMany
   */
  export type SocialLinksFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialLinks
     */
    select?: SocialLinksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SocialLinks
     */
    omit?: SocialLinksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SocialLinksInclude<ExtArgs> | null
    /**
     * Filter, which SocialLinks to fetch.
     */
    where?: SocialLinksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SocialLinks to fetch.
     */
    orderBy?: SocialLinksOrderByWithRelationInput | SocialLinksOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SocialLinks.
     */
    cursor?: SocialLinksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SocialLinks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SocialLinks.
     */
    skip?: number
    distinct?: SocialLinksScalarFieldEnum | SocialLinksScalarFieldEnum[]
  }

  /**
   * SocialLinks create
   */
  export type SocialLinksCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialLinks
     */
    select?: SocialLinksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SocialLinks
     */
    omit?: SocialLinksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SocialLinksInclude<ExtArgs> | null
    /**
     * The data needed to create a SocialLinks.
     */
    data?: XOR<SocialLinksCreateInput, SocialLinksUncheckedCreateInput>
  }

  /**
   * SocialLinks createMany
   */
  export type SocialLinksCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SocialLinks.
     */
    data: SocialLinksCreateManyInput | SocialLinksCreateManyInput[]
  }

  /**
   * SocialLinks createManyAndReturn
   */
  export type SocialLinksCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialLinks
     */
    select?: SocialLinksSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SocialLinks
     */
    omit?: SocialLinksOmit<ExtArgs> | null
    /**
     * The data used to create many SocialLinks.
     */
    data: SocialLinksCreateManyInput | SocialLinksCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SocialLinksIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SocialLinks update
   */
  export type SocialLinksUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialLinks
     */
    select?: SocialLinksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SocialLinks
     */
    omit?: SocialLinksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SocialLinksInclude<ExtArgs> | null
    /**
     * The data needed to update a SocialLinks.
     */
    data: XOR<SocialLinksUpdateInput, SocialLinksUncheckedUpdateInput>
    /**
     * Choose, which SocialLinks to update.
     */
    where: SocialLinksWhereUniqueInput
  }

  /**
   * SocialLinks updateMany
   */
  export type SocialLinksUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SocialLinks.
     */
    data: XOR<SocialLinksUpdateManyMutationInput, SocialLinksUncheckedUpdateManyInput>
    /**
     * Filter which SocialLinks to update
     */
    where?: SocialLinksWhereInput
    /**
     * Limit how many SocialLinks to update.
     */
    limit?: number
  }

  /**
   * SocialLinks updateManyAndReturn
   */
  export type SocialLinksUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialLinks
     */
    select?: SocialLinksSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SocialLinks
     */
    omit?: SocialLinksOmit<ExtArgs> | null
    /**
     * The data used to update SocialLinks.
     */
    data: XOR<SocialLinksUpdateManyMutationInput, SocialLinksUncheckedUpdateManyInput>
    /**
     * Filter which SocialLinks to update
     */
    where?: SocialLinksWhereInput
    /**
     * Limit how many SocialLinks to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SocialLinksIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SocialLinks upsert
   */
  export type SocialLinksUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialLinks
     */
    select?: SocialLinksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SocialLinks
     */
    omit?: SocialLinksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SocialLinksInclude<ExtArgs> | null
    /**
     * The filter to search for the SocialLinks to update in case it exists.
     */
    where: SocialLinksWhereUniqueInput
    /**
     * In case the SocialLinks found by the `where` argument doesn't exist, create a new SocialLinks with this data.
     */
    create: XOR<SocialLinksCreateInput, SocialLinksUncheckedCreateInput>
    /**
     * In case the SocialLinks was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SocialLinksUpdateInput, SocialLinksUncheckedUpdateInput>
  }

  /**
   * SocialLinks delete
   */
  export type SocialLinksDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialLinks
     */
    select?: SocialLinksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SocialLinks
     */
    omit?: SocialLinksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SocialLinksInclude<ExtArgs> | null
    /**
     * Filter which SocialLinks to delete.
     */
    where: SocialLinksWhereUniqueInput
  }

  /**
   * SocialLinks deleteMany
   */
  export type SocialLinksDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SocialLinks to delete
     */
    where?: SocialLinksWhereInput
    /**
     * Limit how many SocialLinks to delete.
     */
    limit?: number
  }

  /**
   * SocialLinks.identity
   */
  export type SocialLinks$identityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SiteIdentity
     */
    select?: SiteIdentitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SiteIdentity
     */
    omit?: SiteIdentityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SiteIdentityInclude<ExtArgs> | null
    where?: SiteIdentityWhereInput
  }

  /**
   * SocialLinks without action
   */
  export type SocialLinksDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialLinks
     */
    select?: SocialLinksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SocialLinks
     */
    omit?: SocialLinksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SocialLinksInclude<ExtArgs> | null
  }


  /**
   * Model Page
   */

  export type AggregatePage = {
    _count: PageCountAggregateOutputType | null
    _min: PageMinAggregateOutputType | null
    _max: PageMaxAggregateOutputType | null
  }

  export type PageMinAggregateOutputType = {
    id: string | null
    slug: string | null
    name: string | null
    title: string | null
    description: string | null
    ogTitle: string | null
    ogDescription: string | null
    ogImage: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PageMaxAggregateOutputType = {
    id: string | null
    slug: string | null
    name: string | null
    title: string | null
    description: string | null
    ogTitle: string | null
    ogDescription: string | null
    ogImage: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PageCountAggregateOutputType = {
    id: number
    slug: number
    name: number
    title: number
    description: number
    keywords: number
    ogTitle: number
    ogDescription: number
    ogImage: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PageMinAggregateInputType = {
    id?: true
    slug?: true
    name?: true
    title?: true
    description?: true
    ogTitle?: true
    ogDescription?: true
    ogImage?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PageMaxAggregateInputType = {
    id?: true
    slug?: true
    name?: true
    title?: true
    description?: true
    ogTitle?: true
    ogDescription?: true
    ogImage?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PageCountAggregateInputType = {
    id?: true
    slug?: true
    name?: true
    title?: true
    description?: true
    keywords?: true
    ogTitle?: true
    ogDescription?: true
    ogImage?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Page to aggregate.
     */
    where?: PageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pages to fetch.
     */
    orderBy?: PageOrderByWithRelationInput | PageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Pages
    **/
    _count?: true | PageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PageMaxAggregateInputType
  }

  export type GetPageAggregateType<T extends PageAggregateArgs> = {
        [P in keyof T & keyof AggregatePage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePage[P]>
      : GetScalarType<T[P], AggregatePage[P]>
  }




  export type PageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PageWhereInput
    orderBy?: PageOrderByWithAggregationInput | PageOrderByWithAggregationInput[]
    by: PageScalarFieldEnum[] | PageScalarFieldEnum
    having?: PageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PageCountAggregateInputType | true
    _min?: PageMinAggregateInputType
    _max?: PageMaxAggregateInputType
  }

  export type PageGroupByOutputType = {
    id: string
    slug: string
    name: string
    title: string
    description: string | null
    keywords: JsonValue | null
    ogTitle: string | null
    ogDescription: string | null
    ogImage: string | null
    createdAt: Date
    updatedAt: Date
    _count: PageCountAggregateOutputType | null
    _min: PageMinAggregateOutputType | null
    _max: PageMaxAggregateOutputType | null
  }

  type GetPageGroupByPayload<T extends PageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PageGroupByOutputType[P]>
            : GetScalarType<T[P], PageGroupByOutputType[P]>
        }
      >
    >


  export type PageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    slug?: boolean
    name?: boolean
    title?: boolean
    description?: boolean
    keywords?: boolean
    ogTitle?: boolean
    ogDescription?: boolean
    ogImage?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    sections?: boolean | Page$sectionsArgs<ExtArgs>
    _count?: boolean | PageCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["page"]>

  export type PageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    slug?: boolean
    name?: boolean
    title?: boolean
    description?: boolean
    keywords?: boolean
    ogTitle?: boolean
    ogDescription?: boolean
    ogImage?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["page"]>

  export type PageSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    slug?: boolean
    name?: boolean
    title?: boolean
    description?: boolean
    keywords?: boolean
    ogTitle?: boolean
    ogDescription?: boolean
    ogImage?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["page"]>

  export type PageSelectScalar = {
    id?: boolean
    slug?: boolean
    name?: boolean
    title?: boolean
    description?: boolean
    keywords?: boolean
    ogTitle?: boolean
    ogDescription?: boolean
    ogImage?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "slug" | "name" | "title" | "description" | "keywords" | "ogTitle" | "ogDescription" | "ogImage" | "createdAt" | "updatedAt", ExtArgs["result"]["page"]>
  export type PageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sections?: boolean | Page$sectionsArgs<ExtArgs>
    _count?: boolean | PageCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type PageIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $PagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Page"
    objects: {
      sections: Prisma.$SectionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      slug: string
      name: string
      title: string
      description: string | null
      keywords: Prisma.JsonValue | null
      ogTitle: string | null
      ogDescription: string | null
      ogImage: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["page"]>
    composites: {}
  }

  type PageGetPayload<S extends boolean | null | undefined | PageDefaultArgs> = $Result.GetResult<Prisma.$PagePayload, S>

  type PageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PageCountAggregateInputType | true
    }

  export interface PageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Page'], meta: { name: 'Page' } }
    /**
     * Find zero or one Page that matches the filter.
     * @param {PageFindUniqueArgs} args - Arguments to find a Page
     * @example
     * // Get one Page
     * const page = await prisma.page.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PageFindUniqueArgs>(args: SelectSubset<T, PageFindUniqueArgs<ExtArgs>>): Prisma__PageClient<$Result.GetResult<Prisma.$PagePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Page that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PageFindUniqueOrThrowArgs} args - Arguments to find a Page
     * @example
     * // Get one Page
     * const page = await prisma.page.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PageFindUniqueOrThrowArgs>(args: SelectSubset<T, PageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PageClient<$Result.GetResult<Prisma.$PagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Page that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PageFindFirstArgs} args - Arguments to find a Page
     * @example
     * // Get one Page
     * const page = await prisma.page.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PageFindFirstArgs>(args?: SelectSubset<T, PageFindFirstArgs<ExtArgs>>): Prisma__PageClient<$Result.GetResult<Prisma.$PagePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Page that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PageFindFirstOrThrowArgs} args - Arguments to find a Page
     * @example
     * // Get one Page
     * const page = await prisma.page.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PageFindFirstOrThrowArgs>(args?: SelectSubset<T, PageFindFirstOrThrowArgs<ExtArgs>>): Prisma__PageClient<$Result.GetResult<Prisma.$PagePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Pages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Pages
     * const pages = await prisma.page.findMany()
     * 
     * // Get first 10 Pages
     * const pages = await prisma.page.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const pageWithIdOnly = await prisma.page.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PageFindManyArgs>(args?: SelectSubset<T, PageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Page.
     * @param {PageCreateArgs} args - Arguments to create a Page.
     * @example
     * // Create one Page
     * const Page = await prisma.page.create({
     *   data: {
     *     // ... data to create a Page
     *   }
     * })
     * 
     */
    create<T extends PageCreateArgs>(args: SelectSubset<T, PageCreateArgs<ExtArgs>>): Prisma__PageClient<$Result.GetResult<Prisma.$PagePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Pages.
     * @param {PageCreateManyArgs} args - Arguments to create many Pages.
     * @example
     * // Create many Pages
     * const page = await prisma.page.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PageCreateManyArgs>(args?: SelectSubset<T, PageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Pages and returns the data saved in the database.
     * @param {PageCreateManyAndReturnArgs} args - Arguments to create many Pages.
     * @example
     * // Create many Pages
     * const page = await prisma.page.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Pages and only return the `id`
     * const pageWithIdOnly = await prisma.page.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PageCreateManyAndReturnArgs>(args?: SelectSubset<T, PageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PagePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Page.
     * @param {PageDeleteArgs} args - Arguments to delete one Page.
     * @example
     * // Delete one Page
     * const Page = await prisma.page.delete({
     *   where: {
     *     // ... filter to delete one Page
     *   }
     * })
     * 
     */
    delete<T extends PageDeleteArgs>(args: SelectSubset<T, PageDeleteArgs<ExtArgs>>): Prisma__PageClient<$Result.GetResult<Prisma.$PagePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Page.
     * @param {PageUpdateArgs} args - Arguments to update one Page.
     * @example
     * // Update one Page
     * const page = await prisma.page.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PageUpdateArgs>(args: SelectSubset<T, PageUpdateArgs<ExtArgs>>): Prisma__PageClient<$Result.GetResult<Prisma.$PagePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Pages.
     * @param {PageDeleteManyArgs} args - Arguments to filter Pages to delete.
     * @example
     * // Delete a few Pages
     * const { count } = await prisma.page.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PageDeleteManyArgs>(args?: SelectSubset<T, PageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Pages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Pages
     * const page = await prisma.page.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PageUpdateManyArgs>(args: SelectSubset<T, PageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Pages and returns the data updated in the database.
     * @param {PageUpdateManyAndReturnArgs} args - Arguments to update many Pages.
     * @example
     * // Update many Pages
     * const page = await prisma.page.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Pages and only return the `id`
     * const pageWithIdOnly = await prisma.page.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PageUpdateManyAndReturnArgs>(args: SelectSubset<T, PageUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PagePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Page.
     * @param {PageUpsertArgs} args - Arguments to update or create a Page.
     * @example
     * // Update or create a Page
     * const page = await prisma.page.upsert({
     *   create: {
     *     // ... data to create a Page
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Page we want to update
     *   }
     * })
     */
    upsert<T extends PageUpsertArgs>(args: SelectSubset<T, PageUpsertArgs<ExtArgs>>): Prisma__PageClient<$Result.GetResult<Prisma.$PagePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Pages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PageCountArgs} args - Arguments to filter Pages to count.
     * @example
     * // Count the number of Pages
     * const count = await prisma.page.count({
     *   where: {
     *     // ... the filter for the Pages we want to count
     *   }
     * })
    **/
    count<T extends PageCountArgs>(
      args?: Subset<T, PageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Page.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PageAggregateArgs>(args: Subset<T, PageAggregateArgs>): Prisma.PrismaPromise<GetPageAggregateType<T>>

    /**
     * Group by Page.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PageGroupByArgs['orderBy'] }
        : { orderBy?: PageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Page model
   */
  readonly fields: PageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Page.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    sections<T extends Page$sectionsArgs<ExtArgs> = {}>(args?: Subset<T, Page$sectionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SectionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Page model
   */
  interface PageFieldRefs {
    readonly id: FieldRef<"Page", 'String'>
    readonly slug: FieldRef<"Page", 'String'>
    readonly name: FieldRef<"Page", 'String'>
    readonly title: FieldRef<"Page", 'String'>
    readonly description: FieldRef<"Page", 'String'>
    readonly keywords: FieldRef<"Page", 'Json'>
    readonly ogTitle: FieldRef<"Page", 'String'>
    readonly ogDescription: FieldRef<"Page", 'String'>
    readonly ogImage: FieldRef<"Page", 'String'>
    readonly createdAt: FieldRef<"Page", 'DateTime'>
    readonly updatedAt: FieldRef<"Page", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Page findUnique
   */
  export type PageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Page
     */
    select?: PageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Page
     */
    omit?: PageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PageInclude<ExtArgs> | null
    /**
     * Filter, which Page to fetch.
     */
    where: PageWhereUniqueInput
  }

  /**
   * Page findUniqueOrThrow
   */
  export type PageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Page
     */
    select?: PageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Page
     */
    omit?: PageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PageInclude<ExtArgs> | null
    /**
     * Filter, which Page to fetch.
     */
    where: PageWhereUniqueInput
  }

  /**
   * Page findFirst
   */
  export type PageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Page
     */
    select?: PageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Page
     */
    omit?: PageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PageInclude<ExtArgs> | null
    /**
     * Filter, which Page to fetch.
     */
    where?: PageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pages to fetch.
     */
    orderBy?: PageOrderByWithRelationInput | PageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Pages.
     */
    cursor?: PageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Pages.
     */
    distinct?: PageScalarFieldEnum | PageScalarFieldEnum[]
  }

  /**
   * Page findFirstOrThrow
   */
  export type PageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Page
     */
    select?: PageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Page
     */
    omit?: PageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PageInclude<ExtArgs> | null
    /**
     * Filter, which Page to fetch.
     */
    where?: PageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pages to fetch.
     */
    orderBy?: PageOrderByWithRelationInput | PageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Pages.
     */
    cursor?: PageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Pages.
     */
    distinct?: PageScalarFieldEnum | PageScalarFieldEnum[]
  }

  /**
   * Page findMany
   */
  export type PageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Page
     */
    select?: PageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Page
     */
    omit?: PageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PageInclude<ExtArgs> | null
    /**
     * Filter, which Pages to fetch.
     */
    where?: PageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pages to fetch.
     */
    orderBy?: PageOrderByWithRelationInput | PageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Pages.
     */
    cursor?: PageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pages.
     */
    skip?: number
    distinct?: PageScalarFieldEnum | PageScalarFieldEnum[]
  }

  /**
   * Page create
   */
  export type PageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Page
     */
    select?: PageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Page
     */
    omit?: PageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PageInclude<ExtArgs> | null
    /**
     * The data needed to create a Page.
     */
    data: XOR<PageCreateInput, PageUncheckedCreateInput>
  }

  /**
   * Page createMany
   */
  export type PageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Pages.
     */
    data: PageCreateManyInput | PageCreateManyInput[]
  }

  /**
   * Page createManyAndReturn
   */
  export type PageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Page
     */
    select?: PageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Page
     */
    omit?: PageOmit<ExtArgs> | null
    /**
     * The data used to create many Pages.
     */
    data: PageCreateManyInput | PageCreateManyInput[]
  }

  /**
   * Page update
   */
  export type PageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Page
     */
    select?: PageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Page
     */
    omit?: PageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PageInclude<ExtArgs> | null
    /**
     * The data needed to update a Page.
     */
    data: XOR<PageUpdateInput, PageUncheckedUpdateInput>
    /**
     * Choose, which Page to update.
     */
    where: PageWhereUniqueInput
  }

  /**
   * Page updateMany
   */
  export type PageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Pages.
     */
    data: XOR<PageUpdateManyMutationInput, PageUncheckedUpdateManyInput>
    /**
     * Filter which Pages to update
     */
    where?: PageWhereInput
    /**
     * Limit how many Pages to update.
     */
    limit?: number
  }

  /**
   * Page updateManyAndReturn
   */
  export type PageUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Page
     */
    select?: PageSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Page
     */
    omit?: PageOmit<ExtArgs> | null
    /**
     * The data used to update Pages.
     */
    data: XOR<PageUpdateManyMutationInput, PageUncheckedUpdateManyInput>
    /**
     * Filter which Pages to update
     */
    where?: PageWhereInput
    /**
     * Limit how many Pages to update.
     */
    limit?: number
  }

  /**
   * Page upsert
   */
  export type PageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Page
     */
    select?: PageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Page
     */
    omit?: PageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PageInclude<ExtArgs> | null
    /**
     * The filter to search for the Page to update in case it exists.
     */
    where: PageWhereUniqueInput
    /**
     * In case the Page found by the `where` argument doesn't exist, create a new Page with this data.
     */
    create: XOR<PageCreateInput, PageUncheckedCreateInput>
    /**
     * In case the Page was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PageUpdateInput, PageUncheckedUpdateInput>
  }

  /**
   * Page delete
   */
  export type PageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Page
     */
    select?: PageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Page
     */
    omit?: PageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PageInclude<ExtArgs> | null
    /**
     * Filter which Page to delete.
     */
    where: PageWhereUniqueInput
  }

  /**
   * Page deleteMany
   */
  export type PageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Pages to delete
     */
    where?: PageWhereInput
    /**
     * Limit how many Pages to delete.
     */
    limit?: number
  }

  /**
   * Page.sections
   */
  export type Page$sectionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Section
     */
    select?: SectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Section
     */
    omit?: SectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SectionInclude<ExtArgs> | null
    where?: SectionWhereInput
    orderBy?: SectionOrderByWithRelationInput | SectionOrderByWithRelationInput[]
    cursor?: SectionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SectionScalarFieldEnum | SectionScalarFieldEnum[]
  }

  /**
   * Page without action
   */
  export type PageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Page
     */
    select?: PageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Page
     */
    omit?: PageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PageInclude<ExtArgs> | null
  }


  /**
   * Model Section
   */

  export type AggregateSection = {
    _count: SectionCountAggregateOutputType | null
    _avg: SectionAvgAggregateOutputType | null
    _sum: SectionSumAggregateOutputType | null
    _min: SectionMinAggregateOutputType | null
    _max: SectionMaxAggregateOutputType | null
  }

  export type SectionAvgAggregateOutputType = {
    order: number | null
  }

  export type SectionSumAggregateOutputType = {
    order: number | null
  }

  export type SectionMinAggregateOutputType = {
    id: string | null
    name: string | null
    pageId: string | null
    type: $Enums.SectionType | null
    title: string | null
    subTitle: string | null
    description: string | null
    additionalText: string | null
    image: string | null
    video: string | null
    icon: string | null
    order: number | null
  }

  export type SectionMaxAggregateOutputType = {
    id: string | null
    name: string | null
    pageId: string | null
    type: $Enums.SectionType | null
    title: string | null
    subTitle: string | null
    description: string | null
    additionalText: string | null
    image: string | null
    video: string | null
    icon: string | null
    order: number | null
  }

  export type SectionCountAggregateOutputType = {
    id: number
    name: number
    pageId: number
    type: number
    title: number
    subTitle: number
    description: number
    additionalText: number
    image: number
    video: number
    icon: number
    order: number
    _all: number
  }


  export type SectionAvgAggregateInputType = {
    order?: true
  }

  export type SectionSumAggregateInputType = {
    order?: true
  }

  export type SectionMinAggregateInputType = {
    id?: true
    name?: true
    pageId?: true
    type?: true
    title?: true
    subTitle?: true
    description?: true
    additionalText?: true
    image?: true
    video?: true
    icon?: true
    order?: true
  }

  export type SectionMaxAggregateInputType = {
    id?: true
    name?: true
    pageId?: true
    type?: true
    title?: true
    subTitle?: true
    description?: true
    additionalText?: true
    image?: true
    video?: true
    icon?: true
    order?: true
  }

  export type SectionCountAggregateInputType = {
    id?: true
    name?: true
    pageId?: true
    type?: true
    title?: true
    subTitle?: true
    description?: true
    additionalText?: true
    image?: true
    video?: true
    icon?: true
    order?: true
    _all?: true
  }

  export type SectionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Section to aggregate.
     */
    where?: SectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sections to fetch.
     */
    orderBy?: SectionOrderByWithRelationInput | SectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Sections
    **/
    _count?: true | SectionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SectionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SectionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SectionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SectionMaxAggregateInputType
  }

  export type GetSectionAggregateType<T extends SectionAggregateArgs> = {
        [P in keyof T & keyof AggregateSection]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSection[P]>
      : GetScalarType<T[P], AggregateSection[P]>
  }




  export type SectionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SectionWhereInput
    orderBy?: SectionOrderByWithAggregationInput | SectionOrderByWithAggregationInput[]
    by: SectionScalarFieldEnum[] | SectionScalarFieldEnum
    having?: SectionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SectionCountAggregateInputType | true
    _avg?: SectionAvgAggregateInputType
    _sum?: SectionSumAggregateInputType
    _min?: SectionMinAggregateInputType
    _max?: SectionMaxAggregateInputType
  }

  export type SectionGroupByOutputType = {
    id: string
    name: string | null
    pageId: string
    type: $Enums.SectionType
    title: string
    subTitle: string | null
    description: string | null
    additionalText: string | null
    image: string | null
    video: string | null
    icon: string | null
    order: number
    _count: SectionCountAggregateOutputType | null
    _avg: SectionAvgAggregateOutputType | null
    _sum: SectionSumAggregateOutputType | null
    _min: SectionMinAggregateOutputType | null
    _max: SectionMaxAggregateOutputType | null
  }

  type GetSectionGroupByPayload<T extends SectionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SectionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SectionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SectionGroupByOutputType[P]>
            : GetScalarType<T[P], SectionGroupByOutputType[P]>
        }
      >
    >


  export type SectionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    pageId?: boolean
    type?: boolean
    title?: boolean
    subTitle?: boolean
    description?: boolean
    additionalText?: boolean
    image?: boolean
    video?: boolean
    icon?: boolean
    order?: boolean
    page?: boolean | PageDefaultArgs<ExtArgs>
    listItems?: boolean | Section$listItemsArgs<ExtArgs>
    _count?: boolean | SectionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["section"]>

  export type SectionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    pageId?: boolean
    type?: boolean
    title?: boolean
    subTitle?: boolean
    description?: boolean
    additionalText?: boolean
    image?: boolean
    video?: boolean
    icon?: boolean
    order?: boolean
    page?: boolean | PageDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["section"]>

  export type SectionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    pageId?: boolean
    type?: boolean
    title?: boolean
    subTitle?: boolean
    description?: boolean
    additionalText?: boolean
    image?: boolean
    video?: boolean
    icon?: boolean
    order?: boolean
    page?: boolean | PageDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["section"]>

  export type SectionSelectScalar = {
    id?: boolean
    name?: boolean
    pageId?: boolean
    type?: boolean
    title?: boolean
    subTitle?: boolean
    description?: boolean
    additionalText?: boolean
    image?: boolean
    video?: boolean
    icon?: boolean
    order?: boolean
  }

  export type SectionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "pageId" | "type" | "title" | "subTitle" | "description" | "additionalText" | "image" | "video" | "icon" | "order", ExtArgs["result"]["section"]>
  export type SectionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    page?: boolean | PageDefaultArgs<ExtArgs>
    listItems?: boolean | Section$listItemsArgs<ExtArgs>
    _count?: boolean | SectionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SectionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    page?: boolean | PageDefaultArgs<ExtArgs>
  }
  export type SectionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    page?: boolean | PageDefaultArgs<ExtArgs>
  }

  export type $SectionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Section"
    objects: {
      page: Prisma.$PagePayload<ExtArgs>
      listItems: Prisma.$ListItemPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string | null
      pageId: string
      type: $Enums.SectionType
      title: string
      subTitle: string | null
      description: string | null
      additionalText: string | null
      image: string | null
      video: string | null
      icon: string | null
      order: number
    }, ExtArgs["result"]["section"]>
    composites: {}
  }

  type SectionGetPayload<S extends boolean | null | undefined | SectionDefaultArgs> = $Result.GetResult<Prisma.$SectionPayload, S>

  type SectionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SectionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SectionCountAggregateInputType | true
    }

  export interface SectionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Section'], meta: { name: 'Section' } }
    /**
     * Find zero or one Section that matches the filter.
     * @param {SectionFindUniqueArgs} args - Arguments to find a Section
     * @example
     * // Get one Section
     * const section = await prisma.section.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SectionFindUniqueArgs>(args: SelectSubset<T, SectionFindUniqueArgs<ExtArgs>>): Prisma__SectionClient<$Result.GetResult<Prisma.$SectionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Section that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SectionFindUniqueOrThrowArgs} args - Arguments to find a Section
     * @example
     * // Get one Section
     * const section = await prisma.section.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SectionFindUniqueOrThrowArgs>(args: SelectSubset<T, SectionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SectionClient<$Result.GetResult<Prisma.$SectionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Section that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SectionFindFirstArgs} args - Arguments to find a Section
     * @example
     * // Get one Section
     * const section = await prisma.section.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SectionFindFirstArgs>(args?: SelectSubset<T, SectionFindFirstArgs<ExtArgs>>): Prisma__SectionClient<$Result.GetResult<Prisma.$SectionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Section that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SectionFindFirstOrThrowArgs} args - Arguments to find a Section
     * @example
     * // Get one Section
     * const section = await prisma.section.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SectionFindFirstOrThrowArgs>(args?: SelectSubset<T, SectionFindFirstOrThrowArgs<ExtArgs>>): Prisma__SectionClient<$Result.GetResult<Prisma.$SectionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Sections that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SectionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sections
     * const sections = await prisma.section.findMany()
     * 
     * // Get first 10 Sections
     * const sections = await prisma.section.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sectionWithIdOnly = await prisma.section.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SectionFindManyArgs>(args?: SelectSubset<T, SectionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SectionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Section.
     * @param {SectionCreateArgs} args - Arguments to create a Section.
     * @example
     * // Create one Section
     * const Section = await prisma.section.create({
     *   data: {
     *     // ... data to create a Section
     *   }
     * })
     * 
     */
    create<T extends SectionCreateArgs>(args: SelectSubset<T, SectionCreateArgs<ExtArgs>>): Prisma__SectionClient<$Result.GetResult<Prisma.$SectionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Sections.
     * @param {SectionCreateManyArgs} args - Arguments to create many Sections.
     * @example
     * // Create many Sections
     * const section = await prisma.section.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SectionCreateManyArgs>(args?: SelectSubset<T, SectionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Sections and returns the data saved in the database.
     * @param {SectionCreateManyAndReturnArgs} args - Arguments to create many Sections.
     * @example
     * // Create many Sections
     * const section = await prisma.section.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Sections and only return the `id`
     * const sectionWithIdOnly = await prisma.section.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SectionCreateManyAndReturnArgs>(args?: SelectSubset<T, SectionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SectionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Section.
     * @param {SectionDeleteArgs} args - Arguments to delete one Section.
     * @example
     * // Delete one Section
     * const Section = await prisma.section.delete({
     *   where: {
     *     // ... filter to delete one Section
     *   }
     * })
     * 
     */
    delete<T extends SectionDeleteArgs>(args: SelectSubset<T, SectionDeleteArgs<ExtArgs>>): Prisma__SectionClient<$Result.GetResult<Prisma.$SectionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Section.
     * @param {SectionUpdateArgs} args - Arguments to update one Section.
     * @example
     * // Update one Section
     * const section = await prisma.section.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SectionUpdateArgs>(args: SelectSubset<T, SectionUpdateArgs<ExtArgs>>): Prisma__SectionClient<$Result.GetResult<Prisma.$SectionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Sections.
     * @param {SectionDeleteManyArgs} args - Arguments to filter Sections to delete.
     * @example
     * // Delete a few Sections
     * const { count } = await prisma.section.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SectionDeleteManyArgs>(args?: SelectSubset<T, SectionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sections.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SectionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sections
     * const section = await prisma.section.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SectionUpdateManyArgs>(args: SelectSubset<T, SectionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sections and returns the data updated in the database.
     * @param {SectionUpdateManyAndReturnArgs} args - Arguments to update many Sections.
     * @example
     * // Update many Sections
     * const section = await prisma.section.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Sections and only return the `id`
     * const sectionWithIdOnly = await prisma.section.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SectionUpdateManyAndReturnArgs>(args: SelectSubset<T, SectionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SectionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Section.
     * @param {SectionUpsertArgs} args - Arguments to update or create a Section.
     * @example
     * // Update or create a Section
     * const section = await prisma.section.upsert({
     *   create: {
     *     // ... data to create a Section
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Section we want to update
     *   }
     * })
     */
    upsert<T extends SectionUpsertArgs>(args: SelectSubset<T, SectionUpsertArgs<ExtArgs>>): Prisma__SectionClient<$Result.GetResult<Prisma.$SectionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Sections.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SectionCountArgs} args - Arguments to filter Sections to count.
     * @example
     * // Count the number of Sections
     * const count = await prisma.section.count({
     *   where: {
     *     // ... the filter for the Sections we want to count
     *   }
     * })
    **/
    count<T extends SectionCountArgs>(
      args?: Subset<T, SectionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SectionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Section.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SectionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SectionAggregateArgs>(args: Subset<T, SectionAggregateArgs>): Prisma.PrismaPromise<GetSectionAggregateType<T>>

    /**
     * Group by Section.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SectionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SectionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SectionGroupByArgs['orderBy'] }
        : { orderBy?: SectionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SectionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSectionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Section model
   */
  readonly fields: SectionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Section.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SectionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    page<T extends PageDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PageDefaultArgs<ExtArgs>>): Prisma__PageClient<$Result.GetResult<Prisma.$PagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    listItems<T extends Section$listItemsArgs<ExtArgs> = {}>(args?: Subset<T, Section$listItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ListItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Section model
   */
  interface SectionFieldRefs {
    readonly id: FieldRef<"Section", 'String'>
    readonly name: FieldRef<"Section", 'String'>
    readonly pageId: FieldRef<"Section", 'String'>
    readonly type: FieldRef<"Section", 'SectionType'>
    readonly title: FieldRef<"Section", 'String'>
    readonly subTitle: FieldRef<"Section", 'String'>
    readonly description: FieldRef<"Section", 'String'>
    readonly additionalText: FieldRef<"Section", 'String'>
    readonly image: FieldRef<"Section", 'String'>
    readonly video: FieldRef<"Section", 'String'>
    readonly icon: FieldRef<"Section", 'String'>
    readonly order: FieldRef<"Section", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Section findUnique
   */
  export type SectionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Section
     */
    select?: SectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Section
     */
    omit?: SectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SectionInclude<ExtArgs> | null
    /**
     * Filter, which Section to fetch.
     */
    where: SectionWhereUniqueInput
  }

  /**
   * Section findUniqueOrThrow
   */
  export type SectionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Section
     */
    select?: SectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Section
     */
    omit?: SectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SectionInclude<ExtArgs> | null
    /**
     * Filter, which Section to fetch.
     */
    where: SectionWhereUniqueInput
  }

  /**
   * Section findFirst
   */
  export type SectionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Section
     */
    select?: SectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Section
     */
    omit?: SectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SectionInclude<ExtArgs> | null
    /**
     * Filter, which Section to fetch.
     */
    where?: SectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sections to fetch.
     */
    orderBy?: SectionOrderByWithRelationInput | SectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sections.
     */
    cursor?: SectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sections.
     */
    distinct?: SectionScalarFieldEnum | SectionScalarFieldEnum[]
  }

  /**
   * Section findFirstOrThrow
   */
  export type SectionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Section
     */
    select?: SectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Section
     */
    omit?: SectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SectionInclude<ExtArgs> | null
    /**
     * Filter, which Section to fetch.
     */
    where?: SectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sections to fetch.
     */
    orderBy?: SectionOrderByWithRelationInput | SectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sections.
     */
    cursor?: SectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sections.
     */
    distinct?: SectionScalarFieldEnum | SectionScalarFieldEnum[]
  }

  /**
   * Section findMany
   */
  export type SectionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Section
     */
    select?: SectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Section
     */
    omit?: SectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SectionInclude<ExtArgs> | null
    /**
     * Filter, which Sections to fetch.
     */
    where?: SectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sections to fetch.
     */
    orderBy?: SectionOrderByWithRelationInput | SectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Sections.
     */
    cursor?: SectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sections.
     */
    skip?: number
    distinct?: SectionScalarFieldEnum | SectionScalarFieldEnum[]
  }

  /**
   * Section create
   */
  export type SectionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Section
     */
    select?: SectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Section
     */
    omit?: SectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SectionInclude<ExtArgs> | null
    /**
     * The data needed to create a Section.
     */
    data: XOR<SectionCreateInput, SectionUncheckedCreateInput>
  }

  /**
   * Section createMany
   */
  export type SectionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Sections.
     */
    data: SectionCreateManyInput | SectionCreateManyInput[]
  }

  /**
   * Section createManyAndReturn
   */
  export type SectionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Section
     */
    select?: SectionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Section
     */
    omit?: SectionOmit<ExtArgs> | null
    /**
     * The data used to create many Sections.
     */
    data: SectionCreateManyInput | SectionCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SectionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Section update
   */
  export type SectionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Section
     */
    select?: SectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Section
     */
    omit?: SectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SectionInclude<ExtArgs> | null
    /**
     * The data needed to update a Section.
     */
    data: XOR<SectionUpdateInput, SectionUncheckedUpdateInput>
    /**
     * Choose, which Section to update.
     */
    where: SectionWhereUniqueInput
  }

  /**
   * Section updateMany
   */
  export type SectionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Sections.
     */
    data: XOR<SectionUpdateManyMutationInput, SectionUncheckedUpdateManyInput>
    /**
     * Filter which Sections to update
     */
    where?: SectionWhereInput
    /**
     * Limit how many Sections to update.
     */
    limit?: number
  }

  /**
   * Section updateManyAndReturn
   */
  export type SectionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Section
     */
    select?: SectionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Section
     */
    omit?: SectionOmit<ExtArgs> | null
    /**
     * The data used to update Sections.
     */
    data: XOR<SectionUpdateManyMutationInput, SectionUncheckedUpdateManyInput>
    /**
     * Filter which Sections to update
     */
    where?: SectionWhereInput
    /**
     * Limit how many Sections to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SectionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Section upsert
   */
  export type SectionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Section
     */
    select?: SectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Section
     */
    omit?: SectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SectionInclude<ExtArgs> | null
    /**
     * The filter to search for the Section to update in case it exists.
     */
    where: SectionWhereUniqueInput
    /**
     * In case the Section found by the `where` argument doesn't exist, create a new Section with this data.
     */
    create: XOR<SectionCreateInput, SectionUncheckedCreateInput>
    /**
     * In case the Section was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SectionUpdateInput, SectionUncheckedUpdateInput>
  }

  /**
   * Section delete
   */
  export type SectionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Section
     */
    select?: SectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Section
     */
    omit?: SectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SectionInclude<ExtArgs> | null
    /**
     * Filter which Section to delete.
     */
    where: SectionWhereUniqueInput
  }

  /**
   * Section deleteMany
   */
  export type SectionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sections to delete
     */
    where?: SectionWhereInput
    /**
     * Limit how many Sections to delete.
     */
    limit?: number
  }

  /**
   * Section.listItems
   */
  export type Section$listItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ListItem
     */
    select?: ListItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ListItem
     */
    omit?: ListItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ListItemInclude<ExtArgs> | null
    where?: ListItemWhereInput
    orderBy?: ListItemOrderByWithRelationInput | ListItemOrderByWithRelationInput[]
    cursor?: ListItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ListItemScalarFieldEnum | ListItemScalarFieldEnum[]
  }

  /**
   * Section without action
   */
  export type SectionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Section
     */
    select?: SectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Section
     */
    omit?: SectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SectionInclude<ExtArgs> | null
  }


  /**
   * Model ListItem
   */

  export type AggregateListItem = {
    _count: ListItemCountAggregateOutputType | null
    _min: ListItemMinAggregateOutputType | null
    _max: ListItemMaxAggregateOutputType | null
  }

  export type ListItemMinAggregateOutputType = {
    id: string | null
    sectionId: string | null
    type: $Enums.ListItemType | null
    title: string | null
    description: string | null
  }

  export type ListItemMaxAggregateOutputType = {
    id: string | null
    sectionId: string | null
    type: $Enums.ListItemType | null
    title: string | null
    description: string | null
  }

  export type ListItemCountAggregateOutputType = {
    id: number
    sectionId: number
    type: number
    title: number
    description: number
    _all: number
  }


  export type ListItemMinAggregateInputType = {
    id?: true
    sectionId?: true
    type?: true
    title?: true
    description?: true
  }

  export type ListItemMaxAggregateInputType = {
    id?: true
    sectionId?: true
    type?: true
    title?: true
    description?: true
  }

  export type ListItemCountAggregateInputType = {
    id?: true
    sectionId?: true
    type?: true
    title?: true
    description?: true
    _all?: true
  }

  export type ListItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ListItem to aggregate.
     */
    where?: ListItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ListItems to fetch.
     */
    orderBy?: ListItemOrderByWithRelationInput | ListItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ListItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ListItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ListItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ListItems
    **/
    _count?: true | ListItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ListItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ListItemMaxAggregateInputType
  }

  export type GetListItemAggregateType<T extends ListItemAggregateArgs> = {
        [P in keyof T & keyof AggregateListItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateListItem[P]>
      : GetScalarType<T[P], AggregateListItem[P]>
  }




  export type ListItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ListItemWhereInput
    orderBy?: ListItemOrderByWithAggregationInput | ListItemOrderByWithAggregationInput[]
    by: ListItemScalarFieldEnum[] | ListItemScalarFieldEnum
    having?: ListItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ListItemCountAggregateInputType | true
    _min?: ListItemMinAggregateInputType
    _max?: ListItemMaxAggregateInputType
  }

  export type ListItemGroupByOutputType = {
    id: string
    sectionId: string
    type: $Enums.ListItemType
    title: string
    description: string | null
    _count: ListItemCountAggregateOutputType | null
    _min: ListItemMinAggregateOutputType | null
    _max: ListItemMaxAggregateOutputType | null
  }

  type GetListItemGroupByPayload<T extends ListItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ListItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ListItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ListItemGroupByOutputType[P]>
            : GetScalarType<T[P], ListItemGroupByOutputType[P]>
        }
      >
    >


  export type ListItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sectionId?: boolean
    type?: boolean
    title?: boolean
    description?: boolean
    section?: boolean | SectionDefaultArgs<ExtArgs>
    entries?: boolean | ListItem$entriesArgs<ExtArgs>
    _count?: boolean | ListItemCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["listItem"]>

  export type ListItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sectionId?: boolean
    type?: boolean
    title?: boolean
    description?: boolean
    section?: boolean | SectionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["listItem"]>

  export type ListItemSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sectionId?: boolean
    type?: boolean
    title?: boolean
    description?: boolean
    section?: boolean | SectionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["listItem"]>

  export type ListItemSelectScalar = {
    id?: boolean
    sectionId?: boolean
    type?: boolean
    title?: boolean
    description?: boolean
  }

  export type ListItemOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "sectionId" | "type" | "title" | "description", ExtArgs["result"]["listItem"]>
  export type ListItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    section?: boolean | SectionDefaultArgs<ExtArgs>
    entries?: boolean | ListItem$entriesArgs<ExtArgs>
    _count?: boolean | ListItemCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ListItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    section?: boolean | SectionDefaultArgs<ExtArgs>
  }
  export type ListItemIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    section?: boolean | SectionDefaultArgs<ExtArgs>
  }

  export type $ListItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ListItem"
    objects: {
      section: Prisma.$SectionPayload<ExtArgs>
      entries: Prisma.$ListEntryPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      sectionId: string
      type: $Enums.ListItemType
      title: string
      description: string | null
    }, ExtArgs["result"]["listItem"]>
    composites: {}
  }

  type ListItemGetPayload<S extends boolean | null | undefined | ListItemDefaultArgs> = $Result.GetResult<Prisma.$ListItemPayload, S>

  type ListItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ListItemFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ListItemCountAggregateInputType | true
    }

  export interface ListItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ListItem'], meta: { name: 'ListItem' } }
    /**
     * Find zero or one ListItem that matches the filter.
     * @param {ListItemFindUniqueArgs} args - Arguments to find a ListItem
     * @example
     * // Get one ListItem
     * const listItem = await prisma.listItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ListItemFindUniqueArgs>(args: SelectSubset<T, ListItemFindUniqueArgs<ExtArgs>>): Prisma__ListItemClient<$Result.GetResult<Prisma.$ListItemPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ListItem that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ListItemFindUniqueOrThrowArgs} args - Arguments to find a ListItem
     * @example
     * // Get one ListItem
     * const listItem = await prisma.listItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ListItemFindUniqueOrThrowArgs>(args: SelectSubset<T, ListItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ListItemClient<$Result.GetResult<Prisma.$ListItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ListItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ListItemFindFirstArgs} args - Arguments to find a ListItem
     * @example
     * // Get one ListItem
     * const listItem = await prisma.listItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ListItemFindFirstArgs>(args?: SelectSubset<T, ListItemFindFirstArgs<ExtArgs>>): Prisma__ListItemClient<$Result.GetResult<Prisma.$ListItemPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ListItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ListItemFindFirstOrThrowArgs} args - Arguments to find a ListItem
     * @example
     * // Get one ListItem
     * const listItem = await prisma.listItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ListItemFindFirstOrThrowArgs>(args?: SelectSubset<T, ListItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__ListItemClient<$Result.GetResult<Prisma.$ListItemPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ListItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ListItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ListItems
     * const listItems = await prisma.listItem.findMany()
     * 
     * // Get first 10 ListItems
     * const listItems = await prisma.listItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const listItemWithIdOnly = await prisma.listItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ListItemFindManyArgs>(args?: SelectSubset<T, ListItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ListItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ListItem.
     * @param {ListItemCreateArgs} args - Arguments to create a ListItem.
     * @example
     * // Create one ListItem
     * const ListItem = await prisma.listItem.create({
     *   data: {
     *     // ... data to create a ListItem
     *   }
     * })
     * 
     */
    create<T extends ListItemCreateArgs>(args: SelectSubset<T, ListItemCreateArgs<ExtArgs>>): Prisma__ListItemClient<$Result.GetResult<Prisma.$ListItemPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ListItems.
     * @param {ListItemCreateManyArgs} args - Arguments to create many ListItems.
     * @example
     * // Create many ListItems
     * const listItem = await prisma.listItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ListItemCreateManyArgs>(args?: SelectSubset<T, ListItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ListItems and returns the data saved in the database.
     * @param {ListItemCreateManyAndReturnArgs} args - Arguments to create many ListItems.
     * @example
     * // Create many ListItems
     * const listItem = await prisma.listItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ListItems and only return the `id`
     * const listItemWithIdOnly = await prisma.listItem.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ListItemCreateManyAndReturnArgs>(args?: SelectSubset<T, ListItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ListItemPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ListItem.
     * @param {ListItemDeleteArgs} args - Arguments to delete one ListItem.
     * @example
     * // Delete one ListItem
     * const ListItem = await prisma.listItem.delete({
     *   where: {
     *     // ... filter to delete one ListItem
     *   }
     * })
     * 
     */
    delete<T extends ListItemDeleteArgs>(args: SelectSubset<T, ListItemDeleteArgs<ExtArgs>>): Prisma__ListItemClient<$Result.GetResult<Prisma.$ListItemPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ListItem.
     * @param {ListItemUpdateArgs} args - Arguments to update one ListItem.
     * @example
     * // Update one ListItem
     * const listItem = await prisma.listItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ListItemUpdateArgs>(args: SelectSubset<T, ListItemUpdateArgs<ExtArgs>>): Prisma__ListItemClient<$Result.GetResult<Prisma.$ListItemPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ListItems.
     * @param {ListItemDeleteManyArgs} args - Arguments to filter ListItems to delete.
     * @example
     * // Delete a few ListItems
     * const { count } = await prisma.listItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ListItemDeleteManyArgs>(args?: SelectSubset<T, ListItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ListItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ListItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ListItems
     * const listItem = await prisma.listItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ListItemUpdateManyArgs>(args: SelectSubset<T, ListItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ListItems and returns the data updated in the database.
     * @param {ListItemUpdateManyAndReturnArgs} args - Arguments to update many ListItems.
     * @example
     * // Update many ListItems
     * const listItem = await prisma.listItem.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ListItems and only return the `id`
     * const listItemWithIdOnly = await prisma.listItem.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ListItemUpdateManyAndReturnArgs>(args: SelectSubset<T, ListItemUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ListItemPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ListItem.
     * @param {ListItemUpsertArgs} args - Arguments to update or create a ListItem.
     * @example
     * // Update or create a ListItem
     * const listItem = await prisma.listItem.upsert({
     *   create: {
     *     // ... data to create a ListItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ListItem we want to update
     *   }
     * })
     */
    upsert<T extends ListItemUpsertArgs>(args: SelectSubset<T, ListItemUpsertArgs<ExtArgs>>): Prisma__ListItemClient<$Result.GetResult<Prisma.$ListItemPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ListItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ListItemCountArgs} args - Arguments to filter ListItems to count.
     * @example
     * // Count the number of ListItems
     * const count = await prisma.listItem.count({
     *   where: {
     *     // ... the filter for the ListItems we want to count
     *   }
     * })
    **/
    count<T extends ListItemCountArgs>(
      args?: Subset<T, ListItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ListItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ListItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ListItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ListItemAggregateArgs>(args: Subset<T, ListItemAggregateArgs>): Prisma.PrismaPromise<GetListItemAggregateType<T>>

    /**
     * Group by ListItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ListItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ListItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ListItemGroupByArgs['orderBy'] }
        : { orderBy?: ListItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ListItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetListItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ListItem model
   */
  readonly fields: ListItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ListItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ListItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    section<T extends SectionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SectionDefaultArgs<ExtArgs>>): Prisma__SectionClient<$Result.GetResult<Prisma.$SectionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    entries<T extends ListItem$entriesArgs<ExtArgs> = {}>(args?: Subset<T, ListItem$entriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ListEntryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ListItem model
   */
  interface ListItemFieldRefs {
    readonly id: FieldRef<"ListItem", 'String'>
    readonly sectionId: FieldRef<"ListItem", 'String'>
    readonly type: FieldRef<"ListItem", 'ListItemType'>
    readonly title: FieldRef<"ListItem", 'String'>
    readonly description: FieldRef<"ListItem", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ListItem findUnique
   */
  export type ListItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ListItem
     */
    select?: ListItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ListItem
     */
    omit?: ListItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ListItemInclude<ExtArgs> | null
    /**
     * Filter, which ListItem to fetch.
     */
    where: ListItemWhereUniqueInput
  }

  /**
   * ListItem findUniqueOrThrow
   */
  export type ListItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ListItem
     */
    select?: ListItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ListItem
     */
    omit?: ListItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ListItemInclude<ExtArgs> | null
    /**
     * Filter, which ListItem to fetch.
     */
    where: ListItemWhereUniqueInput
  }

  /**
   * ListItem findFirst
   */
  export type ListItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ListItem
     */
    select?: ListItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ListItem
     */
    omit?: ListItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ListItemInclude<ExtArgs> | null
    /**
     * Filter, which ListItem to fetch.
     */
    where?: ListItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ListItems to fetch.
     */
    orderBy?: ListItemOrderByWithRelationInput | ListItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ListItems.
     */
    cursor?: ListItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ListItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ListItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ListItems.
     */
    distinct?: ListItemScalarFieldEnum | ListItemScalarFieldEnum[]
  }

  /**
   * ListItem findFirstOrThrow
   */
  export type ListItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ListItem
     */
    select?: ListItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ListItem
     */
    omit?: ListItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ListItemInclude<ExtArgs> | null
    /**
     * Filter, which ListItem to fetch.
     */
    where?: ListItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ListItems to fetch.
     */
    orderBy?: ListItemOrderByWithRelationInput | ListItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ListItems.
     */
    cursor?: ListItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ListItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ListItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ListItems.
     */
    distinct?: ListItemScalarFieldEnum | ListItemScalarFieldEnum[]
  }

  /**
   * ListItem findMany
   */
  export type ListItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ListItem
     */
    select?: ListItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ListItem
     */
    omit?: ListItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ListItemInclude<ExtArgs> | null
    /**
     * Filter, which ListItems to fetch.
     */
    where?: ListItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ListItems to fetch.
     */
    orderBy?: ListItemOrderByWithRelationInput | ListItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ListItems.
     */
    cursor?: ListItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ListItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ListItems.
     */
    skip?: number
    distinct?: ListItemScalarFieldEnum | ListItemScalarFieldEnum[]
  }

  /**
   * ListItem create
   */
  export type ListItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ListItem
     */
    select?: ListItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ListItem
     */
    omit?: ListItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ListItemInclude<ExtArgs> | null
    /**
     * The data needed to create a ListItem.
     */
    data: XOR<ListItemCreateInput, ListItemUncheckedCreateInput>
  }

  /**
   * ListItem createMany
   */
  export type ListItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ListItems.
     */
    data: ListItemCreateManyInput | ListItemCreateManyInput[]
  }

  /**
   * ListItem createManyAndReturn
   */
  export type ListItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ListItem
     */
    select?: ListItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ListItem
     */
    omit?: ListItemOmit<ExtArgs> | null
    /**
     * The data used to create many ListItems.
     */
    data: ListItemCreateManyInput | ListItemCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ListItemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ListItem update
   */
  export type ListItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ListItem
     */
    select?: ListItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ListItem
     */
    omit?: ListItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ListItemInclude<ExtArgs> | null
    /**
     * The data needed to update a ListItem.
     */
    data: XOR<ListItemUpdateInput, ListItemUncheckedUpdateInput>
    /**
     * Choose, which ListItem to update.
     */
    where: ListItemWhereUniqueInput
  }

  /**
   * ListItem updateMany
   */
  export type ListItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ListItems.
     */
    data: XOR<ListItemUpdateManyMutationInput, ListItemUncheckedUpdateManyInput>
    /**
     * Filter which ListItems to update
     */
    where?: ListItemWhereInput
    /**
     * Limit how many ListItems to update.
     */
    limit?: number
  }

  /**
   * ListItem updateManyAndReturn
   */
  export type ListItemUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ListItem
     */
    select?: ListItemSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ListItem
     */
    omit?: ListItemOmit<ExtArgs> | null
    /**
     * The data used to update ListItems.
     */
    data: XOR<ListItemUpdateManyMutationInput, ListItemUncheckedUpdateManyInput>
    /**
     * Filter which ListItems to update
     */
    where?: ListItemWhereInput
    /**
     * Limit how many ListItems to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ListItemIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ListItem upsert
   */
  export type ListItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ListItem
     */
    select?: ListItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ListItem
     */
    omit?: ListItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ListItemInclude<ExtArgs> | null
    /**
     * The filter to search for the ListItem to update in case it exists.
     */
    where: ListItemWhereUniqueInput
    /**
     * In case the ListItem found by the `where` argument doesn't exist, create a new ListItem with this data.
     */
    create: XOR<ListItemCreateInput, ListItemUncheckedCreateInput>
    /**
     * In case the ListItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ListItemUpdateInput, ListItemUncheckedUpdateInput>
  }

  /**
   * ListItem delete
   */
  export type ListItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ListItem
     */
    select?: ListItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ListItem
     */
    omit?: ListItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ListItemInclude<ExtArgs> | null
    /**
     * Filter which ListItem to delete.
     */
    where: ListItemWhereUniqueInput
  }

  /**
   * ListItem deleteMany
   */
  export type ListItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ListItems to delete
     */
    where?: ListItemWhereInput
    /**
     * Limit how many ListItems to delete.
     */
    limit?: number
  }

  /**
   * ListItem.entries
   */
  export type ListItem$entriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ListEntry
     */
    select?: ListEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ListEntry
     */
    omit?: ListEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ListEntryInclude<ExtArgs> | null
    where?: ListEntryWhereInput
    orderBy?: ListEntryOrderByWithRelationInput | ListEntryOrderByWithRelationInput[]
    cursor?: ListEntryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ListEntryScalarFieldEnum | ListEntryScalarFieldEnum[]
  }

  /**
   * ListItem without action
   */
  export type ListItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ListItem
     */
    select?: ListItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ListItem
     */
    omit?: ListItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ListItemInclude<ExtArgs> | null
  }


  /**
   * Model ListEntry
   */

  export type AggregateListEntry = {
    _count: ListEntryCountAggregateOutputType | null
    _avg: ListEntryAvgAggregateOutputType | null
    _sum: ListEntrySumAggregateOutputType | null
    _min: ListEntryMinAggregateOutputType | null
    _max: ListEntryMaxAggregateOutputType | null
  }

  export type ListEntryAvgAggregateOutputType = {
    price: number | null
  }

  export type ListEntrySumAggregateOutputType = {
    price: number | null
  }

  export type ListEntryMinAggregateOutputType = {
    id: string | null
    listItemId: string | null
    title: string | null
    price: number | null
    description: string | null
    icon: string | null
    image: string | null
  }

  export type ListEntryMaxAggregateOutputType = {
    id: string | null
    listItemId: string | null
    title: string | null
    price: number | null
    description: string | null
    icon: string | null
    image: string | null
  }

  export type ListEntryCountAggregateOutputType = {
    id: number
    listItemId: number
    title: number
    price: number
    description: number
    icon: number
    image: number
    _all: number
  }


  export type ListEntryAvgAggregateInputType = {
    price?: true
  }

  export type ListEntrySumAggregateInputType = {
    price?: true
  }

  export type ListEntryMinAggregateInputType = {
    id?: true
    listItemId?: true
    title?: true
    price?: true
    description?: true
    icon?: true
    image?: true
  }

  export type ListEntryMaxAggregateInputType = {
    id?: true
    listItemId?: true
    title?: true
    price?: true
    description?: true
    icon?: true
    image?: true
  }

  export type ListEntryCountAggregateInputType = {
    id?: true
    listItemId?: true
    title?: true
    price?: true
    description?: true
    icon?: true
    image?: true
    _all?: true
  }

  export type ListEntryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ListEntry to aggregate.
     */
    where?: ListEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ListEntries to fetch.
     */
    orderBy?: ListEntryOrderByWithRelationInput | ListEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ListEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ListEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ListEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ListEntries
    **/
    _count?: true | ListEntryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ListEntryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ListEntrySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ListEntryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ListEntryMaxAggregateInputType
  }

  export type GetListEntryAggregateType<T extends ListEntryAggregateArgs> = {
        [P in keyof T & keyof AggregateListEntry]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateListEntry[P]>
      : GetScalarType<T[P], AggregateListEntry[P]>
  }




  export type ListEntryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ListEntryWhereInput
    orderBy?: ListEntryOrderByWithAggregationInput | ListEntryOrderByWithAggregationInput[]
    by: ListEntryScalarFieldEnum[] | ListEntryScalarFieldEnum
    having?: ListEntryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ListEntryCountAggregateInputType | true
    _avg?: ListEntryAvgAggregateInputType
    _sum?: ListEntrySumAggregateInputType
    _min?: ListEntryMinAggregateInputType
    _max?: ListEntryMaxAggregateInputType
  }

  export type ListEntryGroupByOutputType = {
    id: string
    listItemId: string
    title: string
    price: number | null
    description: string | null
    icon: string | null
    image: string | null
    _count: ListEntryCountAggregateOutputType | null
    _avg: ListEntryAvgAggregateOutputType | null
    _sum: ListEntrySumAggregateOutputType | null
    _min: ListEntryMinAggregateOutputType | null
    _max: ListEntryMaxAggregateOutputType | null
  }

  type GetListEntryGroupByPayload<T extends ListEntryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ListEntryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ListEntryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ListEntryGroupByOutputType[P]>
            : GetScalarType<T[P], ListEntryGroupByOutputType[P]>
        }
      >
    >


  export type ListEntrySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    listItemId?: boolean
    title?: boolean
    price?: boolean
    description?: boolean
    icon?: boolean
    image?: boolean
    listItem?: boolean | ListItemDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["listEntry"]>

  export type ListEntrySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    listItemId?: boolean
    title?: boolean
    price?: boolean
    description?: boolean
    icon?: boolean
    image?: boolean
    listItem?: boolean | ListItemDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["listEntry"]>

  export type ListEntrySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    listItemId?: boolean
    title?: boolean
    price?: boolean
    description?: boolean
    icon?: boolean
    image?: boolean
    listItem?: boolean | ListItemDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["listEntry"]>

  export type ListEntrySelectScalar = {
    id?: boolean
    listItemId?: boolean
    title?: boolean
    price?: boolean
    description?: boolean
    icon?: boolean
    image?: boolean
  }

  export type ListEntryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "listItemId" | "title" | "price" | "description" | "icon" | "image", ExtArgs["result"]["listEntry"]>
  export type ListEntryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    listItem?: boolean | ListItemDefaultArgs<ExtArgs>
  }
  export type ListEntryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    listItem?: boolean | ListItemDefaultArgs<ExtArgs>
  }
  export type ListEntryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    listItem?: boolean | ListItemDefaultArgs<ExtArgs>
  }

  export type $ListEntryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ListEntry"
    objects: {
      listItem: Prisma.$ListItemPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      listItemId: string
      title: string
      price: number | null
      description: string | null
      icon: string | null
      image: string | null
    }, ExtArgs["result"]["listEntry"]>
    composites: {}
  }

  type ListEntryGetPayload<S extends boolean | null | undefined | ListEntryDefaultArgs> = $Result.GetResult<Prisma.$ListEntryPayload, S>

  type ListEntryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ListEntryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ListEntryCountAggregateInputType | true
    }

  export interface ListEntryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ListEntry'], meta: { name: 'ListEntry' } }
    /**
     * Find zero or one ListEntry that matches the filter.
     * @param {ListEntryFindUniqueArgs} args - Arguments to find a ListEntry
     * @example
     * // Get one ListEntry
     * const listEntry = await prisma.listEntry.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ListEntryFindUniqueArgs>(args: SelectSubset<T, ListEntryFindUniqueArgs<ExtArgs>>): Prisma__ListEntryClient<$Result.GetResult<Prisma.$ListEntryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ListEntry that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ListEntryFindUniqueOrThrowArgs} args - Arguments to find a ListEntry
     * @example
     * // Get one ListEntry
     * const listEntry = await prisma.listEntry.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ListEntryFindUniqueOrThrowArgs>(args: SelectSubset<T, ListEntryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ListEntryClient<$Result.GetResult<Prisma.$ListEntryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ListEntry that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ListEntryFindFirstArgs} args - Arguments to find a ListEntry
     * @example
     * // Get one ListEntry
     * const listEntry = await prisma.listEntry.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ListEntryFindFirstArgs>(args?: SelectSubset<T, ListEntryFindFirstArgs<ExtArgs>>): Prisma__ListEntryClient<$Result.GetResult<Prisma.$ListEntryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ListEntry that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ListEntryFindFirstOrThrowArgs} args - Arguments to find a ListEntry
     * @example
     * // Get one ListEntry
     * const listEntry = await prisma.listEntry.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ListEntryFindFirstOrThrowArgs>(args?: SelectSubset<T, ListEntryFindFirstOrThrowArgs<ExtArgs>>): Prisma__ListEntryClient<$Result.GetResult<Prisma.$ListEntryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ListEntries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ListEntryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ListEntries
     * const listEntries = await prisma.listEntry.findMany()
     * 
     * // Get first 10 ListEntries
     * const listEntries = await prisma.listEntry.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const listEntryWithIdOnly = await prisma.listEntry.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ListEntryFindManyArgs>(args?: SelectSubset<T, ListEntryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ListEntryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ListEntry.
     * @param {ListEntryCreateArgs} args - Arguments to create a ListEntry.
     * @example
     * // Create one ListEntry
     * const ListEntry = await prisma.listEntry.create({
     *   data: {
     *     // ... data to create a ListEntry
     *   }
     * })
     * 
     */
    create<T extends ListEntryCreateArgs>(args: SelectSubset<T, ListEntryCreateArgs<ExtArgs>>): Prisma__ListEntryClient<$Result.GetResult<Prisma.$ListEntryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ListEntries.
     * @param {ListEntryCreateManyArgs} args - Arguments to create many ListEntries.
     * @example
     * // Create many ListEntries
     * const listEntry = await prisma.listEntry.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ListEntryCreateManyArgs>(args?: SelectSubset<T, ListEntryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ListEntries and returns the data saved in the database.
     * @param {ListEntryCreateManyAndReturnArgs} args - Arguments to create many ListEntries.
     * @example
     * // Create many ListEntries
     * const listEntry = await prisma.listEntry.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ListEntries and only return the `id`
     * const listEntryWithIdOnly = await prisma.listEntry.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ListEntryCreateManyAndReturnArgs>(args?: SelectSubset<T, ListEntryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ListEntryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ListEntry.
     * @param {ListEntryDeleteArgs} args - Arguments to delete one ListEntry.
     * @example
     * // Delete one ListEntry
     * const ListEntry = await prisma.listEntry.delete({
     *   where: {
     *     // ... filter to delete one ListEntry
     *   }
     * })
     * 
     */
    delete<T extends ListEntryDeleteArgs>(args: SelectSubset<T, ListEntryDeleteArgs<ExtArgs>>): Prisma__ListEntryClient<$Result.GetResult<Prisma.$ListEntryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ListEntry.
     * @param {ListEntryUpdateArgs} args - Arguments to update one ListEntry.
     * @example
     * // Update one ListEntry
     * const listEntry = await prisma.listEntry.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ListEntryUpdateArgs>(args: SelectSubset<T, ListEntryUpdateArgs<ExtArgs>>): Prisma__ListEntryClient<$Result.GetResult<Prisma.$ListEntryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ListEntries.
     * @param {ListEntryDeleteManyArgs} args - Arguments to filter ListEntries to delete.
     * @example
     * // Delete a few ListEntries
     * const { count } = await prisma.listEntry.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ListEntryDeleteManyArgs>(args?: SelectSubset<T, ListEntryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ListEntries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ListEntryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ListEntries
     * const listEntry = await prisma.listEntry.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ListEntryUpdateManyArgs>(args: SelectSubset<T, ListEntryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ListEntries and returns the data updated in the database.
     * @param {ListEntryUpdateManyAndReturnArgs} args - Arguments to update many ListEntries.
     * @example
     * // Update many ListEntries
     * const listEntry = await prisma.listEntry.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ListEntries and only return the `id`
     * const listEntryWithIdOnly = await prisma.listEntry.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ListEntryUpdateManyAndReturnArgs>(args: SelectSubset<T, ListEntryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ListEntryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ListEntry.
     * @param {ListEntryUpsertArgs} args - Arguments to update or create a ListEntry.
     * @example
     * // Update or create a ListEntry
     * const listEntry = await prisma.listEntry.upsert({
     *   create: {
     *     // ... data to create a ListEntry
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ListEntry we want to update
     *   }
     * })
     */
    upsert<T extends ListEntryUpsertArgs>(args: SelectSubset<T, ListEntryUpsertArgs<ExtArgs>>): Prisma__ListEntryClient<$Result.GetResult<Prisma.$ListEntryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ListEntries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ListEntryCountArgs} args - Arguments to filter ListEntries to count.
     * @example
     * // Count the number of ListEntries
     * const count = await prisma.listEntry.count({
     *   where: {
     *     // ... the filter for the ListEntries we want to count
     *   }
     * })
    **/
    count<T extends ListEntryCountArgs>(
      args?: Subset<T, ListEntryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ListEntryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ListEntry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ListEntryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ListEntryAggregateArgs>(args: Subset<T, ListEntryAggregateArgs>): Prisma.PrismaPromise<GetListEntryAggregateType<T>>

    /**
     * Group by ListEntry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ListEntryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ListEntryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ListEntryGroupByArgs['orderBy'] }
        : { orderBy?: ListEntryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ListEntryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetListEntryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ListEntry model
   */
  readonly fields: ListEntryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ListEntry.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ListEntryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    listItem<T extends ListItemDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ListItemDefaultArgs<ExtArgs>>): Prisma__ListItemClient<$Result.GetResult<Prisma.$ListItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ListEntry model
   */
  interface ListEntryFieldRefs {
    readonly id: FieldRef<"ListEntry", 'String'>
    readonly listItemId: FieldRef<"ListEntry", 'String'>
    readonly title: FieldRef<"ListEntry", 'String'>
    readonly price: FieldRef<"ListEntry", 'Int'>
    readonly description: FieldRef<"ListEntry", 'String'>
    readonly icon: FieldRef<"ListEntry", 'String'>
    readonly image: FieldRef<"ListEntry", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ListEntry findUnique
   */
  export type ListEntryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ListEntry
     */
    select?: ListEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ListEntry
     */
    omit?: ListEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ListEntryInclude<ExtArgs> | null
    /**
     * Filter, which ListEntry to fetch.
     */
    where: ListEntryWhereUniqueInput
  }

  /**
   * ListEntry findUniqueOrThrow
   */
  export type ListEntryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ListEntry
     */
    select?: ListEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ListEntry
     */
    omit?: ListEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ListEntryInclude<ExtArgs> | null
    /**
     * Filter, which ListEntry to fetch.
     */
    where: ListEntryWhereUniqueInput
  }

  /**
   * ListEntry findFirst
   */
  export type ListEntryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ListEntry
     */
    select?: ListEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ListEntry
     */
    omit?: ListEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ListEntryInclude<ExtArgs> | null
    /**
     * Filter, which ListEntry to fetch.
     */
    where?: ListEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ListEntries to fetch.
     */
    orderBy?: ListEntryOrderByWithRelationInput | ListEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ListEntries.
     */
    cursor?: ListEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ListEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ListEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ListEntries.
     */
    distinct?: ListEntryScalarFieldEnum | ListEntryScalarFieldEnum[]
  }

  /**
   * ListEntry findFirstOrThrow
   */
  export type ListEntryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ListEntry
     */
    select?: ListEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ListEntry
     */
    omit?: ListEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ListEntryInclude<ExtArgs> | null
    /**
     * Filter, which ListEntry to fetch.
     */
    where?: ListEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ListEntries to fetch.
     */
    orderBy?: ListEntryOrderByWithRelationInput | ListEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ListEntries.
     */
    cursor?: ListEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ListEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ListEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ListEntries.
     */
    distinct?: ListEntryScalarFieldEnum | ListEntryScalarFieldEnum[]
  }

  /**
   * ListEntry findMany
   */
  export type ListEntryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ListEntry
     */
    select?: ListEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ListEntry
     */
    omit?: ListEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ListEntryInclude<ExtArgs> | null
    /**
     * Filter, which ListEntries to fetch.
     */
    where?: ListEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ListEntries to fetch.
     */
    orderBy?: ListEntryOrderByWithRelationInput | ListEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ListEntries.
     */
    cursor?: ListEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ListEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ListEntries.
     */
    skip?: number
    distinct?: ListEntryScalarFieldEnum | ListEntryScalarFieldEnum[]
  }

  /**
   * ListEntry create
   */
  export type ListEntryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ListEntry
     */
    select?: ListEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ListEntry
     */
    omit?: ListEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ListEntryInclude<ExtArgs> | null
    /**
     * The data needed to create a ListEntry.
     */
    data: XOR<ListEntryCreateInput, ListEntryUncheckedCreateInput>
  }

  /**
   * ListEntry createMany
   */
  export type ListEntryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ListEntries.
     */
    data: ListEntryCreateManyInput | ListEntryCreateManyInput[]
  }

  /**
   * ListEntry createManyAndReturn
   */
  export type ListEntryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ListEntry
     */
    select?: ListEntrySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ListEntry
     */
    omit?: ListEntryOmit<ExtArgs> | null
    /**
     * The data used to create many ListEntries.
     */
    data: ListEntryCreateManyInput | ListEntryCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ListEntryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ListEntry update
   */
  export type ListEntryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ListEntry
     */
    select?: ListEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ListEntry
     */
    omit?: ListEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ListEntryInclude<ExtArgs> | null
    /**
     * The data needed to update a ListEntry.
     */
    data: XOR<ListEntryUpdateInput, ListEntryUncheckedUpdateInput>
    /**
     * Choose, which ListEntry to update.
     */
    where: ListEntryWhereUniqueInput
  }

  /**
   * ListEntry updateMany
   */
  export type ListEntryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ListEntries.
     */
    data: XOR<ListEntryUpdateManyMutationInput, ListEntryUncheckedUpdateManyInput>
    /**
     * Filter which ListEntries to update
     */
    where?: ListEntryWhereInput
    /**
     * Limit how many ListEntries to update.
     */
    limit?: number
  }

  /**
   * ListEntry updateManyAndReturn
   */
  export type ListEntryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ListEntry
     */
    select?: ListEntrySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ListEntry
     */
    omit?: ListEntryOmit<ExtArgs> | null
    /**
     * The data used to update ListEntries.
     */
    data: XOR<ListEntryUpdateManyMutationInput, ListEntryUncheckedUpdateManyInput>
    /**
     * Filter which ListEntries to update
     */
    where?: ListEntryWhereInput
    /**
     * Limit how many ListEntries to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ListEntryIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ListEntry upsert
   */
  export type ListEntryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ListEntry
     */
    select?: ListEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ListEntry
     */
    omit?: ListEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ListEntryInclude<ExtArgs> | null
    /**
     * The filter to search for the ListEntry to update in case it exists.
     */
    where: ListEntryWhereUniqueInput
    /**
     * In case the ListEntry found by the `where` argument doesn't exist, create a new ListEntry with this data.
     */
    create: XOR<ListEntryCreateInput, ListEntryUncheckedCreateInput>
    /**
     * In case the ListEntry was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ListEntryUpdateInput, ListEntryUncheckedUpdateInput>
  }

  /**
   * ListEntry delete
   */
  export type ListEntryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ListEntry
     */
    select?: ListEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ListEntry
     */
    omit?: ListEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ListEntryInclude<ExtArgs> | null
    /**
     * Filter which ListEntry to delete.
     */
    where: ListEntryWhereUniqueInput
  }

  /**
   * ListEntry deleteMany
   */
  export type ListEntryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ListEntries to delete
     */
    where?: ListEntryWhereInput
    /**
     * Limit how many ListEntries to delete.
     */
    limit?: number
  }

  /**
   * ListEntry without action
   */
  export type ListEntryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ListEntry
     */
    select?: ListEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ListEntry
     */
    omit?: ListEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ListEntryInclude<ExtArgs> | null
  }


  /**
   * Model Product
   */

  export type AggregateProduct = {
    _count: ProductCountAggregateOutputType | null
    _avg: ProductAvgAggregateOutputType | null
    _sum: ProductSumAggregateOutputType | null
    _min: ProductMinAggregateOutputType | null
    _max: ProductMaxAggregateOutputType | null
  }

  export type ProductAvgAggregateOutputType = {
    price: number | null
    proccessTime: number | null
    quality: number | null
  }

  export type ProductSumAggregateOutputType = {
    price: number | null
    proccessTime: number | null
    quality: number | null
  }

  export type ProductMinAggregateOutputType = {
    id: string | null
    sku: string | null
    name: string | null
    slug: string | null
    description: string | null
    bestFor: string | null
    image: string | null
    price: number | null
    proccessTime: number | null
    inStock: boolean | null
    status: $Enums.ProductStatus | null
    categoryId: string | null
    quality: number | null
    isBest: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProductMaxAggregateOutputType = {
    id: string | null
    sku: string | null
    name: string | null
    slug: string | null
    description: string | null
    bestFor: string | null
    image: string | null
    price: number | null
    proccessTime: number | null
    inStock: boolean | null
    status: $Enums.ProductStatus | null
    categoryId: string | null
    quality: number | null
    isBest: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProductCountAggregateOutputType = {
    id: number
    sku: number
    name: number
    slug: number
    description: number
    bestFor: number
    image: number
    price: number
    proccessTime: number
    inStock: number
    status: number
    categoryId: number
    keywords: number
    quality: number
    isBest: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ProductAvgAggregateInputType = {
    price?: true
    proccessTime?: true
    quality?: true
  }

  export type ProductSumAggregateInputType = {
    price?: true
    proccessTime?: true
    quality?: true
  }

  export type ProductMinAggregateInputType = {
    id?: true
    sku?: true
    name?: true
    slug?: true
    description?: true
    bestFor?: true
    image?: true
    price?: true
    proccessTime?: true
    inStock?: true
    status?: true
    categoryId?: true
    quality?: true
    isBest?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProductMaxAggregateInputType = {
    id?: true
    sku?: true
    name?: true
    slug?: true
    description?: true
    bestFor?: true
    image?: true
    price?: true
    proccessTime?: true
    inStock?: true
    status?: true
    categoryId?: true
    quality?: true
    isBest?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProductCountAggregateInputType = {
    id?: true
    sku?: true
    name?: true
    slug?: true
    description?: true
    bestFor?: true
    image?: true
    price?: true
    proccessTime?: true
    inStock?: true
    status?: true
    categoryId?: true
    keywords?: true
    quality?: true
    isBest?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ProductAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Product to aggregate.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Products
    **/
    _count?: true | ProductCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProductAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProductSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductMaxAggregateInputType
  }

  export type GetProductAggregateType<T extends ProductAggregateArgs> = {
        [P in keyof T & keyof AggregateProduct]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProduct[P]>
      : GetScalarType<T[P], AggregateProduct[P]>
  }




  export type ProductGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductWhereInput
    orderBy?: ProductOrderByWithAggregationInput | ProductOrderByWithAggregationInput[]
    by: ProductScalarFieldEnum[] | ProductScalarFieldEnum
    having?: ProductScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductCountAggregateInputType | true
    _avg?: ProductAvgAggregateInputType
    _sum?: ProductSumAggregateInputType
    _min?: ProductMinAggregateInputType
    _max?: ProductMaxAggregateInputType
  }

  export type ProductGroupByOutputType = {
    id: string
    sku: string
    name: string
    slug: string
    description: string | null
    bestFor: string | null
    image: string | null
    price: number
    proccessTime: number | null
    inStock: boolean
    status: $Enums.ProductStatus
    categoryId: string
    keywords: JsonValue | null
    quality: number
    isBest: boolean
    createdAt: Date
    updatedAt: Date
    _count: ProductCountAggregateOutputType | null
    _avg: ProductAvgAggregateOutputType | null
    _sum: ProductSumAggregateOutputType | null
    _min: ProductMinAggregateOutputType | null
    _max: ProductMaxAggregateOutputType | null
  }

  type GetProductGroupByPayload<T extends ProductGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductGroupByOutputType[P]>
            : GetScalarType<T[P], ProductGroupByOutputType[P]>
        }
      >
    >


  export type ProductSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sku?: boolean
    name?: boolean
    slug?: boolean
    description?: boolean
    bestFor?: boolean
    image?: boolean
    price?: boolean
    proccessTime?: boolean
    inStock?: boolean
    status?: boolean
    categoryId?: boolean
    keywords?: boolean
    quality?: boolean
    isBest?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    category?: boolean | CategoryDefaultArgs<ExtArgs>
    tags?: boolean | Product$tagsArgs<ExtArgs>
    gallery?: boolean | Product$galleryArgs<ExtArgs>
    benefits?: boolean | Product$benefitsArgs<ExtArgs>
    benefitPoints?: boolean | Product$benefitPointsArgs<ExtArgs>
    promotions?: boolean | Product$promotionsArgs<ExtArgs>
    vouchers?: boolean | Product$vouchersArgs<ExtArgs>
    orders?: boolean | Product$ordersArgs<ExtArgs>
    _count?: boolean | ProductCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["product"]>

  export type ProductSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sku?: boolean
    name?: boolean
    slug?: boolean
    description?: boolean
    bestFor?: boolean
    image?: boolean
    price?: boolean
    proccessTime?: boolean
    inStock?: boolean
    status?: boolean
    categoryId?: boolean
    keywords?: boolean
    quality?: boolean
    isBest?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    category?: boolean | CategoryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["product"]>

  export type ProductSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sku?: boolean
    name?: boolean
    slug?: boolean
    description?: boolean
    bestFor?: boolean
    image?: boolean
    price?: boolean
    proccessTime?: boolean
    inStock?: boolean
    status?: boolean
    categoryId?: boolean
    keywords?: boolean
    quality?: boolean
    isBest?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    category?: boolean | CategoryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["product"]>

  export type ProductSelectScalar = {
    id?: boolean
    sku?: boolean
    name?: boolean
    slug?: boolean
    description?: boolean
    bestFor?: boolean
    image?: boolean
    price?: boolean
    proccessTime?: boolean
    inStock?: boolean
    status?: boolean
    categoryId?: boolean
    keywords?: boolean
    quality?: boolean
    isBest?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ProductOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "sku" | "name" | "slug" | "description" | "bestFor" | "image" | "price" | "proccessTime" | "inStock" | "status" | "categoryId" | "keywords" | "quality" | "isBest" | "createdAt" | "updatedAt", ExtArgs["result"]["product"]>
  export type ProductInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    category?: boolean | CategoryDefaultArgs<ExtArgs>
    tags?: boolean | Product$tagsArgs<ExtArgs>
    gallery?: boolean | Product$galleryArgs<ExtArgs>
    benefits?: boolean | Product$benefitsArgs<ExtArgs>
    benefitPoints?: boolean | Product$benefitPointsArgs<ExtArgs>
    promotions?: boolean | Product$promotionsArgs<ExtArgs>
    vouchers?: boolean | Product$vouchersArgs<ExtArgs>
    orders?: boolean | Product$ordersArgs<ExtArgs>
    _count?: boolean | ProductCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ProductIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    category?: boolean | CategoryDefaultArgs<ExtArgs>
  }
  export type ProductIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    category?: boolean | CategoryDefaultArgs<ExtArgs>
  }

  export type $ProductPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Product"
    objects: {
      category: Prisma.$CategoryPayload<ExtArgs>
      tags: Prisma.$TagPayload<ExtArgs>[]
      gallery: Prisma.$ProductGalleryPayload<ExtArgs>[]
      benefits: Prisma.$ProductBenefitPayload<ExtArgs>[]
      benefitPoints: Prisma.$ProductBenefitPointPayload<ExtArgs>[]
      promotions: Prisma.$PromotionPayload<ExtArgs>[]
      vouchers: Prisma.$VoucherPayload<ExtArgs>[]
      orders: Prisma.$OrderPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      sku: string
      name: string
      slug: string
      description: string | null
      bestFor: string | null
      image: string | null
      price: number
      proccessTime: number | null
      inStock: boolean
      status: $Enums.ProductStatus
      categoryId: string
      keywords: Prisma.JsonValue | null
      quality: number
      isBest: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["product"]>
    composites: {}
  }

  type ProductGetPayload<S extends boolean | null | undefined | ProductDefaultArgs> = $Result.GetResult<Prisma.$ProductPayload, S>

  type ProductCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProductFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProductCountAggregateInputType | true
    }

  export interface ProductDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Product'], meta: { name: 'Product' } }
    /**
     * Find zero or one Product that matches the filter.
     * @param {ProductFindUniqueArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProductFindUniqueArgs>(args: SelectSubset<T, ProductFindUniqueArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Product that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProductFindUniqueOrThrowArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProductFindUniqueOrThrowArgs>(args: SelectSubset<T, ProductFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Product that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindFirstArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProductFindFirstArgs>(args?: SelectSubset<T, ProductFindFirstArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Product that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindFirstOrThrowArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProductFindFirstOrThrowArgs>(args?: SelectSubset<T, ProductFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Products that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Products
     * const products = await prisma.product.findMany()
     * 
     * // Get first 10 Products
     * const products = await prisma.product.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productWithIdOnly = await prisma.product.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProductFindManyArgs>(args?: SelectSubset<T, ProductFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Product.
     * @param {ProductCreateArgs} args - Arguments to create a Product.
     * @example
     * // Create one Product
     * const Product = await prisma.product.create({
     *   data: {
     *     // ... data to create a Product
     *   }
     * })
     * 
     */
    create<T extends ProductCreateArgs>(args: SelectSubset<T, ProductCreateArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Products.
     * @param {ProductCreateManyArgs} args - Arguments to create many Products.
     * @example
     * // Create many Products
     * const product = await prisma.product.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProductCreateManyArgs>(args?: SelectSubset<T, ProductCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Products and returns the data saved in the database.
     * @param {ProductCreateManyAndReturnArgs} args - Arguments to create many Products.
     * @example
     * // Create many Products
     * const product = await prisma.product.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Products and only return the `id`
     * const productWithIdOnly = await prisma.product.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProductCreateManyAndReturnArgs>(args?: SelectSubset<T, ProductCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Product.
     * @param {ProductDeleteArgs} args - Arguments to delete one Product.
     * @example
     * // Delete one Product
     * const Product = await prisma.product.delete({
     *   where: {
     *     // ... filter to delete one Product
     *   }
     * })
     * 
     */
    delete<T extends ProductDeleteArgs>(args: SelectSubset<T, ProductDeleteArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Product.
     * @param {ProductUpdateArgs} args - Arguments to update one Product.
     * @example
     * // Update one Product
     * const product = await prisma.product.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProductUpdateArgs>(args: SelectSubset<T, ProductUpdateArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Products.
     * @param {ProductDeleteManyArgs} args - Arguments to filter Products to delete.
     * @example
     * // Delete a few Products
     * const { count } = await prisma.product.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProductDeleteManyArgs>(args?: SelectSubset<T, ProductDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Products
     * const product = await prisma.product.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProductUpdateManyArgs>(args: SelectSubset<T, ProductUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Products and returns the data updated in the database.
     * @param {ProductUpdateManyAndReturnArgs} args - Arguments to update many Products.
     * @example
     * // Update many Products
     * const product = await prisma.product.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Products and only return the `id`
     * const productWithIdOnly = await prisma.product.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProductUpdateManyAndReturnArgs>(args: SelectSubset<T, ProductUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Product.
     * @param {ProductUpsertArgs} args - Arguments to update or create a Product.
     * @example
     * // Update or create a Product
     * const product = await prisma.product.upsert({
     *   create: {
     *     // ... data to create a Product
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Product we want to update
     *   }
     * })
     */
    upsert<T extends ProductUpsertArgs>(args: SelectSubset<T, ProductUpsertArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCountArgs} args - Arguments to filter Products to count.
     * @example
     * // Count the number of Products
     * const count = await prisma.product.count({
     *   where: {
     *     // ... the filter for the Products we want to count
     *   }
     * })
    **/
    count<T extends ProductCountArgs>(
      args?: Subset<T, ProductCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Product.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductAggregateArgs>(args: Subset<T, ProductAggregateArgs>): Prisma.PrismaPromise<GetProductAggregateType<T>>

    /**
     * Group by Product.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductGroupByArgs['orderBy'] }
        : { orderBy?: ProductGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Product model
   */
  readonly fields: ProductFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Product.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProductClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    category<T extends CategoryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CategoryDefaultArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    tags<T extends Product$tagsArgs<ExtArgs> = {}>(args?: Subset<T, Product$tagsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    gallery<T extends Product$galleryArgs<ExtArgs> = {}>(args?: Subset<T, Product$galleryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductGalleryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    benefits<T extends Product$benefitsArgs<ExtArgs> = {}>(args?: Subset<T, Product$benefitsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductBenefitPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    benefitPoints<T extends Product$benefitPointsArgs<ExtArgs> = {}>(args?: Subset<T, Product$benefitPointsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductBenefitPointPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    promotions<T extends Product$promotionsArgs<ExtArgs> = {}>(args?: Subset<T, Product$promotionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PromotionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    vouchers<T extends Product$vouchersArgs<ExtArgs> = {}>(args?: Subset<T, Product$vouchersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VoucherPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    orders<T extends Product$ordersArgs<ExtArgs> = {}>(args?: Subset<T, Product$ordersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Product model
   */
  interface ProductFieldRefs {
    readonly id: FieldRef<"Product", 'String'>
    readonly sku: FieldRef<"Product", 'String'>
    readonly name: FieldRef<"Product", 'String'>
    readonly slug: FieldRef<"Product", 'String'>
    readonly description: FieldRef<"Product", 'String'>
    readonly bestFor: FieldRef<"Product", 'String'>
    readonly image: FieldRef<"Product", 'String'>
    readonly price: FieldRef<"Product", 'Float'>
    readonly proccessTime: FieldRef<"Product", 'Int'>
    readonly inStock: FieldRef<"Product", 'Boolean'>
    readonly status: FieldRef<"Product", 'ProductStatus'>
    readonly categoryId: FieldRef<"Product", 'String'>
    readonly keywords: FieldRef<"Product", 'Json'>
    readonly quality: FieldRef<"Product", 'Int'>
    readonly isBest: FieldRef<"Product", 'Boolean'>
    readonly createdAt: FieldRef<"Product", 'DateTime'>
    readonly updatedAt: FieldRef<"Product", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Product findUnique
   */
  export type ProductFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product findUniqueOrThrow
   */
  export type ProductFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product findFirst
   */
  export type ProductFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Products.
     */
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Product findFirstOrThrow
   */
  export type ProductFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Products.
     */
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Product findMany
   */
  export type ProductFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Products to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Product create
   */
  export type ProductCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * The data needed to create a Product.
     */
    data: XOR<ProductCreateInput, ProductUncheckedCreateInput>
  }

  /**
   * Product createMany
   */
  export type ProductCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Products.
     */
    data: ProductCreateManyInput | ProductCreateManyInput[]
  }

  /**
   * Product createManyAndReturn
   */
  export type ProductCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * The data used to create many Products.
     */
    data: ProductCreateManyInput | ProductCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Product update
   */
  export type ProductUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * The data needed to update a Product.
     */
    data: XOR<ProductUpdateInput, ProductUncheckedUpdateInput>
    /**
     * Choose, which Product to update.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product updateMany
   */
  export type ProductUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Products.
     */
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyInput>
    /**
     * Filter which Products to update
     */
    where?: ProductWhereInput
    /**
     * Limit how many Products to update.
     */
    limit?: number
  }

  /**
   * Product updateManyAndReturn
   */
  export type ProductUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * The data used to update Products.
     */
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyInput>
    /**
     * Filter which Products to update
     */
    where?: ProductWhereInput
    /**
     * Limit how many Products to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Product upsert
   */
  export type ProductUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * The filter to search for the Product to update in case it exists.
     */
    where: ProductWhereUniqueInput
    /**
     * In case the Product found by the `where` argument doesn't exist, create a new Product with this data.
     */
    create: XOR<ProductCreateInput, ProductUncheckedCreateInput>
    /**
     * In case the Product was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductUpdateInput, ProductUncheckedUpdateInput>
  }

  /**
   * Product delete
   */
  export type ProductDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter which Product to delete.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product deleteMany
   */
  export type ProductDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Products to delete
     */
    where?: ProductWhereInput
    /**
     * Limit how many Products to delete.
     */
    limit?: number
  }

  /**
   * Product.tags
   */
  export type Product$tagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    where?: TagWhereInput
    orderBy?: TagOrderByWithRelationInput | TagOrderByWithRelationInput[]
    cursor?: TagWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TagScalarFieldEnum | TagScalarFieldEnum[]
  }

  /**
   * Product.gallery
   */
  export type Product$galleryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductGallery
     */
    select?: ProductGallerySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductGallery
     */
    omit?: ProductGalleryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductGalleryInclude<ExtArgs> | null
    where?: ProductGalleryWhereInput
    orderBy?: ProductGalleryOrderByWithRelationInput | ProductGalleryOrderByWithRelationInput[]
    cursor?: ProductGalleryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductGalleryScalarFieldEnum | ProductGalleryScalarFieldEnum[]
  }

  /**
   * Product.benefits
   */
  export type Product$benefitsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductBenefit
     */
    select?: ProductBenefitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductBenefit
     */
    omit?: ProductBenefitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductBenefitInclude<ExtArgs> | null
    where?: ProductBenefitWhereInput
    orderBy?: ProductBenefitOrderByWithRelationInput | ProductBenefitOrderByWithRelationInput[]
    cursor?: ProductBenefitWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductBenefitScalarFieldEnum | ProductBenefitScalarFieldEnum[]
  }

  /**
   * Product.benefitPoints
   */
  export type Product$benefitPointsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductBenefitPoint
     */
    select?: ProductBenefitPointSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductBenefitPoint
     */
    omit?: ProductBenefitPointOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductBenefitPointInclude<ExtArgs> | null
    where?: ProductBenefitPointWhereInput
    orderBy?: ProductBenefitPointOrderByWithRelationInput | ProductBenefitPointOrderByWithRelationInput[]
    cursor?: ProductBenefitPointWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductBenefitPointScalarFieldEnum | ProductBenefitPointScalarFieldEnum[]
  }

  /**
   * Product.promotions
   */
  export type Product$promotionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Promotion
     */
    select?: PromotionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Promotion
     */
    omit?: PromotionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromotionInclude<ExtArgs> | null
    where?: PromotionWhereInput
    orderBy?: PromotionOrderByWithRelationInput | PromotionOrderByWithRelationInput[]
    cursor?: PromotionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PromotionScalarFieldEnum | PromotionScalarFieldEnum[]
  }

  /**
   * Product.vouchers
   */
  export type Product$vouchersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Voucher
     */
    select?: VoucherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Voucher
     */
    omit?: VoucherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoucherInclude<ExtArgs> | null
    where?: VoucherWhereInput
    orderBy?: VoucherOrderByWithRelationInput | VoucherOrderByWithRelationInput[]
    cursor?: VoucherWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VoucherScalarFieldEnum | VoucherScalarFieldEnum[]
  }

  /**
   * Product.orders
   */
  export type Product$ordersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    where?: OrderWhereInput
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    cursor?: OrderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * Product without action
   */
  export type ProductDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
  }


  /**
   * Model Category
   */

  export type AggregateCategory = {
    _count: CategoryCountAggregateOutputType | null
    _min: CategoryMinAggregateOutputType | null
    _max: CategoryMaxAggregateOutputType | null
  }

  export type CategoryMinAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CategoryMaxAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CategoryCountAggregateOutputType = {
    id: number
    name: number
    slug: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CategoryMinAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CategoryMaxAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CategoryCountAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CategoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Category to aggregate.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Categories
    **/
    _count?: true | CategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CategoryMaxAggregateInputType
  }

  export type GetCategoryAggregateType<T extends CategoryAggregateArgs> = {
        [P in keyof T & keyof AggregateCategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCategory[P]>
      : GetScalarType<T[P], AggregateCategory[P]>
  }




  export type CategoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CategoryWhereInput
    orderBy?: CategoryOrderByWithAggregationInput | CategoryOrderByWithAggregationInput[]
    by: CategoryScalarFieldEnum[] | CategoryScalarFieldEnum
    having?: CategoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CategoryCountAggregateInputType | true
    _min?: CategoryMinAggregateInputType
    _max?: CategoryMaxAggregateInputType
  }

  export type CategoryGroupByOutputType = {
    id: string
    name: string
    slug: string
    createdAt: Date
    updatedAt: Date
    _count: CategoryCountAggregateOutputType | null
    _min: CategoryMinAggregateOutputType | null
    _max: CategoryMaxAggregateOutputType | null
  }

  type GetCategoryGroupByPayload<T extends CategoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CategoryGroupByOutputType[P]>
            : GetScalarType<T[P], CategoryGroupByOutputType[P]>
        }
      >
    >


  export type CategorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    products?: boolean | Category$productsArgs<ExtArgs>
    _count?: boolean | CategoryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["category"]>

  export type CategorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["category"]>

  export type CategorySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["category"]>

  export type CategorySelectScalar = {
    id?: boolean
    name?: boolean
    slug?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CategoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "slug" | "createdAt" | "updatedAt", ExtArgs["result"]["category"]>
  export type CategoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    products?: boolean | Category$productsArgs<ExtArgs>
    _count?: boolean | CategoryCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CategoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type CategoryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $CategoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Category"
    objects: {
      products: Prisma.$ProductPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      slug: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["category"]>
    composites: {}
  }

  type CategoryGetPayload<S extends boolean | null | undefined | CategoryDefaultArgs> = $Result.GetResult<Prisma.$CategoryPayload, S>

  type CategoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CategoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CategoryCountAggregateInputType | true
    }

  export interface CategoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Category'], meta: { name: 'Category' } }
    /**
     * Find zero or one Category that matches the filter.
     * @param {CategoryFindUniqueArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CategoryFindUniqueArgs>(args: SelectSubset<T, CategoryFindUniqueArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Category that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CategoryFindUniqueOrThrowArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CategoryFindUniqueOrThrowArgs>(args: SelectSubset<T, CategoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Category that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryFindFirstArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CategoryFindFirstArgs>(args?: SelectSubset<T, CategoryFindFirstArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Category that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryFindFirstOrThrowArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CategoryFindFirstOrThrowArgs>(args?: SelectSubset<T, CategoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Categories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Categories
     * const categories = await prisma.category.findMany()
     * 
     * // Get first 10 Categories
     * const categories = await prisma.category.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const categoryWithIdOnly = await prisma.category.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CategoryFindManyArgs>(args?: SelectSubset<T, CategoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Category.
     * @param {CategoryCreateArgs} args - Arguments to create a Category.
     * @example
     * // Create one Category
     * const Category = await prisma.category.create({
     *   data: {
     *     // ... data to create a Category
     *   }
     * })
     * 
     */
    create<T extends CategoryCreateArgs>(args: SelectSubset<T, CategoryCreateArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Categories.
     * @param {CategoryCreateManyArgs} args - Arguments to create many Categories.
     * @example
     * // Create many Categories
     * const category = await prisma.category.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CategoryCreateManyArgs>(args?: SelectSubset<T, CategoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Categories and returns the data saved in the database.
     * @param {CategoryCreateManyAndReturnArgs} args - Arguments to create many Categories.
     * @example
     * // Create many Categories
     * const category = await prisma.category.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Categories and only return the `id`
     * const categoryWithIdOnly = await prisma.category.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CategoryCreateManyAndReturnArgs>(args?: SelectSubset<T, CategoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Category.
     * @param {CategoryDeleteArgs} args - Arguments to delete one Category.
     * @example
     * // Delete one Category
     * const Category = await prisma.category.delete({
     *   where: {
     *     // ... filter to delete one Category
     *   }
     * })
     * 
     */
    delete<T extends CategoryDeleteArgs>(args: SelectSubset<T, CategoryDeleteArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Category.
     * @param {CategoryUpdateArgs} args - Arguments to update one Category.
     * @example
     * // Update one Category
     * const category = await prisma.category.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CategoryUpdateArgs>(args: SelectSubset<T, CategoryUpdateArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Categories.
     * @param {CategoryDeleteManyArgs} args - Arguments to filter Categories to delete.
     * @example
     * // Delete a few Categories
     * const { count } = await prisma.category.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CategoryDeleteManyArgs>(args?: SelectSubset<T, CategoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Categories
     * const category = await prisma.category.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CategoryUpdateManyArgs>(args: SelectSubset<T, CategoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Categories and returns the data updated in the database.
     * @param {CategoryUpdateManyAndReturnArgs} args - Arguments to update many Categories.
     * @example
     * // Update many Categories
     * const category = await prisma.category.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Categories and only return the `id`
     * const categoryWithIdOnly = await prisma.category.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CategoryUpdateManyAndReturnArgs>(args: SelectSubset<T, CategoryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Category.
     * @param {CategoryUpsertArgs} args - Arguments to update or create a Category.
     * @example
     * // Update or create a Category
     * const category = await prisma.category.upsert({
     *   create: {
     *     // ... data to create a Category
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Category we want to update
     *   }
     * })
     */
    upsert<T extends CategoryUpsertArgs>(args: SelectSubset<T, CategoryUpsertArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryCountArgs} args - Arguments to filter Categories to count.
     * @example
     * // Count the number of Categories
     * const count = await prisma.category.count({
     *   where: {
     *     // ... the filter for the Categories we want to count
     *   }
     * })
    **/
    count<T extends CategoryCountArgs>(
      args?: Subset<T, CategoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Category.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CategoryAggregateArgs>(args: Subset<T, CategoryAggregateArgs>): Prisma.PrismaPromise<GetCategoryAggregateType<T>>

    /**
     * Group by Category.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CategoryGroupByArgs['orderBy'] }
        : { orderBy?: CategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CategoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCategoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Category model
   */
  readonly fields: CategoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Category.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CategoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    products<T extends Category$productsArgs<ExtArgs> = {}>(args?: Subset<T, Category$productsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Category model
   */
  interface CategoryFieldRefs {
    readonly id: FieldRef<"Category", 'String'>
    readonly name: FieldRef<"Category", 'String'>
    readonly slug: FieldRef<"Category", 'String'>
    readonly createdAt: FieldRef<"Category", 'DateTime'>
    readonly updatedAt: FieldRef<"Category", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Category findUnique
   */
  export type CategoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category findUniqueOrThrow
   */
  export type CategoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category findFirst
   */
  export type CategoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Categories.
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Categories.
     */
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * Category findFirstOrThrow
   */
  export type CategoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Categories.
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Categories.
     */
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * Category findMany
   */
  export type CategoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Categories to fetch.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Categories.
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * Category create
   */
  export type CategoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * The data needed to create a Category.
     */
    data: XOR<CategoryCreateInput, CategoryUncheckedCreateInput>
  }

  /**
   * Category createMany
   */
  export type CategoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Categories.
     */
    data: CategoryCreateManyInput | CategoryCreateManyInput[]
  }

  /**
   * Category createManyAndReturn
   */
  export type CategoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * The data used to create many Categories.
     */
    data: CategoryCreateManyInput | CategoryCreateManyInput[]
  }

  /**
   * Category update
   */
  export type CategoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * The data needed to update a Category.
     */
    data: XOR<CategoryUpdateInput, CategoryUncheckedUpdateInput>
    /**
     * Choose, which Category to update.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category updateMany
   */
  export type CategoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Categories.
     */
    data: XOR<CategoryUpdateManyMutationInput, CategoryUncheckedUpdateManyInput>
    /**
     * Filter which Categories to update
     */
    where?: CategoryWhereInput
    /**
     * Limit how many Categories to update.
     */
    limit?: number
  }

  /**
   * Category updateManyAndReturn
   */
  export type CategoryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * The data used to update Categories.
     */
    data: XOR<CategoryUpdateManyMutationInput, CategoryUncheckedUpdateManyInput>
    /**
     * Filter which Categories to update
     */
    where?: CategoryWhereInput
    /**
     * Limit how many Categories to update.
     */
    limit?: number
  }

  /**
   * Category upsert
   */
  export type CategoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * The filter to search for the Category to update in case it exists.
     */
    where: CategoryWhereUniqueInput
    /**
     * In case the Category found by the `where` argument doesn't exist, create a new Category with this data.
     */
    create: XOR<CategoryCreateInput, CategoryUncheckedCreateInput>
    /**
     * In case the Category was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CategoryUpdateInput, CategoryUncheckedUpdateInput>
  }

  /**
   * Category delete
   */
  export type CategoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter which Category to delete.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category deleteMany
   */
  export type CategoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Categories to delete
     */
    where?: CategoryWhereInput
    /**
     * Limit how many Categories to delete.
     */
    limit?: number
  }

  /**
   * Category.products
   */
  export type Category$productsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    where?: ProductWhereInput
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    cursor?: ProductWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Category without action
   */
  export type CategoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
  }


  /**
   * Model Tag
   */

  export type AggregateTag = {
    _count: TagCountAggregateOutputType | null
    _min: TagMinAggregateOutputType | null
    _max: TagMaxAggregateOutputType | null
  }

  export type TagMinAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
  }

  export type TagMaxAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
  }

  export type TagCountAggregateOutputType = {
    id: number
    name: number
    slug: number
    _all: number
  }


  export type TagMinAggregateInputType = {
    id?: true
    name?: true
    slug?: true
  }

  export type TagMaxAggregateInputType = {
    id?: true
    name?: true
    slug?: true
  }

  export type TagCountAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    _all?: true
  }

  export type TagAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tag to aggregate.
     */
    where?: TagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tags to fetch.
     */
    orderBy?: TagOrderByWithRelationInput | TagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Tags
    **/
    _count?: true | TagCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TagMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TagMaxAggregateInputType
  }

  export type GetTagAggregateType<T extends TagAggregateArgs> = {
        [P in keyof T & keyof AggregateTag]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTag[P]>
      : GetScalarType<T[P], AggregateTag[P]>
  }




  export type TagGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TagWhereInput
    orderBy?: TagOrderByWithAggregationInput | TagOrderByWithAggregationInput[]
    by: TagScalarFieldEnum[] | TagScalarFieldEnum
    having?: TagScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TagCountAggregateInputType | true
    _min?: TagMinAggregateInputType
    _max?: TagMaxAggregateInputType
  }

  export type TagGroupByOutputType = {
    id: string
    name: string
    slug: string
    _count: TagCountAggregateOutputType | null
    _min: TagMinAggregateOutputType | null
    _max: TagMaxAggregateOutputType | null
  }

  type GetTagGroupByPayload<T extends TagGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TagGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TagGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TagGroupByOutputType[P]>
            : GetScalarType<T[P], TagGroupByOutputType[P]>
        }
      >
    >


  export type TagSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    products?: boolean | Tag$productsArgs<ExtArgs>
    _count?: boolean | TagCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tag"]>

  export type TagSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
  }, ExtArgs["result"]["tag"]>

  export type TagSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
  }, ExtArgs["result"]["tag"]>

  export type TagSelectScalar = {
    id?: boolean
    name?: boolean
    slug?: boolean
  }

  export type TagOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "slug", ExtArgs["result"]["tag"]>
  export type TagInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    products?: boolean | Tag$productsArgs<ExtArgs>
    _count?: boolean | TagCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TagIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type TagIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $TagPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Tag"
    objects: {
      products: Prisma.$ProductPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      slug: string
    }, ExtArgs["result"]["tag"]>
    composites: {}
  }

  type TagGetPayload<S extends boolean | null | undefined | TagDefaultArgs> = $Result.GetResult<Prisma.$TagPayload, S>

  type TagCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TagFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TagCountAggregateInputType | true
    }

  export interface TagDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Tag'], meta: { name: 'Tag' } }
    /**
     * Find zero or one Tag that matches the filter.
     * @param {TagFindUniqueArgs} args - Arguments to find a Tag
     * @example
     * // Get one Tag
     * const tag = await prisma.tag.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TagFindUniqueArgs>(args: SelectSubset<T, TagFindUniqueArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Tag that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TagFindUniqueOrThrowArgs} args - Arguments to find a Tag
     * @example
     * // Get one Tag
     * const tag = await prisma.tag.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TagFindUniqueOrThrowArgs>(args: SelectSubset<T, TagFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tag that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagFindFirstArgs} args - Arguments to find a Tag
     * @example
     * // Get one Tag
     * const tag = await prisma.tag.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TagFindFirstArgs>(args?: SelectSubset<T, TagFindFirstArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tag that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagFindFirstOrThrowArgs} args - Arguments to find a Tag
     * @example
     * // Get one Tag
     * const tag = await prisma.tag.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TagFindFirstOrThrowArgs>(args?: SelectSubset<T, TagFindFirstOrThrowArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Tags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tags
     * const tags = await prisma.tag.findMany()
     * 
     * // Get first 10 Tags
     * const tags = await prisma.tag.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tagWithIdOnly = await prisma.tag.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TagFindManyArgs>(args?: SelectSubset<T, TagFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Tag.
     * @param {TagCreateArgs} args - Arguments to create a Tag.
     * @example
     * // Create one Tag
     * const Tag = await prisma.tag.create({
     *   data: {
     *     // ... data to create a Tag
     *   }
     * })
     * 
     */
    create<T extends TagCreateArgs>(args: SelectSubset<T, TagCreateArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Tags.
     * @param {TagCreateManyArgs} args - Arguments to create many Tags.
     * @example
     * // Create many Tags
     * const tag = await prisma.tag.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TagCreateManyArgs>(args?: SelectSubset<T, TagCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Tags and returns the data saved in the database.
     * @param {TagCreateManyAndReturnArgs} args - Arguments to create many Tags.
     * @example
     * // Create many Tags
     * const tag = await prisma.tag.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Tags and only return the `id`
     * const tagWithIdOnly = await prisma.tag.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TagCreateManyAndReturnArgs>(args?: SelectSubset<T, TagCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Tag.
     * @param {TagDeleteArgs} args - Arguments to delete one Tag.
     * @example
     * // Delete one Tag
     * const Tag = await prisma.tag.delete({
     *   where: {
     *     // ... filter to delete one Tag
     *   }
     * })
     * 
     */
    delete<T extends TagDeleteArgs>(args: SelectSubset<T, TagDeleteArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Tag.
     * @param {TagUpdateArgs} args - Arguments to update one Tag.
     * @example
     * // Update one Tag
     * const tag = await prisma.tag.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TagUpdateArgs>(args: SelectSubset<T, TagUpdateArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Tags.
     * @param {TagDeleteManyArgs} args - Arguments to filter Tags to delete.
     * @example
     * // Delete a few Tags
     * const { count } = await prisma.tag.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TagDeleteManyArgs>(args?: SelectSubset<T, TagDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tags
     * const tag = await prisma.tag.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TagUpdateManyArgs>(args: SelectSubset<T, TagUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tags and returns the data updated in the database.
     * @param {TagUpdateManyAndReturnArgs} args - Arguments to update many Tags.
     * @example
     * // Update many Tags
     * const tag = await prisma.tag.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Tags and only return the `id`
     * const tagWithIdOnly = await prisma.tag.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TagUpdateManyAndReturnArgs>(args: SelectSubset<T, TagUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Tag.
     * @param {TagUpsertArgs} args - Arguments to update or create a Tag.
     * @example
     * // Update or create a Tag
     * const tag = await prisma.tag.upsert({
     *   create: {
     *     // ... data to create a Tag
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tag we want to update
     *   }
     * })
     */
    upsert<T extends TagUpsertArgs>(args: SelectSubset<T, TagUpsertArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Tags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagCountArgs} args - Arguments to filter Tags to count.
     * @example
     * // Count the number of Tags
     * const count = await prisma.tag.count({
     *   where: {
     *     // ... the filter for the Tags we want to count
     *   }
     * })
    **/
    count<T extends TagCountArgs>(
      args?: Subset<T, TagCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TagCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TagAggregateArgs>(args: Subset<T, TagAggregateArgs>): Prisma.PrismaPromise<GetTagAggregateType<T>>

    /**
     * Group by Tag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TagGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TagGroupByArgs['orderBy'] }
        : { orderBy?: TagGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TagGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTagGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Tag model
   */
  readonly fields: TagFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Tag.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TagClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    products<T extends Tag$productsArgs<ExtArgs> = {}>(args?: Subset<T, Tag$productsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Tag model
   */
  interface TagFieldRefs {
    readonly id: FieldRef<"Tag", 'String'>
    readonly name: FieldRef<"Tag", 'String'>
    readonly slug: FieldRef<"Tag", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Tag findUnique
   */
  export type TagFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter, which Tag to fetch.
     */
    where: TagWhereUniqueInput
  }

  /**
   * Tag findUniqueOrThrow
   */
  export type TagFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter, which Tag to fetch.
     */
    where: TagWhereUniqueInput
  }

  /**
   * Tag findFirst
   */
  export type TagFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter, which Tag to fetch.
     */
    where?: TagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tags to fetch.
     */
    orderBy?: TagOrderByWithRelationInput | TagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tags.
     */
    cursor?: TagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tags.
     */
    distinct?: TagScalarFieldEnum | TagScalarFieldEnum[]
  }

  /**
   * Tag findFirstOrThrow
   */
  export type TagFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter, which Tag to fetch.
     */
    where?: TagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tags to fetch.
     */
    orderBy?: TagOrderByWithRelationInput | TagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tags.
     */
    cursor?: TagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tags.
     */
    distinct?: TagScalarFieldEnum | TagScalarFieldEnum[]
  }

  /**
   * Tag findMany
   */
  export type TagFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter, which Tags to fetch.
     */
    where?: TagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tags to fetch.
     */
    orderBy?: TagOrderByWithRelationInput | TagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Tags.
     */
    cursor?: TagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tags.
     */
    skip?: number
    distinct?: TagScalarFieldEnum | TagScalarFieldEnum[]
  }

  /**
   * Tag create
   */
  export type TagCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * The data needed to create a Tag.
     */
    data: XOR<TagCreateInput, TagUncheckedCreateInput>
  }

  /**
   * Tag createMany
   */
  export type TagCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Tags.
     */
    data: TagCreateManyInput | TagCreateManyInput[]
  }

  /**
   * Tag createManyAndReturn
   */
  export type TagCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * The data used to create many Tags.
     */
    data: TagCreateManyInput | TagCreateManyInput[]
  }

  /**
   * Tag update
   */
  export type TagUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * The data needed to update a Tag.
     */
    data: XOR<TagUpdateInput, TagUncheckedUpdateInput>
    /**
     * Choose, which Tag to update.
     */
    where: TagWhereUniqueInput
  }

  /**
   * Tag updateMany
   */
  export type TagUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Tags.
     */
    data: XOR<TagUpdateManyMutationInput, TagUncheckedUpdateManyInput>
    /**
     * Filter which Tags to update
     */
    where?: TagWhereInput
    /**
     * Limit how many Tags to update.
     */
    limit?: number
  }

  /**
   * Tag updateManyAndReturn
   */
  export type TagUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * The data used to update Tags.
     */
    data: XOR<TagUpdateManyMutationInput, TagUncheckedUpdateManyInput>
    /**
     * Filter which Tags to update
     */
    where?: TagWhereInput
    /**
     * Limit how many Tags to update.
     */
    limit?: number
  }

  /**
   * Tag upsert
   */
  export type TagUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * The filter to search for the Tag to update in case it exists.
     */
    where: TagWhereUniqueInput
    /**
     * In case the Tag found by the `where` argument doesn't exist, create a new Tag with this data.
     */
    create: XOR<TagCreateInput, TagUncheckedCreateInput>
    /**
     * In case the Tag was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TagUpdateInput, TagUncheckedUpdateInput>
  }

  /**
   * Tag delete
   */
  export type TagDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter which Tag to delete.
     */
    where: TagWhereUniqueInput
  }

  /**
   * Tag deleteMany
   */
  export type TagDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tags to delete
     */
    where?: TagWhereInput
    /**
     * Limit how many Tags to delete.
     */
    limit?: number
  }

  /**
   * Tag.products
   */
  export type Tag$productsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    where?: ProductWhereInput
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    cursor?: ProductWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Tag without action
   */
  export type TagDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
  }


  /**
   * Model ProductGallery
   */

  export type AggregateProductGallery = {
    _count: ProductGalleryCountAggregateOutputType | null
    _avg: ProductGalleryAvgAggregateOutputType | null
    _sum: ProductGallerySumAggregateOutputType | null
    _min: ProductGalleryMinAggregateOutputType | null
    _max: ProductGalleryMaxAggregateOutputType | null
  }

  export type ProductGalleryAvgAggregateOutputType = {
    order: number | null
  }

  export type ProductGallerySumAggregateOutputType = {
    order: number | null
  }

  export type ProductGalleryMinAggregateOutputType = {
    id: string | null
    productId: string | null
    imageUrl: string | null
    order: number | null
    createdAt: Date | null
  }

  export type ProductGalleryMaxAggregateOutputType = {
    id: string | null
    productId: string | null
    imageUrl: string | null
    order: number | null
    createdAt: Date | null
  }

  export type ProductGalleryCountAggregateOutputType = {
    id: number
    productId: number
    imageUrl: number
    order: number
    createdAt: number
    _all: number
  }


  export type ProductGalleryAvgAggregateInputType = {
    order?: true
  }

  export type ProductGallerySumAggregateInputType = {
    order?: true
  }

  export type ProductGalleryMinAggregateInputType = {
    id?: true
    productId?: true
    imageUrl?: true
    order?: true
    createdAt?: true
  }

  export type ProductGalleryMaxAggregateInputType = {
    id?: true
    productId?: true
    imageUrl?: true
    order?: true
    createdAt?: true
  }

  export type ProductGalleryCountAggregateInputType = {
    id?: true
    productId?: true
    imageUrl?: true
    order?: true
    createdAt?: true
    _all?: true
  }

  export type ProductGalleryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductGallery to aggregate.
     */
    where?: ProductGalleryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductGalleries to fetch.
     */
    orderBy?: ProductGalleryOrderByWithRelationInput | ProductGalleryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductGalleryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductGalleries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductGalleries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProductGalleries
    **/
    _count?: true | ProductGalleryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProductGalleryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProductGallerySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductGalleryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductGalleryMaxAggregateInputType
  }

  export type GetProductGalleryAggregateType<T extends ProductGalleryAggregateArgs> = {
        [P in keyof T & keyof AggregateProductGallery]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProductGallery[P]>
      : GetScalarType<T[P], AggregateProductGallery[P]>
  }




  export type ProductGalleryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductGalleryWhereInput
    orderBy?: ProductGalleryOrderByWithAggregationInput | ProductGalleryOrderByWithAggregationInput[]
    by: ProductGalleryScalarFieldEnum[] | ProductGalleryScalarFieldEnum
    having?: ProductGalleryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductGalleryCountAggregateInputType | true
    _avg?: ProductGalleryAvgAggregateInputType
    _sum?: ProductGallerySumAggregateInputType
    _min?: ProductGalleryMinAggregateInputType
    _max?: ProductGalleryMaxAggregateInputType
  }

  export type ProductGalleryGroupByOutputType = {
    id: string
    productId: string
    imageUrl: string
    order: number
    createdAt: Date
    _count: ProductGalleryCountAggregateOutputType | null
    _avg: ProductGalleryAvgAggregateOutputType | null
    _sum: ProductGallerySumAggregateOutputType | null
    _min: ProductGalleryMinAggregateOutputType | null
    _max: ProductGalleryMaxAggregateOutputType | null
  }

  type GetProductGalleryGroupByPayload<T extends ProductGalleryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductGalleryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductGalleryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductGalleryGroupByOutputType[P]>
            : GetScalarType<T[P], ProductGalleryGroupByOutputType[P]>
        }
      >
    >


  export type ProductGallerySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productId?: boolean
    imageUrl?: boolean
    order?: boolean
    createdAt?: boolean
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productGallery"]>

  export type ProductGallerySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productId?: boolean
    imageUrl?: boolean
    order?: boolean
    createdAt?: boolean
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productGallery"]>

  export type ProductGallerySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productId?: boolean
    imageUrl?: boolean
    order?: boolean
    createdAt?: boolean
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productGallery"]>

  export type ProductGallerySelectScalar = {
    id?: boolean
    productId?: boolean
    imageUrl?: boolean
    order?: boolean
    createdAt?: boolean
  }

  export type ProductGalleryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "productId" | "imageUrl" | "order" | "createdAt", ExtArgs["result"]["productGallery"]>
  export type ProductGalleryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }
  export type ProductGalleryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }
  export type ProductGalleryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }

  export type $ProductGalleryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProductGallery"
    objects: {
      product: Prisma.$ProductPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      productId: string
      imageUrl: string
      order: number
      createdAt: Date
    }, ExtArgs["result"]["productGallery"]>
    composites: {}
  }

  type ProductGalleryGetPayload<S extends boolean | null | undefined | ProductGalleryDefaultArgs> = $Result.GetResult<Prisma.$ProductGalleryPayload, S>

  type ProductGalleryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProductGalleryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProductGalleryCountAggregateInputType | true
    }

  export interface ProductGalleryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProductGallery'], meta: { name: 'ProductGallery' } }
    /**
     * Find zero or one ProductGallery that matches the filter.
     * @param {ProductGalleryFindUniqueArgs} args - Arguments to find a ProductGallery
     * @example
     * // Get one ProductGallery
     * const productGallery = await prisma.productGallery.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProductGalleryFindUniqueArgs>(args: SelectSubset<T, ProductGalleryFindUniqueArgs<ExtArgs>>): Prisma__ProductGalleryClient<$Result.GetResult<Prisma.$ProductGalleryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ProductGallery that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProductGalleryFindUniqueOrThrowArgs} args - Arguments to find a ProductGallery
     * @example
     * // Get one ProductGallery
     * const productGallery = await prisma.productGallery.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProductGalleryFindUniqueOrThrowArgs>(args: SelectSubset<T, ProductGalleryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProductGalleryClient<$Result.GetResult<Prisma.$ProductGalleryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProductGallery that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductGalleryFindFirstArgs} args - Arguments to find a ProductGallery
     * @example
     * // Get one ProductGallery
     * const productGallery = await prisma.productGallery.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProductGalleryFindFirstArgs>(args?: SelectSubset<T, ProductGalleryFindFirstArgs<ExtArgs>>): Prisma__ProductGalleryClient<$Result.GetResult<Prisma.$ProductGalleryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProductGallery that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductGalleryFindFirstOrThrowArgs} args - Arguments to find a ProductGallery
     * @example
     * // Get one ProductGallery
     * const productGallery = await prisma.productGallery.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProductGalleryFindFirstOrThrowArgs>(args?: SelectSubset<T, ProductGalleryFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProductGalleryClient<$Result.GetResult<Prisma.$ProductGalleryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ProductGalleries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductGalleryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProductGalleries
     * const productGalleries = await prisma.productGallery.findMany()
     * 
     * // Get first 10 ProductGalleries
     * const productGalleries = await prisma.productGallery.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productGalleryWithIdOnly = await prisma.productGallery.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProductGalleryFindManyArgs>(args?: SelectSubset<T, ProductGalleryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductGalleryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ProductGallery.
     * @param {ProductGalleryCreateArgs} args - Arguments to create a ProductGallery.
     * @example
     * // Create one ProductGallery
     * const ProductGallery = await prisma.productGallery.create({
     *   data: {
     *     // ... data to create a ProductGallery
     *   }
     * })
     * 
     */
    create<T extends ProductGalleryCreateArgs>(args: SelectSubset<T, ProductGalleryCreateArgs<ExtArgs>>): Prisma__ProductGalleryClient<$Result.GetResult<Prisma.$ProductGalleryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ProductGalleries.
     * @param {ProductGalleryCreateManyArgs} args - Arguments to create many ProductGalleries.
     * @example
     * // Create many ProductGalleries
     * const productGallery = await prisma.productGallery.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProductGalleryCreateManyArgs>(args?: SelectSubset<T, ProductGalleryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProductGalleries and returns the data saved in the database.
     * @param {ProductGalleryCreateManyAndReturnArgs} args - Arguments to create many ProductGalleries.
     * @example
     * // Create many ProductGalleries
     * const productGallery = await prisma.productGallery.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProductGalleries and only return the `id`
     * const productGalleryWithIdOnly = await prisma.productGallery.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProductGalleryCreateManyAndReturnArgs>(args?: SelectSubset<T, ProductGalleryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductGalleryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ProductGallery.
     * @param {ProductGalleryDeleteArgs} args - Arguments to delete one ProductGallery.
     * @example
     * // Delete one ProductGallery
     * const ProductGallery = await prisma.productGallery.delete({
     *   where: {
     *     // ... filter to delete one ProductGallery
     *   }
     * })
     * 
     */
    delete<T extends ProductGalleryDeleteArgs>(args: SelectSubset<T, ProductGalleryDeleteArgs<ExtArgs>>): Prisma__ProductGalleryClient<$Result.GetResult<Prisma.$ProductGalleryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ProductGallery.
     * @param {ProductGalleryUpdateArgs} args - Arguments to update one ProductGallery.
     * @example
     * // Update one ProductGallery
     * const productGallery = await prisma.productGallery.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProductGalleryUpdateArgs>(args: SelectSubset<T, ProductGalleryUpdateArgs<ExtArgs>>): Prisma__ProductGalleryClient<$Result.GetResult<Prisma.$ProductGalleryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ProductGalleries.
     * @param {ProductGalleryDeleteManyArgs} args - Arguments to filter ProductGalleries to delete.
     * @example
     * // Delete a few ProductGalleries
     * const { count } = await prisma.productGallery.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProductGalleryDeleteManyArgs>(args?: SelectSubset<T, ProductGalleryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductGalleries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductGalleryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProductGalleries
     * const productGallery = await prisma.productGallery.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProductGalleryUpdateManyArgs>(args: SelectSubset<T, ProductGalleryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductGalleries and returns the data updated in the database.
     * @param {ProductGalleryUpdateManyAndReturnArgs} args - Arguments to update many ProductGalleries.
     * @example
     * // Update many ProductGalleries
     * const productGallery = await prisma.productGallery.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ProductGalleries and only return the `id`
     * const productGalleryWithIdOnly = await prisma.productGallery.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProductGalleryUpdateManyAndReturnArgs>(args: SelectSubset<T, ProductGalleryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductGalleryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ProductGallery.
     * @param {ProductGalleryUpsertArgs} args - Arguments to update or create a ProductGallery.
     * @example
     * // Update or create a ProductGallery
     * const productGallery = await prisma.productGallery.upsert({
     *   create: {
     *     // ... data to create a ProductGallery
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProductGallery we want to update
     *   }
     * })
     */
    upsert<T extends ProductGalleryUpsertArgs>(args: SelectSubset<T, ProductGalleryUpsertArgs<ExtArgs>>): Prisma__ProductGalleryClient<$Result.GetResult<Prisma.$ProductGalleryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ProductGalleries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductGalleryCountArgs} args - Arguments to filter ProductGalleries to count.
     * @example
     * // Count the number of ProductGalleries
     * const count = await prisma.productGallery.count({
     *   where: {
     *     // ... the filter for the ProductGalleries we want to count
     *   }
     * })
    **/
    count<T extends ProductGalleryCountArgs>(
      args?: Subset<T, ProductGalleryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductGalleryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProductGallery.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductGalleryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductGalleryAggregateArgs>(args: Subset<T, ProductGalleryAggregateArgs>): Prisma.PrismaPromise<GetProductGalleryAggregateType<T>>

    /**
     * Group by ProductGallery.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductGalleryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductGalleryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductGalleryGroupByArgs['orderBy'] }
        : { orderBy?: ProductGalleryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductGalleryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductGalleryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProductGallery model
   */
  readonly fields: ProductGalleryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProductGallery.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProductGalleryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    product<T extends ProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductDefaultArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProductGallery model
   */
  interface ProductGalleryFieldRefs {
    readonly id: FieldRef<"ProductGallery", 'String'>
    readonly productId: FieldRef<"ProductGallery", 'String'>
    readonly imageUrl: FieldRef<"ProductGallery", 'String'>
    readonly order: FieldRef<"ProductGallery", 'Int'>
    readonly createdAt: FieldRef<"ProductGallery", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ProductGallery findUnique
   */
  export type ProductGalleryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductGallery
     */
    select?: ProductGallerySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductGallery
     */
    omit?: ProductGalleryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductGalleryInclude<ExtArgs> | null
    /**
     * Filter, which ProductGallery to fetch.
     */
    where: ProductGalleryWhereUniqueInput
  }

  /**
   * ProductGallery findUniqueOrThrow
   */
  export type ProductGalleryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductGallery
     */
    select?: ProductGallerySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductGallery
     */
    omit?: ProductGalleryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductGalleryInclude<ExtArgs> | null
    /**
     * Filter, which ProductGallery to fetch.
     */
    where: ProductGalleryWhereUniqueInput
  }

  /**
   * ProductGallery findFirst
   */
  export type ProductGalleryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductGallery
     */
    select?: ProductGallerySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductGallery
     */
    omit?: ProductGalleryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductGalleryInclude<ExtArgs> | null
    /**
     * Filter, which ProductGallery to fetch.
     */
    where?: ProductGalleryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductGalleries to fetch.
     */
    orderBy?: ProductGalleryOrderByWithRelationInput | ProductGalleryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductGalleries.
     */
    cursor?: ProductGalleryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductGalleries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductGalleries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductGalleries.
     */
    distinct?: ProductGalleryScalarFieldEnum | ProductGalleryScalarFieldEnum[]
  }

  /**
   * ProductGallery findFirstOrThrow
   */
  export type ProductGalleryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductGallery
     */
    select?: ProductGallerySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductGallery
     */
    omit?: ProductGalleryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductGalleryInclude<ExtArgs> | null
    /**
     * Filter, which ProductGallery to fetch.
     */
    where?: ProductGalleryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductGalleries to fetch.
     */
    orderBy?: ProductGalleryOrderByWithRelationInput | ProductGalleryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductGalleries.
     */
    cursor?: ProductGalleryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductGalleries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductGalleries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductGalleries.
     */
    distinct?: ProductGalleryScalarFieldEnum | ProductGalleryScalarFieldEnum[]
  }

  /**
   * ProductGallery findMany
   */
  export type ProductGalleryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductGallery
     */
    select?: ProductGallerySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductGallery
     */
    omit?: ProductGalleryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductGalleryInclude<ExtArgs> | null
    /**
     * Filter, which ProductGalleries to fetch.
     */
    where?: ProductGalleryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductGalleries to fetch.
     */
    orderBy?: ProductGalleryOrderByWithRelationInput | ProductGalleryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProductGalleries.
     */
    cursor?: ProductGalleryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductGalleries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductGalleries.
     */
    skip?: number
    distinct?: ProductGalleryScalarFieldEnum | ProductGalleryScalarFieldEnum[]
  }

  /**
   * ProductGallery create
   */
  export type ProductGalleryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductGallery
     */
    select?: ProductGallerySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductGallery
     */
    omit?: ProductGalleryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductGalleryInclude<ExtArgs> | null
    /**
     * The data needed to create a ProductGallery.
     */
    data: XOR<ProductGalleryCreateInput, ProductGalleryUncheckedCreateInput>
  }

  /**
   * ProductGallery createMany
   */
  export type ProductGalleryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProductGalleries.
     */
    data: ProductGalleryCreateManyInput | ProductGalleryCreateManyInput[]
  }

  /**
   * ProductGallery createManyAndReturn
   */
  export type ProductGalleryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductGallery
     */
    select?: ProductGallerySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProductGallery
     */
    omit?: ProductGalleryOmit<ExtArgs> | null
    /**
     * The data used to create many ProductGalleries.
     */
    data: ProductGalleryCreateManyInput | ProductGalleryCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductGalleryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProductGallery update
   */
  export type ProductGalleryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductGallery
     */
    select?: ProductGallerySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductGallery
     */
    omit?: ProductGalleryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductGalleryInclude<ExtArgs> | null
    /**
     * The data needed to update a ProductGallery.
     */
    data: XOR<ProductGalleryUpdateInput, ProductGalleryUncheckedUpdateInput>
    /**
     * Choose, which ProductGallery to update.
     */
    where: ProductGalleryWhereUniqueInput
  }

  /**
   * ProductGallery updateMany
   */
  export type ProductGalleryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProductGalleries.
     */
    data: XOR<ProductGalleryUpdateManyMutationInput, ProductGalleryUncheckedUpdateManyInput>
    /**
     * Filter which ProductGalleries to update
     */
    where?: ProductGalleryWhereInput
    /**
     * Limit how many ProductGalleries to update.
     */
    limit?: number
  }

  /**
   * ProductGallery updateManyAndReturn
   */
  export type ProductGalleryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductGallery
     */
    select?: ProductGallerySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProductGallery
     */
    omit?: ProductGalleryOmit<ExtArgs> | null
    /**
     * The data used to update ProductGalleries.
     */
    data: XOR<ProductGalleryUpdateManyMutationInput, ProductGalleryUncheckedUpdateManyInput>
    /**
     * Filter which ProductGalleries to update
     */
    where?: ProductGalleryWhereInput
    /**
     * Limit how many ProductGalleries to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductGalleryIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProductGallery upsert
   */
  export type ProductGalleryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductGallery
     */
    select?: ProductGallerySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductGallery
     */
    omit?: ProductGalleryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductGalleryInclude<ExtArgs> | null
    /**
     * The filter to search for the ProductGallery to update in case it exists.
     */
    where: ProductGalleryWhereUniqueInput
    /**
     * In case the ProductGallery found by the `where` argument doesn't exist, create a new ProductGallery with this data.
     */
    create: XOR<ProductGalleryCreateInput, ProductGalleryUncheckedCreateInput>
    /**
     * In case the ProductGallery was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductGalleryUpdateInput, ProductGalleryUncheckedUpdateInput>
  }

  /**
   * ProductGallery delete
   */
  export type ProductGalleryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductGallery
     */
    select?: ProductGallerySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductGallery
     */
    omit?: ProductGalleryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductGalleryInclude<ExtArgs> | null
    /**
     * Filter which ProductGallery to delete.
     */
    where: ProductGalleryWhereUniqueInput
  }

  /**
   * ProductGallery deleteMany
   */
  export type ProductGalleryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductGalleries to delete
     */
    where?: ProductGalleryWhereInput
    /**
     * Limit how many ProductGalleries to delete.
     */
    limit?: number
  }

  /**
   * ProductGallery without action
   */
  export type ProductGalleryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductGallery
     */
    select?: ProductGallerySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductGallery
     */
    omit?: ProductGalleryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductGalleryInclude<ExtArgs> | null
  }


  /**
   * Model Benefit
   */

  export type AggregateBenefit = {
    _count: BenefitCountAggregateOutputType | null
    _min: BenefitMinAggregateOutputType | null
    _max: BenefitMaxAggregateOutputType | null
  }

  export type BenefitMinAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    icon: string | null
  }

  export type BenefitMaxAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    icon: string | null
  }

  export type BenefitCountAggregateOutputType = {
    id: number
    title: number
    description: number
    icon: number
    _all: number
  }


  export type BenefitMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    icon?: true
  }

  export type BenefitMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    icon?: true
  }

  export type BenefitCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    icon?: true
    _all?: true
  }

  export type BenefitAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Benefit to aggregate.
     */
    where?: BenefitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Benefits to fetch.
     */
    orderBy?: BenefitOrderByWithRelationInput | BenefitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BenefitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Benefits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Benefits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Benefits
    **/
    _count?: true | BenefitCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BenefitMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BenefitMaxAggregateInputType
  }

  export type GetBenefitAggregateType<T extends BenefitAggregateArgs> = {
        [P in keyof T & keyof AggregateBenefit]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBenefit[P]>
      : GetScalarType<T[P], AggregateBenefit[P]>
  }




  export type BenefitGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BenefitWhereInput
    orderBy?: BenefitOrderByWithAggregationInput | BenefitOrderByWithAggregationInput[]
    by: BenefitScalarFieldEnum[] | BenefitScalarFieldEnum
    having?: BenefitScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BenefitCountAggregateInputType | true
    _min?: BenefitMinAggregateInputType
    _max?: BenefitMaxAggregateInputType
  }

  export type BenefitGroupByOutputType = {
    id: string
    title: string
    description: string | null
    icon: string | null
    _count: BenefitCountAggregateOutputType | null
    _min: BenefitMinAggregateOutputType | null
    _max: BenefitMaxAggregateOutputType | null
  }

  type GetBenefitGroupByPayload<T extends BenefitGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BenefitGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BenefitGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BenefitGroupByOutputType[P]>
            : GetScalarType<T[P], BenefitGroupByOutputType[P]>
        }
      >
    >


  export type BenefitSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    icon?: boolean
    products?: boolean | Benefit$productsArgs<ExtArgs>
    _count?: boolean | BenefitCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["benefit"]>

  export type BenefitSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    icon?: boolean
  }, ExtArgs["result"]["benefit"]>

  export type BenefitSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    icon?: boolean
  }, ExtArgs["result"]["benefit"]>

  export type BenefitSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    icon?: boolean
  }

  export type BenefitOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "description" | "icon", ExtArgs["result"]["benefit"]>
  export type BenefitInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    products?: boolean | Benefit$productsArgs<ExtArgs>
    _count?: boolean | BenefitCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type BenefitIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type BenefitIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $BenefitPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Benefit"
    objects: {
      products: Prisma.$ProductBenefitPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      description: string | null
      icon: string | null
    }, ExtArgs["result"]["benefit"]>
    composites: {}
  }

  type BenefitGetPayload<S extends boolean | null | undefined | BenefitDefaultArgs> = $Result.GetResult<Prisma.$BenefitPayload, S>

  type BenefitCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BenefitFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BenefitCountAggregateInputType | true
    }

  export interface BenefitDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Benefit'], meta: { name: 'Benefit' } }
    /**
     * Find zero or one Benefit that matches the filter.
     * @param {BenefitFindUniqueArgs} args - Arguments to find a Benefit
     * @example
     * // Get one Benefit
     * const benefit = await prisma.benefit.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BenefitFindUniqueArgs>(args: SelectSubset<T, BenefitFindUniqueArgs<ExtArgs>>): Prisma__BenefitClient<$Result.GetResult<Prisma.$BenefitPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Benefit that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BenefitFindUniqueOrThrowArgs} args - Arguments to find a Benefit
     * @example
     * // Get one Benefit
     * const benefit = await prisma.benefit.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BenefitFindUniqueOrThrowArgs>(args: SelectSubset<T, BenefitFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BenefitClient<$Result.GetResult<Prisma.$BenefitPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Benefit that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BenefitFindFirstArgs} args - Arguments to find a Benefit
     * @example
     * // Get one Benefit
     * const benefit = await prisma.benefit.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BenefitFindFirstArgs>(args?: SelectSubset<T, BenefitFindFirstArgs<ExtArgs>>): Prisma__BenefitClient<$Result.GetResult<Prisma.$BenefitPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Benefit that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BenefitFindFirstOrThrowArgs} args - Arguments to find a Benefit
     * @example
     * // Get one Benefit
     * const benefit = await prisma.benefit.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BenefitFindFirstOrThrowArgs>(args?: SelectSubset<T, BenefitFindFirstOrThrowArgs<ExtArgs>>): Prisma__BenefitClient<$Result.GetResult<Prisma.$BenefitPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Benefits that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BenefitFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Benefits
     * const benefits = await prisma.benefit.findMany()
     * 
     * // Get first 10 Benefits
     * const benefits = await prisma.benefit.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const benefitWithIdOnly = await prisma.benefit.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BenefitFindManyArgs>(args?: SelectSubset<T, BenefitFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BenefitPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Benefit.
     * @param {BenefitCreateArgs} args - Arguments to create a Benefit.
     * @example
     * // Create one Benefit
     * const Benefit = await prisma.benefit.create({
     *   data: {
     *     // ... data to create a Benefit
     *   }
     * })
     * 
     */
    create<T extends BenefitCreateArgs>(args: SelectSubset<T, BenefitCreateArgs<ExtArgs>>): Prisma__BenefitClient<$Result.GetResult<Prisma.$BenefitPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Benefits.
     * @param {BenefitCreateManyArgs} args - Arguments to create many Benefits.
     * @example
     * // Create many Benefits
     * const benefit = await prisma.benefit.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BenefitCreateManyArgs>(args?: SelectSubset<T, BenefitCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Benefits and returns the data saved in the database.
     * @param {BenefitCreateManyAndReturnArgs} args - Arguments to create many Benefits.
     * @example
     * // Create many Benefits
     * const benefit = await prisma.benefit.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Benefits and only return the `id`
     * const benefitWithIdOnly = await prisma.benefit.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BenefitCreateManyAndReturnArgs>(args?: SelectSubset<T, BenefitCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BenefitPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Benefit.
     * @param {BenefitDeleteArgs} args - Arguments to delete one Benefit.
     * @example
     * // Delete one Benefit
     * const Benefit = await prisma.benefit.delete({
     *   where: {
     *     // ... filter to delete one Benefit
     *   }
     * })
     * 
     */
    delete<T extends BenefitDeleteArgs>(args: SelectSubset<T, BenefitDeleteArgs<ExtArgs>>): Prisma__BenefitClient<$Result.GetResult<Prisma.$BenefitPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Benefit.
     * @param {BenefitUpdateArgs} args - Arguments to update one Benefit.
     * @example
     * // Update one Benefit
     * const benefit = await prisma.benefit.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BenefitUpdateArgs>(args: SelectSubset<T, BenefitUpdateArgs<ExtArgs>>): Prisma__BenefitClient<$Result.GetResult<Prisma.$BenefitPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Benefits.
     * @param {BenefitDeleteManyArgs} args - Arguments to filter Benefits to delete.
     * @example
     * // Delete a few Benefits
     * const { count } = await prisma.benefit.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BenefitDeleteManyArgs>(args?: SelectSubset<T, BenefitDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Benefits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BenefitUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Benefits
     * const benefit = await prisma.benefit.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BenefitUpdateManyArgs>(args: SelectSubset<T, BenefitUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Benefits and returns the data updated in the database.
     * @param {BenefitUpdateManyAndReturnArgs} args - Arguments to update many Benefits.
     * @example
     * // Update many Benefits
     * const benefit = await prisma.benefit.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Benefits and only return the `id`
     * const benefitWithIdOnly = await prisma.benefit.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BenefitUpdateManyAndReturnArgs>(args: SelectSubset<T, BenefitUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BenefitPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Benefit.
     * @param {BenefitUpsertArgs} args - Arguments to update or create a Benefit.
     * @example
     * // Update or create a Benefit
     * const benefit = await prisma.benefit.upsert({
     *   create: {
     *     // ... data to create a Benefit
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Benefit we want to update
     *   }
     * })
     */
    upsert<T extends BenefitUpsertArgs>(args: SelectSubset<T, BenefitUpsertArgs<ExtArgs>>): Prisma__BenefitClient<$Result.GetResult<Prisma.$BenefitPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Benefits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BenefitCountArgs} args - Arguments to filter Benefits to count.
     * @example
     * // Count the number of Benefits
     * const count = await prisma.benefit.count({
     *   where: {
     *     // ... the filter for the Benefits we want to count
     *   }
     * })
    **/
    count<T extends BenefitCountArgs>(
      args?: Subset<T, BenefitCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BenefitCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Benefit.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BenefitAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BenefitAggregateArgs>(args: Subset<T, BenefitAggregateArgs>): Prisma.PrismaPromise<GetBenefitAggregateType<T>>

    /**
     * Group by Benefit.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BenefitGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BenefitGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BenefitGroupByArgs['orderBy'] }
        : { orderBy?: BenefitGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BenefitGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBenefitGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Benefit model
   */
  readonly fields: BenefitFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Benefit.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BenefitClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    products<T extends Benefit$productsArgs<ExtArgs> = {}>(args?: Subset<T, Benefit$productsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductBenefitPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Benefit model
   */
  interface BenefitFieldRefs {
    readonly id: FieldRef<"Benefit", 'String'>
    readonly title: FieldRef<"Benefit", 'String'>
    readonly description: FieldRef<"Benefit", 'String'>
    readonly icon: FieldRef<"Benefit", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Benefit findUnique
   */
  export type BenefitFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Benefit
     */
    select?: BenefitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Benefit
     */
    omit?: BenefitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BenefitInclude<ExtArgs> | null
    /**
     * Filter, which Benefit to fetch.
     */
    where: BenefitWhereUniqueInput
  }

  /**
   * Benefit findUniqueOrThrow
   */
  export type BenefitFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Benefit
     */
    select?: BenefitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Benefit
     */
    omit?: BenefitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BenefitInclude<ExtArgs> | null
    /**
     * Filter, which Benefit to fetch.
     */
    where: BenefitWhereUniqueInput
  }

  /**
   * Benefit findFirst
   */
  export type BenefitFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Benefit
     */
    select?: BenefitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Benefit
     */
    omit?: BenefitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BenefitInclude<ExtArgs> | null
    /**
     * Filter, which Benefit to fetch.
     */
    where?: BenefitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Benefits to fetch.
     */
    orderBy?: BenefitOrderByWithRelationInput | BenefitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Benefits.
     */
    cursor?: BenefitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Benefits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Benefits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Benefits.
     */
    distinct?: BenefitScalarFieldEnum | BenefitScalarFieldEnum[]
  }

  /**
   * Benefit findFirstOrThrow
   */
  export type BenefitFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Benefit
     */
    select?: BenefitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Benefit
     */
    omit?: BenefitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BenefitInclude<ExtArgs> | null
    /**
     * Filter, which Benefit to fetch.
     */
    where?: BenefitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Benefits to fetch.
     */
    orderBy?: BenefitOrderByWithRelationInput | BenefitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Benefits.
     */
    cursor?: BenefitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Benefits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Benefits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Benefits.
     */
    distinct?: BenefitScalarFieldEnum | BenefitScalarFieldEnum[]
  }

  /**
   * Benefit findMany
   */
  export type BenefitFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Benefit
     */
    select?: BenefitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Benefit
     */
    omit?: BenefitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BenefitInclude<ExtArgs> | null
    /**
     * Filter, which Benefits to fetch.
     */
    where?: BenefitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Benefits to fetch.
     */
    orderBy?: BenefitOrderByWithRelationInput | BenefitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Benefits.
     */
    cursor?: BenefitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Benefits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Benefits.
     */
    skip?: number
    distinct?: BenefitScalarFieldEnum | BenefitScalarFieldEnum[]
  }

  /**
   * Benefit create
   */
  export type BenefitCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Benefit
     */
    select?: BenefitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Benefit
     */
    omit?: BenefitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BenefitInclude<ExtArgs> | null
    /**
     * The data needed to create a Benefit.
     */
    data: XOR<BenefitCreateInput, BenefitUncheckedCreateInput>
  }

  /**
   * Benefit createMany
   */
  export type BenefitCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Benefits.
     */
    data: BenefitCreateManyInput | BenefitCreateManyInput[]
  }

  /**
   * Benefit createManyAndReturn
   */
  export type BenefitCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Benefit
     */
    select?: BenefitSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Benefit
     */
    omit?: BenefitOmit<ExtArgs> | null
    /**
     * The data used to create many Benefits.
     */
    data: BenefitCreateManyInput | BenefitCreateManyInput[]
  }

  /**
   * Benefit update
   */
  export type BenefitUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Benefit
     */
    select?: BenefitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Benefit
     */
    omit?: BenefitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BenefitInclude<ExtArgs> | null
    /**
     * The data needed to update a Benefit.
     */
    data: XOR<BenefitUpdateInput, BenefitUncheckedUpdateInput>
    /**
     * Choose, which Benefit to update.
     */
    where: BenefitWhereUniqueInput
  }

  /**
   * Benefit updateMany
   */
  export type BenefitUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Benefits.
     */
    data: XOR<BenefitUpdateManyMutationInput, BenefitUncheckedUpdateManyInput>
    /**
     * Filter which Benefits to update
     */
    where?: BenefitWhereInput
    /**
     * Limit how many Benefits to update.
     */
    limit?: number
  }

  /**
   * Benefit updateManyAndReturn
   */
  export type BenefitUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Benefit
     */
    select?: BenefitSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Benefit
     */
    omit?: BenefitOmit<ExtArgs> | null
    /**
     * The data used to update Benefits.
     */
    data: XOR<BenefitUpdateManyMutationInput, BenefitUncheckedUpdateManyInput>
    /**
     * Filter which Benefits to update
     */
    where?: BenefitWhereInput
    /**
     * Limit how many Benefits to update.
     */
    limit?: number
  }

  /**
   * Benefit upsert
   */
  export type BenefitUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Benefit
     */
    select?: BenefitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Benefit
     */
    omit?: BenefitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BenefitInclude<ExtArgs> | null
    /**
     * The filter to search for the Benefit to update in case it exists.
     */
    where: BenefitWhereUniqueInput
    /**
     * In case the Benefit found by the `where` argument doesn't exist, create a new Benefit with this data.
     */
    create: XOR<BenefitCreateInput, BenefitUncheckedCreateInput>
    /**
     * In case the Benefit was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BenefitUpdateInput, BenefitUncheckedUpdateInput>
  }

  /**
   * Benefit delete
   */
  export type BenefitDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Benefit
     */
    select?: BenefitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Benefit
     */
    omit?: BenefitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BenefitInclude<ExtArgs> | null
    /**
     * Filter which Benefit to delete.
     */
    where: BenefitWhereUniqueInput
  }

  /**
   * Benefit deleteMany
   */
  export type BenefitDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Benefits to delete
     */
    where?: BenefitWhereInput
    /**
     * Limit how many Benefits to delete.
     */
    limit?: number
  }

  /**
   * Benefit.products
   */
  export type Benefit$productsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductBenefit
     */
    select?: ProductBenefitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductBenefit
     */
    omit?: ProductBenefitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductBenefitInclude<ExtArgs> | null
    where?: ProductBenefitWhereInput
    orderBy?: ProductBenefitOrderByWithRelationInput | ProductBenefitOrderByWithRelationInput[]
    cursor?: ProductBenefitWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductBenefitScalarFieldEnum | ProductBenefitScalarFieldEnum[]
  }

  /**
   * Benefit without action
   */
  export type BenefitDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Benefit
     */
    select?: BenefitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Benefit
     */
    omit?: BenefitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BenefitInclude<ExtArgs> | null
  }


  /**
   * Model ProductBenefit
   */

  export type AggregateProductBenefit = {
    _count: ProductBenefitCountAggregateOutputType | null
    _avg: ProductBenefitAvgAggregateOutputType | null
    _sum: ProductBenefitSumAggregateOutputType | null
    _min: ProductBenefitMinAggregateOutputType | null
    _max: ProductBenefitMaxAggregateOutputType | null
  }

  export type ProductBenefitAvgAggregateOutputType = {
    order: number | null
  }

  export type ProductBenefitSumAggregateOutputType = {
    order: number | null
  }

  export type ProductBenefitMinAggregateOutputType = {
    id: string | null
    productId: string | null
    benefitId: string | null
    isActive: boolean | null
    order: number | null
  }

  export type ProductBenefitMaxAggregateOutputType = {
    id: string | null
    productId: string | null
    benefitId: string | null
    isActive: boolean | null
    order: number | null
  }

  export type ProductBenefitCountAggregateOutputType = {
    id: number
    productId: number
    benefitId: number
    isActive: number
    order: number
    _all: number
  }


  export type ProductBenefitAvgAggregateInputType = {
    order?: true
  }

  export type ProductBenefitSumAggregateInputType = {
    order?: true
  }

  export type ProductBenefitMinAggregateInputType = {
    id?: true
    productId?: true
    benefitId?: true
    isActive?: true
    order?: true
  }

  export type ProductBenefitMaxAggregateInputType = {
    id?: true
    productId?: true
    benefitId?: true
    isActive?: true
    order?: true
  }

  export type ProductBenefitCountAggregateInputType = {
    id?: true
    productId?: true
    benefitId?: true
    isActive?: true
    order?: true
    _all?: true
  }

  export type ProductBenefitAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductBenefit to aggregate.
     */
    where?: ProductBenefitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductBenefits to fetch.
     */
    orderBy?: ProductBenefitOrderByWithRelationInput | ProductBenefitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductBenefitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductBenefits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductBenefits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProductBenefits
    **/
    _count?: true | ProductBenefitCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProductBenefitAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProductBenefitSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductBenefitMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductBenefitMaxAggregateInputType
  }

  export type GetProductBenefitAggregateType<T extends ProductBenefitAggregateArgs> = {
        [P in keyof T & keyof AggregateProductBenefit]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProductBenefit[P]>
      : GetScalarType<T[P], AggregateProductBenefit[P]>
  }




  export type ProductBenefitGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductBenefitWhereInput
    orderBy?: ProductBenefitOrderByWithAggregationInput | ProductBenefitOrderByWithAggregationInput[]
    by: ProductBenefitScalarFieldEnum[] | ProductBenefitScalarFieldEnum
    having?: ProductBenefitScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductBenefitCountAggregateInputType | true
    _avg?: ProductBenefitAvgAggregateInputType
    _sum?: ProductBenefitSumAggregateInputType
    _min?: ProductBenefitMinAggregateInputType
    _max?: ProductBenefitMaxAggregateInputType
  }

  export type ProductBenefitGroupByOutputType = {
    id: string
    productId: string
    benefitId: string
    isActive: boolean
    order: number
    _count: ProductBenefitCountAggregateOutputType | null
    _avg: ProductBenefitAvgAggregateOutputType | null
    _sum: ProductBenefitSumAggregateOutputType | null
    _min: ProductBenefitMinAggregateOutputType | null
    _max: ProductBenefitMaxAggregateOutputType | null
  }

  type GetProductBenefitGroupByPayload<T extends ProductBenefitGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductBenefitGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductBenefitGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductBenefitGroupByOutputType[P]>
            : GetScalarType<T[P], ProductBenefitGroupByOutputType[P]>
        }
      >
    >


  export type ProductBenefitSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productId?: boolean
    benefitId?: boolean
    isActive?: boolean
    order?: boolean
    product?: boolean | ProductDefaultArgs<ExtArgs>
    benefit?: boolean | BenefitDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productBenefit"]>

  export type ProductBenefitSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productId?: boolean
    benefitId?: boolean
    isActive?: boolean
    order?: boolean
    product?: boolean | ProductDefaultArgs<ExtArgs>
    benefit?: boolean | BenefitDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productBenefit"]>

  export type ProductBenefitSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productId?: boolean
    benefitId?: boolean
    isActive?: boolean
    order?: boolean
    product?: boolean | ProductDefaultArgs<ExtArgs>
    benefit?: boolean | BenefitDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productBenefit"]>

  export type ProductBenefitSelectScalar = {
    id?: boolean
    productId?: boolean
    benefitId?: boolean
    isActive?: boolean
    order?: boolean
  }

  export type ProductBenefitOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "productId" | "benefitId" | "isActive" | "order", ExtArgs["result"]["productBenefit"]>
  export type ProductBenefitInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductDefaultArgs<ExtArgs>
    benefit?: boolean | BenefitDefaultArgs<ExtArgs>
  }
  export type ProductBenefitIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductDefaultArgs<ExtArgs>
    benefit?: boolean | BenefitDefaultArgs<ExtArgs>
  }
  export type ProductBenefitIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductDefaultArgs<ExtArgs>
    benefit?: boolean | BenefitDefaultArgs<ExtArgs>
  }

  export type $ProductBenefitPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProductBenefit"
    objects: {
      product: Prisma.$ProductPayload<ExtArgs>
      benefit: Prisma.$BenefitPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      productId: string
      benefitId: string
      isActive: boolean
      order: number
    }, ExtArgs["result"]["productBenefit"]>
    composites: {}
  }

  type ProductBenefitGetPayload<S extends boolean | null | undefined | ProductBenefitDefaultArgs> = $Result.GetResult<Prisma.$ProductBenefitPayload, S>

  type ProductBenefitCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProductBenefitFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProductBenefitCountAggregateInputType | true
    }

  export interface ProductBenefitDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProductBenefit'], meta: { name: 'ProductBenefit' } }
    /**
     * Find zero or one ProductBenefit that matches the filter.
     * @param {ProductBenefitFindUniqueArgs} args - Arguments to find a ProductBenefit
     * @example
     * // Get one ProductBenefit
     * const productBenefit = await prisma.productBenefit.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProductBenefitFindUniqueArgs>(args: SelectSubset<T, ProductBenefitFindUniqueArgs<ExtArgs>>): Prisma__ProductBenefitClient<$Result.GetResult<Prisma.$ProductBenefitPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ProductBenefit that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProductBenefitFindUniqueOrThrowArgs} args - Arguments to find a ProductBenefit
     * @example
     * // Get one ProductBenefit
     * const productBenefit = await prisma.productBenefit.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProductBenefitFindUniqueOrThrowArgs>(args: SelectSubset<T, ProductBenefitFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProductBenefitClient<$Result.GetResult<Prisma.$ProductBenefitPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProductBenefit that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductBenefitFindFirstArgs} args - Arguments to find a ProductBenefit
     * @example
     * // Get one ProductBenefit
     * const productBenefit = await prisma.productBenefit.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProductBenefitFindFirstArgs>(args?: SelectSubset<T, ProductBenefitFindFirstArgs<ExtArgs>>): Prisma__ProductBenefitClient<$Result.GetResult<Prisma.$ProductBenefitPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProductBenefit that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductBenefitFindFirstOrThrowArgs} args - Arguments to find a ProductBenefit
     * @example
     * // Get one ProductBenefit
     * const productBenefit = await prisma.productBenefit.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProductBenefitFindFirstOrThrowArgs>(args?: SelectSubset<T, ProductBenefitFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProductBenefitClient<$Result.GetResult<Prisma.$ProductBenefitPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ProductBenefits that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductBenefitFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProductBenefits
     * const productBenefits = await prisma.productBenefit.findMany()
     * 
     * // Get first 10 ProductBenefits
     * const productBenefits = await prisma.productBenefit.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productBenefitWithIdOnly = await prisma.productBenefit.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProductBenefitFindManyArgs>(args?: SelectSubset<T, ProductBenefitFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductBenefitPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ProductBenefit.
     * @param {ProductBenefitCreateArgs} args - Arguments to create a ProductBenefit.
     * @example
     * // Create one ProductBenefit
     * const ProductBenefit = await prisma.productBenefit.create({
     *   data: {
     *     // ... data to create a ProductBenefit
     *   }
     * })
     * 
     */
    create<T extends ProductBenefitCreateArgs>(args: SelectSubset<T, ProductBenefitCreateArgs<ExtArgs>>): Prisma__ProductBenefitClient<$Result.GetResult<Prisma.$ProductBenefitPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ProductBenefits.
     * @param {ProductBenefitCreateManyArgs} args - Arguments to create many ProductBenefits.
     * @example
     * // Create many ProductBenefits
     * const productBenefit = await prisma.productBenefit.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProductBenefitCreateManyArgs>(args?: SelectSubset<T, ProductBenefitCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProductBenefits and returns the data saved in the database.
     * @param {ProductBenefitCreateManyAndReturnArgs} args - Arguments to create many ProductBenefits.
     * @example
     * // Create many ProductBenefits
     * const productBenefit = await prisma.productBenefit.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProductBenefits and only return the `id`
     * const productBenefitWithIdOnly = await prisma.productBenefit.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProductBenefitCreateManyAndReturnArgs>(args?: SelectSubset<T, ProductBenefitCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductBenefitPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ProductBenefit.
     * @param {ProductBenefitDeleteArgs} args - Arguments to delete one ProductBenefit.
     * @example
     * // Delete one ProductBenefit
     * const ProductBenefit = await prisma.productBenefit.delete({
     *   where: {
     *     // ... filter to delete one ProductBenefit
     *   }
     * })
     * 
     */
    delete<T extends ProductBenefitDeleteArgs>(args: SelectSubset<T, ProductBenefitDeleteArgs<ExtArgs>>): Prisma__ProductBenefitClient<$Result.GetResult<Prisma.$ProductBenefitPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ProductBenefit.
     * @param {ProductBenefitUpdateArgs} args - Arguments to update one ProductBenefit.
     * @example
     * // Update one ProductBenefit
     * const productBenefit = await prisma.productBenefit.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProductBenefitUpdateArgs>(args: SelectSubset<T, ProductBenefitUpdateArgs<ExtArgs>>): Prisma__ProductBenefitClient<$Result.GetResult<Prisma.$ProductBenefitPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ProductBenefits.
     * @param {ProductBenefitDeleteManyArgs} args - Arguments to filter ProductBenefits to delete.
     * @example
     * // Delete a few ProductBenefits
     * const { count } = await prisma.productBenefit.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProductBenefitDeleteManyArgs>(args?: SelectSubset<T, ProductBenefitDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductBenefits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductBenefitUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProductBenefits
     * const productBenefit = await prisma.productBenefit.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProductBenefitUpdateManyArgs>(args: SelectSubset<T, ProductBenefitUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductBenefits and returns the data updated in the database.
     * @param {ProductBenefitUpdateManyAndReturnArgs} args - Arguments to update many ProductBenefits.
     * @example
     * // Update many ProductBenefits
     * const productBenefit = await prisma.productBenefit.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ProductBenefits and only return the `id`
     * const productBenefitWithIdOnly = await prisma.productBenefit.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProductBenefitUpdateManyAndReturnArgs>(args: SelectSubset<T, ProductBenefitUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductBenefitPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ProductBenefit.
     * @param {ProductBenefitUpsertArgs} args - Arguments to update or create a ProductBenefit.
     * @example
     * // Update or create a ProductBenefit
     * const productBenefit = await prisma.productBenefit.upsert({
     *   create: {
     *     // ... data to create a ProductBenefit
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProductBenefit we want to update
     *   }
     * })
     */
    upsert<T extends ProductBenefitUpsertArgs>(args: SelectSubset<T, ProductBenefitUpsertArgs<ExtArgs>>): Prisma__ProductBenefitClient<$Result.GetResult<Prisma.$ProductBenefitPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ProductBenefits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductBenefitCountArgs} args - Arguments to filter ProductBenefits to count.
     * @example
     * // Count the number of ProductBenefits
     * const count = await prisma.productBenefit.count({
     *   where: {
     *     // ... the filter for the ProductBenefits we want to count
     *   }
     * })
    **/
    count<T extends ProductBenefitCountArgs>(
      args?: Subset<T, ProductBenefitCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductBenefitCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProductBenefit.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductBenefitAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductBenefitAggregateArgs>(args: Subset<T, ProductBenefitAggregateArgs>): Prisma.PrismaPromise<GetProductBenefitAggregateType<T>>

    /**
     * Group by ProductBenefit.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductBenefitGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductBenefitGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductBenefitGroupByArgs['orderBy'] }
        : { orderBy?: ProductBenefitGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductBenefitGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductBenefitGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProductBenefit model
   */
  readonly fields: ProductBenefitFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProductBenefit.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProductBenefitClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    product<T extends ProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductDefaultArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    benefit<T extends BenefitDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BenefitDefaultArgs<ExtArgs>>): Prisma__BenefitClient<$Result.GetResult<Prisma.$BenefitPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProductBenefit model
   */
  interface ProductBenefitFieldRefs {
    readonly id: FieldRef<"ProductBenefit", 'String'>
    readonly productId: FieldRef<"ProductBenefit", 'String'>
    readonly benefitId: FieldRef<"ProductBenefit", 'String'>
    readonly isActive: FieldRef<"ProductBenefit", 'Boolean'>
    readonly order: FieldRef<"ProductBenefit", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * ProductBenefit findUnique
   */
  export type ProductBenefitFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductBenefit
     */
    select?: ProductBenefitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductBenefit
     */
    omit?: ProductBenefitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductBenefitInclude<ExtArgs> | null
    /**
     * Filter, which ProductBenefit to fetch.
     */
    where: ProductBenefitWhereUniqueInput
  }

  /**
   * ProductBenefit findUniqueOrThrow
   */
  export type ProductBenefitFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductBenefit
     */
    select?: ProductBenefitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductBenefit
     */
    omit?: ProductBenefitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductBenefitInclude<ExtArgs> | null
    /**
     * Filter, which ProductBenefit to fetch.
     */
    where: ProductBenefitWhereUniqueInput
  }

  /**
   * ProductBenefit findFirst
   */
  export type ProductBenefitFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductBenefit
     */
    select?: ProductBenefitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductBenefit
     */
    omit?: ProductBenefitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductBenefitInclude<ExtArgs> | null
    /**
     * Filter, which ProductBenefit to fetch.
     */
    where?: ProductBenefitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductBenefits to fetch.
     */
    orderBy?: ProductBenefitOrderByWithRelationInput | ProductBenefitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductBenefits.
     */
    cursor?: ProductBenefitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductBenefits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductBenefits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductBenefits.
     */
    distinct?: ProductBenefitScalarFieldEnum | ProductBenefitScalarFieldEnum[]
  }

  /**
   * ProductBenefit findFirstOrThrow
   */
  export type ProductBenefitFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductBenefit
     */
    select?: ProductBenefitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductBenefit
     */
    omit?: ProductBenefitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductBenefitInclude<ExtArgs> | null
    /**
     * Filter, which ProductBenefit to fetch.
     */
    where?: ProductBenefitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductBenefits to fetch.
     */
    orderBy?: ProductBenefitOrderByWithRelationInput | ProductBenefitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductBenefits.
     */
    cursor?: ProductBenefitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductBenefits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductBenefits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductBenefits.
     */
    distinct?: ProductBenefitScalarFieldEnum | ProductBenefitScalarFieldEnum[]
  }

  /**
   * ProductBenefit findMany
   */
  export type ProductBenefitFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductBenefit
     */
    select?: ProductBenefitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductBenefit
     */
    omit?: ProductBenefitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductBenefitInclude<ExtArgs> | null
    /**
     * Filter, which ProductBenefits to fetch.
     */
    where?: ProductBenefitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductBenefits to fetch.
     */
    orderBy?: ProductBenefitOrderByWithRelationInput | ProductBenefitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProductBenefits.
     */
    cursor?: ProductBenefitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductBenefits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductBenefits.
     */
    skip?: number
    distinct?: ProductBenefitScalarFieldEnum | ProductBenefitScalarFieldEnum[]
  }

  /**
   * ProductBenefit create
   */
  export type ProductBenefitCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductBenefit
     */
    select?: ProductBenefitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductBenefit
     */
    omit?: ProductBenefitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductBenefitInclude<ExtArgs> | null
    /**
     * The data needed to create a ProductBenefit.
     */
    data: XOR<ProductBenefitCreateInput, ProductBenefitUncheckedCreateInput>
  }

  /**
   * ProductBenefit createMany
   */
  export type ProductBenefitCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProductBenefits.
     */
    data: ProductBenefitCreateManyInput | ProductBenefitCreateManyInput[]
  }

  /**
   * ProductBenefit createManyAndReturn
   */
  export type ProductBenefitCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductBenefit
     */
    select?: ProductBenefitSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProductBenefit
     */
    omit?: ProductBenefitOmit<ExtArgs> | null
    /**
     * The data used to create many ProductBenefits.
     */
    data: ProductBenefitCreateManyInput | ProductBenefitCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductBenefitIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProductBenefit update
   */
  export type ProductBenefitUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductBenefit
     */
    select?: ProductBenefitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductBenefit
     */
    omit?: ProductBenefitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductBenefitInclude<ExtArgs> | null
    /**
     * The data needed to update a ProductBenefit.
     */
    data: XOR<ProductBenefitUpdateInput, ProductBenefitUncheckedUpdateInput>
    /**
     * Choose, which ProductBenefit to update.
     */
    where: ProductBenefitWhereUniqueInput
  }

  /**
   * ProductBenefit updateMany
   */
  export type ProductBenefitUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProductBenefits.
     */
    data: XOR<ProductBenefitUpdateManyMutationInput, ProductBenefitUncheckedUpdateManyInput>
    /**
     * Filter which ProductBenefits to update
     */
    where?: ProductBenefitWhereInput
    /**
     * Limit how many ProductBenefits to update.
     */
    limit?: number
  }

  /**
   * ProductBenefit updateManyAndReturn
   */
  export type ProductBenefitUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductBenefit
     */
    select?: ProductBenefitSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProductBenefit
     */
    omit?: ProductBenefitOmit<ExtArgs> | null
    /**
     * The data used to update ProductBenefits.
     */
    data: XOR<ProductBenefitUpdateManyMutationInput, ProductBenefitUncheckedUpdateManyInput>
    /**
     * Filter which ProductBenefits to update
     */
    where?: ProductBenefitWhereInput
    /**
     * Limit how many ProductBenefits to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductBenefitIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProductBenefit upsert
   */
  export type ProductBenefitUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductBenefit
     */
    select?: ProductBenefitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductBenefit
     */
    omit?: ProductBenefitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductBenefitInclude<ExtArgs> | null
    /**
     * The filter to search for the ProductBenefit to update in case it exists.
     */
    where: ProductBenefitWhereUniqueInput
    /**
     * In case the ProductBenefit found by the `where` argument doesn't exist, create a new ProductBenefit with this data.
     */
    create: XOR<ProductBenefitCreateInput, ProductBenefitUncheckedCreateInput>
    /**
     * In case the ProductBenefit was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductBenefitUpdateInput, ProductBenefitUncheckedUpdateInput>
  }

  /**
   * ProductBenefit delete
   */
  export type ProductBenefitDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductBenefit
     */
    select?: ProductBenefitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductBenefit
     */
    omit?: ProductBenefitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductBenefitInclude<ExtArgs> | null
    /**
     * Filter which ProductBenefit to delete.
     */
    where: ProductBenefitWhereUniqueInput
  }

  /**
   * ProductBenefit deleteMany
   */
  export type ProductBenefitDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductBenefits to delete
     */
    where?: ProductBenefitWhereInput
    /**
     * Limit how many ProductBenefits to delete.
     */
    limit?: number
  }

  /**
   * ProductBenefit without action
   */
  export type ProductBenefitDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductBenefit
     */
    select?: ProductBenefitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductBenefit
     */
    omit?: ProductBenefitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductBenefitInclude<ExtArgs> | null
  }


  /**
   * Model ProductBenefitPoint
   */

  export type AggregateProductBenefitPoint = {
    _count: ProductBenefitPointCountAggregateOutputType | null
    _avg: ProductBenefitPointAvgAggregateOutputType | null
    _sum: ProductBenefitPointSumAggregateOutputType | null
    _min: ProductBenefitPointMinAggregateOutputType | null
    _max: ProductBenefitPointMaxAggregateOutputType | null
  }

  export type ProductBenefitPointAvgAggregateOutputType = {
    order: number | null
  }

  export type ProductBenefitPointSumAggregateOutputType = {
    order: number | null
  }

  export type ProductBenefitPointMinAggregateOutputType = {
    id: string | null
    productId: string | null
    text: string | null
    order: number | null
    icon: string | null
  }

  export type ProductBenefitPointMaxAggregateOutputType = {
    id: string | null
    productId: string | null
    text: string | null
    order: number | null
    icon: string | null
  }

  export type ProductBenefitPointCountAggregateOutputType = {
    id: number
    productId: number
    text: number
    order: number
    icon: number
    _all: number
  }


  export type ProductBenefitPointAvgAggregateInputType = {
    order?: true
  }

  export type ProductBenefitPointSumAggregateInputType = {
    order?: true
  }

  export type ProductBenefitPointMinAggregateInputType = {
    id?: true
    productId?: true
    text?: true
    order?: true
    icon?: true
  }

  export type ProductBenefitPointMaxAggregateInputType = {
    id?: true
    productId?: true
    text?: true
    order?: true
    icon?: true
  }

  export type ProductBenefitPointCountAggregateInputType = {
    id?: true
    productId?: true
    text?: true
    order?: true
    icon?: true
    _all?: true
  }

  export type ProductBenefitPointAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductBenefitPoint to aggregate.
     */
    where?: ProductBenefitPointWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductBenefitPoints to fetch.
     */
    orderBy?: ProductBenefitPointOrderByWithRelationInput | ProductBenefitPointOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductBenefitPointWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductBenefitPoints from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductBenefitPoints.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProductBenefitPoints
    **/
    _count?: true | ProductBenefitPointCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProductBenefitPointAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProductBenefitPointSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductBenefitPointMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductBenefitPointMaxAggregateInputType
  }

  export type GetProductBenefitPointAggregateType<T extends ProductBenefitPointAggregateArgs> = {
        [P in keyof T & keyof AggregateProductBenefitPoint]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProductBenefitPoint[P]>
      : GetScalarType<T[P], AggregateProductBenefitPoint[P]>
  }




  export type ProductBenefitPointGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductBenefitPointWhereInput
    orderBy?: ProductBenefitPointOrderByWithAggregationInput | ProductBenefitPointOrderByWithAggregationInput[]
    by: ProductBenefitPointScalarFieldEnum[] | ProductBenefitPointScalarFieldEnum
    having?: ProductBenefitPointScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductBenefitPointCountAggregateInputType | true
    _avg?: ProductBenefitPointAvgAggregateInputType
    _sum?: ProductBenefitPointSumAggregateInputType
    _min?: ProductBenefitPointMinAggregateInputType
    _max?: ProductBenefitPointMaxAggregateInputType
  }

  export type ProductBenefitPointGroupByOutputType = {
    id: string
    productId: string
    text: string
    order: number
    icon: string | null
    _count: ProductBenefitPointCountAggregateOutputType | null
    _avg: ProductBenefitPointAvgAggregateOutputType | null
    _sum: ProductBenefitPointSumAggregateOutputType | null
    _min: ProductBenefitPointMinAggregateOutputType | null
    _max: ProductBenefitPointMaxAggregateOutputType | null
  }

  type GetProductBenefitPointGroupByPayload<T extends ProductBenefitPointGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductBenefitPointGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductBenefitPointGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductBenefitPointGroupByOutputType[P]>
            : GetScalarType<T[P], ProductBenefitPointGroupByOutputType[P]>
        }
      >
    >


  export type ProductBenefitPointSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productId?: boolean
    text?: boolean
    order?: boolean
    icon?: boolean
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productBenefitPoint"]>

  export type ProductBenefitPointSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productId?: boolean
    text?: boolean
    order?: boolean
    icon?: boolean
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productBenefitPoint"]>

  export type ProductBenefitPointSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productId?: boolean
    text?: boolean
    order?: boolean
    icon?: boolean
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productBenefitPoint"]>

  export type ProductBenefitPointSelectScalar = {
    id?: boolean
    productId?: boolean
    text?: boolean
    order?: boolean
    icon?: boolean
  }

  export type ProductBenefitPointOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "productId" | "text" | "order" | "icon", ExtArgs["result"]["productBenefitPoint"]>
  export type ProductBenefitPointInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }
  export type ProductBenefitPointIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }
  export type ProductBenefitPointIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }

  export type $ProductBenefitPointPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProductBenefitPoint"
    objects: {
      product: Prisma.$ProductPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      productId: string
      text: string
      order: number
      icon: string | null
    }, ExtArgs["result"]["productBenefitPoint"]>
    composites: {}
  }

  type ProductBenefitPointGetPayload<S extends boolean | null | undefined | ProductBenefitPointDefaultArgs> = $Result.GetResult<Prisma.$ProductBenefitPointPayload, S>

  type ProductBenefitPointCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProductBenefitPointFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProductBenefitPointCountAggregateInputType | true
    }

  export interface ProductBenefitPointDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProductBenefitPoint'], meta: { name: 'ProductBenefitPoint' } }
    /**
     * Find zero or one ProductBenefitPoint that matches the filter.
     * @param {ProductBenefitPointFindUniqueArgs} args - Arguments to find a ProductBenefitPoint
     * @example
     * // Get one ProductBenefitPoint
     * const productBenefitPoint = await prisma.productBenefitPoint.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProductBenefitPointFindUniqueArgs>(args: SelectSubset<T, ProductBenefitPointFindUniqueArgs<ExtArgs>>): Prisma__ProductBenefitPointClient<$Result.GetResult<Prisma.$ProductBenefitPointPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ProductBenefitPoint that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProductBenefitPointFindUniqueOrThrowArgs} args - Arguments to find a ProductBenefitPoint
     * @example
     * // Get one ProductBenefitPoint
     * const productBenefitPoint = await prisma.productBenefitPoint.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProductBenefitPointFindUniqueOrThrowArgs>(args: SelectSubset<T, ProductBenefitPointFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProductBenefitPointClient<$Result.GetResult<Prisma.$ProductBenefitPointPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProductBenefitPoint that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductBenefitPointFindFirstArgs} args - Arguments to find a ProductBenefitPoint
     * @example
     * // Get one ProductBenefitPoint
     * const productBenefitPoint = await prisma.productBenefitPoint.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProductBenefitPointFindFirstArgs>(args?: SelectSubset<T, ProductBenefitPointFindFirstArgs<ExtArgs>>): Prisma__ProductBenefitPointClient<$Result.GetResult<Prisma.$ProductBenefitPointPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProductBenefitPoint that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductBenefitPointFindFirstOrThrowArgs} args - Arguments to find a ProductBenefitPoint
     * @example
     * // Get one ProductBenefitPoint
     * const productBenefitPoint = await prisma.productBenefitPoint.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProductBenefitPointFindFirstOrThrowArgs>(args?: SelectSubset<T, ProductBenefitPointFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProductBenefitPointClient<$Result.GetResult<Prisma.$ProductBenefitPointPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ProductBenefitPoints that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductBenefitPointFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProductBenefitPoints
     * const productBenefitPoints = await prisma.productBenefitPoint.findMany()
     * 
     * // Get first 10 ProductBenefitPoints
     * const productBenefitPoints = await prisma.productBenefitPoint.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productBenefitPointWithIdOnly = await prisma.productBenefitPoint.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProductBenefitPointFindManyArgs>(args?: SelectSubset<T, ProductBenefitPointFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductBenefitPointPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ProductBenefitPoint.
     * @param {ProductBenefitPointCreateArgs} args - Arguments to create a ProductBenefitPoint.
     * @example
     * // Create one ProductBenefitPoint
     * const ProductBenefitPoint = await prisma.productBenefitPoint.create({
     *   data: {
     *     // ... data to create a ProductBenefitPoint
     *   }
     * })
     * 
     */
    create<T extends ProductBenefitPointCreateArgs>(args: SelectSubset<T, ProductBenefitPointCreateArgs<ExtArgs>>): Prisma__ProductBenefitPointClient<$Result.GetResult<Prisma.$ProductBenefitPointPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ProductBenefitPoints.
     * @param {ProductBenefitPointCreateManyArgs} args - Arguments to create many ProductBenefitPoints.
     * @example
     * // Create many ProductBenefitPoints
     * const productBenefitPoint = await prisma.productBenefitPoint.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProductBenefitPointCreateManyArgs>(args?: SelectSubset<T, ProductBenefitPointCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProductBenefitPoints and returns the data saved in the database.
     * @param {ProductBenefitPointCreateManyAndReturnArgs} args - Arguments to create many ProductBenefitPoints.
     * @example
     * // Create many ProductBenefitPoints
     * const productBenefitPoint = await prisma.productBenefitPoint.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProductBenefitPoints and only return the `id`
     * const productBenefitPointWithIdOnly = await prisma.productBenefitPoint.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProductBenefitPointCreateManyAndReturnArgs>(args?: SelectSubset<T, ProductBenefitPointCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductBenefitPointPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ProductBenefitPoint.
     * @param {ProductBenefitPointDeleteArgs} args - Arguments to delete one ProductBenefitPoint.
     * @example
     * // Delete one ProductBenefitPoint
     * const ProductBenefitPoint = await prisma.productBenefitPoint.delete({
     *   where: {
     *     // ... filter to delete one ProductBenefitPoint
     *   }
     * })
     * 
     */
    delete<T extends ProductBenefitPointDeleteArgs>(args: SelectSubset<T, ProductBenefitPointDeleteArgs<ExtArgs>>): Prisma__ProductBenefitPointClient<$Result.GetResult<Prisma.$ProductBenefitPointPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ProductBenefitPoint.
     * @param {ProductBenefitPointUpdateArgs} args - Arguments to update one ProductBenefitPoint.
     * @example
     * // Update one ProductBenefitPoint
     * const productBenefitPoint = await prisma.productBenefitPoint.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProductBenefitPointUpdateArgs>(args: SelectSubset<T, ProductBenefitPointUpdateArgs<ExtArgs>>): Prisma__ProductBenefitPointClient<$Result.GetResult<Prisma.$ProductBenefitPointPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ProductBenefitPoints.
     * @param {ProductBenefitPointDeleteManyArgs} args - Arguments to filter ProductBenefitPoints to delete.
     * @example
     * // Delete a few ProductBenefitPoints
     * const { count } = await prisma.productBenefitPoint.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProductBenefitPointDeleteManyArgs>(args?: SelectSubset<T, ProductBenefitPointDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductBenefitPoints.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductBenefitPointUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProductBenefitPoints
     * const productBenefitPoint = await prisma.productBenefitPoint.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProductBenefitPointUpdateManyArgs>(args: SelectSubset<T, ProductBenefitPointUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductBenefitPoints and returns the data updated in the database.
     * @param {ProductBenefitPointUpdateManyAndReturnArgs} args - Arguments to update many ProductBenefitPoints.
     * @example
     * // Update many ProductBenefitPoints
     * const productBenefitPoint = await prisma.productBenefitPoint.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ProductBenefitPoints and only return the `id`
     * const productBenefitPointWithIdOnly = await prisma.productBenefitPoint.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProductBenefitPointUpdateManyAndReturnArgs>(args: SelectSubset<T, ProductBenefitPointUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductBenefitPointPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ProductBenefitPoint.
     * @param {ProductBenefitPointUpsertArgs} args - Arguments to update or create a ProductBenefitPoint.
     * @example
     * // Update or create a ProductBenefitPoint
     * const productBenefitPoint = await prisma.productBenefitPoint.upsert({
     *   create: {
     *     // ... data to create a ProductBenefitPoint
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProductBenefitPoint we want to update
     *   }
     * })
     */
    upsert<T extends ProductBenefitPointUpsertArgs>(args: SelectSubset<T, ProductBenefitPointUpsertArgs<ExtArgs>>): Prisma__ProductBenefitPointClient<$Result.GetResult<Prisma.$ProductBenefitPointPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ProductBenefitPoints.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductBenefitPointCountArgs} args - Arguments to filter ProductBenefitPoints to count.
     * @example
     * // Count the number of ProductBenefitPoints
     * const count = await prisma.productBenefitPoint.count({
     *   where: {
     *     // ... the filter for the ProductBenefitPoints we want to count
     *   }
     * })
    **/
    count<T extends ProductBenefitPointCountArgs>(
      args?: Subset<T, ProductBenefitPointCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductBenefitPointCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProductBenefitPoint.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductBenefitPointAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductBenefitPointAggregateArgs>(args: Subset<T, ProductBenefitPointAggregateArgs>): Prisma.PrismaPromise<GetProductBenefitPointAggregateType<T>>

    /**
     * Group by ProductBenefitPoint.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductBenefitPointGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductBenefitPointGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductBenefitPointGroupByArgs['orderBy'] }
        : { orderBy?: ProductBenefitPointGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductBenefitPointGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductBenefitPointGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProductBenefitPoint model
   */
  readonly fields: ProductBenefitPointFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProductBenefitPoint.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProductBenefitPointClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    product<T extends ProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductDefaultArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProductBenefitPoint model
   */
  interface ProductBenefitPointFieldRefs {
    readonly id: FieldRef<"ProductBenefitPoint", 'String'>
    readonly productId: FieldRef<"ProductBenefitPoint", 'String'>
    readonly text: FieldRef<"ProductBenefitPoint", 'String'>
    readonly order: FieldRef<"ProductBenefitPoint", 'Int'>
    readonly icon: FieldRef<"ProductBenefitPoint", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ProductBenefitPoint findUnique
   */
  export type ProductBenefitPointFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductBenefitPoint
     */
    select?: ProductBenefitPointSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductBenefitPoint
     */
    omit?: ProductBenefitPointOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductBenefitPointInclude<ExtArgs> | null
    /**
     * Filter, which ProductBenefitPoint to fetch.
     */
    where: ProductBenefitPointWhereUniqueInput
  }

  /**
   * ProductBenefitPoint findUniqueOrThrow
   */
  export type ProductBenefitPointFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductBenefitPoint
     */
    select?: ProductBenefitPointSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductBenefitPoint
     */
    omit?: ProductBenefitPointOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductBenefitPointInclude<ExtArgs> | null
    /**
     * Filter, which ProductBenefitPoint to fetch.
     */
    where: ProductBenefitPointWhereUniqueInput
  }

  /**
   * ProductBenefitPoint findFirst
   */
  export type ProductBenefitPointFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductBenefitPoint
     */
    select?: ProductBenefitPointSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductBenefitPoint
     */
    omit?: ProductBenefitPointOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductBenefitPointInclude<ExtArgs> | null
    /**
     * Filter, which ProductBenefitPoint to fetch.
     */
    where?: ProductBenefitPointWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductBenefitPoints to fetch.
     */
    orderBy?: ProductBenefitPointOrderByWithRelationInput | ProductBenefitPointOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductBenefitPoints.
     */
    cursor?: ProductBenefitPointWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductBenefitPoints from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductBenefitPoints.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductBenefitPoints.
     */
    distinct?: ProductBenefitPointScalarFieldEnum | ProductBenefitPointScalarFieldEnum[]
  }

  /**
   * ProductBenefitPoint findFirstOrThrow
   */
  export type ProductBenefitPointFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductBenefitPoint
     */
    select?: ProductBenefitPointSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductBenefitPoint
     */
    omit?: ProductBenefitPointOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductBenefitPointInclude<ExtArgs> | null
    /**
     * Filter, which ProductBenefitPoint to fetch.
     */
    where?: ProductBenefitPointWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductBenefitPoints to fetch.
     */
    orderBy?: ProductBenefitPointOrderByWithRelationInput | ProductBenefitPointOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductBenefitPoints.
     */
    cursor?: ProductBenefitPointWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductBenefitPoints from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductBenefitPoints.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductBenefitPoints.
     */
    distinct?: ProductBenefitPointScalarFieldEnum | ProductBenefitPointScalarFieldEnum[]
  }

  /**
   * ProductBenefitPoint findMany
   */
  export type ProductBenefitPointFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductBenefitPoint
     */
    select?: ProductBenefitPointSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductBenefitPoint
     */
    omit?: ProductBenefitPointOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductBenefitPointInclude<ExtArgs> | null
    /**
     * Filter, which ProductBenefitPoints to fetch.
     */
    where?: ProductBenefitPointWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductBenefitPoints to fetch.
     */
    orderBy?: ProductBenefitPointOrderByWithRelationInput | ProductBenefitPointOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProductBenefitPoints.
     */
    cursor?: ProductBenefitPointWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductBenefitPoints from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductBenefitPoints.
     */
    skip?: number
    distinct?: ProductBenefitPointScalarFieldEnum | ProductBenefitPointScalarFieldEnum[]
  }

  /**
   * ProductBenefitPoint create
   */
  export type ProductBenefitPointCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductBenefitPoint
     */
    select?: ProductBenefitPointSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductBenefitPoint
     */
    omit?: ProductBenefitPointOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductBenefitPointInclude<ExtArgs> | null
    /**
     * The data needed to create a ProductBenefitPoint.
     */
    data: XOR<ProductBenefitPointCreateInput, ProductBenefitPointUncheckedCreateInput>
  }

  /**
   * ProductBenefitPoint createMany
   */
  export type ProductBenefitPointCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProductBenefitPoints.
     */
    data: ProductBenefitPointCreateManyInput | ProductBenefitPointCreateManyInput[]
  }

  /**
   * ProductBenefitPoint createManyAndReturn
   */
  export type ProductBenefitPointCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductBenefitPoint
     */
    select?: ProductBenefitPointSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProductBenefitPoint
     */
    omit?: ProductBenefitPointOmit<ExtArgs> | null
    /**
     * The data used to create many ProductBenefitPoints.
     */
    data: ProductBenefitPointCreateManyInput | ProductBenefitPointCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductBenefitPointIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProductBenefitPoint update
   */
  export type ProductBenefitPointUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductBenefitPoint
     */
    select?: ProductBenefitPointSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductBenefitPoint
     */
    omit?: ProductBenefitPointOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductBenefitPointInclude<ExtArgs> | null
    /**
     * The data needed to update a ProductBenefitPoint.
     */
    data: XOR<ProductBenefitPointUpdateInput, ProductBenefitPointUncheckedUpdateInput>
    /**
     * Choose, which ProductBenefitPoint to update.
     */
    where: ProductBenefitPointWhereUniqueInput
  }

  /**
   * ProductBenefitPoint updateMany
   */
  export type ProductBenefitPointUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProductBenefitPoints.
     */
    data: XOR<ProductBenefitPointUpdateManyMutationInput, ProductBenefitPointUncheckedUpdateManyInput>
    /**
     * Filter which ProductBenefitPoints to update
     */
    where?: ProductBenefitPointWhereInput
    /**
     * Limit how many ProductBenefitPoints to update.
     */
    limit?: number
  }

  /**
   * ProductBenefitPoint updateManyAndReturn
   */
  export type ProductBenefitPointUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductBenefitPoint
     */
    select?: ProductBenefitPointSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProductBenefitPoint
     */
    omit?: ProductBenefitPointOmit<ExtArgs> | null
    /**
     * The data used to update ProductBenefitPoints.
     */
    data: XOR<ProductBenefitPointUpdateManyMutationInput, ProductBenefitPointUncheckedUpdateManyInput>
    /**
     * Filter which ProductBenefitPoints to update
     */
    where?: ProductBenefitPointWhereInput
    /**
     * Limit how many ProductBenefitPoints to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductBenefitPointIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProductBenefitPoint upsert
   */
  export type ProductBenefitPointUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductBenefitPoint
     */
    select?: ProductBenefitPointSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductBenefitPoint
     */
    omit?: ProductBenefitPointOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductBenefitPointInclude<ExtArgs> | null
    /**
     * The filter to search for the ProductBenefitPoint to update in case it exists.
     */
    where: ProductBenefitPointWhereUniqueInput
    /**
     * In case the ProductBenefitPoint found by the `where` argument doesn't exist, create a new ProductBenefitPoint with this data.
     */
    create: XOR<ProductBenefitPointCreateInput, ProductBenefitPointUncheckedCreateInput>
    /**
     * In case the ProductBenefitPoint was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductBenefitPointUpdateInput, ProductBenefitPointUncheckedUpdateInput>
  }

  /**
   * ProductBenefitPoint delete
   */
  export type ProductBenefitPointDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductBenefitPoint
     */
    select?: ProductBenefitPointSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductBenefitPoint
     */
    omit?: ProductBenefitPointOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductBenefitPointInclude<ExtArgs> | null
    /**
     * Filter which ProductBenefitPoint to delete.
     */
    where: ProductBenefitPointWhereUniqueInput
  }

  /**
   * ProductBenefitPoint deleteMany
   */
  export type ProductBenefitPointDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductBenefitPoints to delete
     */
    where?: ProductBenefitPointWhereInput
    /**
     * Limit how many ProductBenefitPoints to delete.
     */
    limit?: number
  }

  /**
   * ProductBenefitPoint without action
   */
  export type ProductBenefitPointDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductBenefitPoint
     */
    select?: ProductBenefitPointSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductBenefitPoint
     */
    omit?: ProductBenefitPointOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductBenefitPointInclude<ExtArgs> | null
  }


  /**
   * Model Promotion
   */

  export type AggregatePromotion = {
    _count: PromotionCountAggregateOutputType | null
    _avg: PromotionAvgAggregateOutputType | null
    _sum: PromotionSumAggregateOutputType | null
    _min: PromotionMinAggregateOutputType | null
    _max: PromotionMaxAggregateOutputType | null
  }

  export type PromotionAvgAggregateOutputType = {
    value: number | null
  }

  export type PromotionSumAggregateOutputType = {
    value: number | null
  }

  export type PromotionMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    type: $Enums.PromoType | null
    value: number | null
    isActive: boolean | null
    startDate: Date | null
    endDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PromotionMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    type: $Enums.PromoType | null
    value: number | null
    isActive: boolean | null
    startDate: Date | null
    endDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PromotionCountAggregateOutputType = {
    id: number
    name: number
    description: number
    type: number
    value: number
    isActive: number
    startDate: number
    endDate: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PromotionAvgAggregateInputType = {
    value?: true
  }

  export type PromotionSumAggregateInputType = {
    value?: true
  }

  export type PromotionMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    type?: true
    value?: true
    isActive?: true
    startDate?: true
    endDate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PromotionMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    type?: true
    value?: true
    isActive?: true
    startDate?: true
    endDate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PromotionCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    type?: true
    value?: true
    isActive?: true
    startDate?: true
    endDate?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PromotionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Promotion to aggregate.
     */
    where?: PromotionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Promotions to fetch.
     */
    orderBy?: PromotionOrderByWithRelationInput | PromotionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PromotionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Promotions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Promotions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Promotions
    **/
    _count?: true | PromotionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PromotionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PromotionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PromotionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PromotionMaxAggregateInputType
  }

  export type GetPromotionAggregateType<T extends PromotionAggregateArgs> = {
        [P in keyof T & keyof AggregatePromotion]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePromotion[P]>
      : GetScalarType<T[P], AggregatePromotion[P]>
  }




  export type PromotionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PromotionWhereInput
    orderBy?: PromotionOrderByWithAggregationInput | PromotionOrderByWithAggregationInput[]
    by: PromotionScalarFieldEnum[] | PromotionScalarFieldEnum
    having?: PromotionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PromotionCountAggregateInputType | true
    _avg?: PromotionAvgAggregateInputType
    _sum?: PromotionSumAggregateInputType
    _min?: PromotionMinAggregateInputType
    _max?: PromotionMaxAggregateInputType
  }

  export type PromotionGroupByOutputType = {
    id: string
    name: string
    description: string | null
    type: $Enums.PromoType
    value: number | null
    isActive: boolean
    startDate: Date
    endDate: Date
    createdAt: Date
    updatedAt: Date
    _count: PromotionCountAggregateOutputType | null
    _avg: PromotionAvgAggregateOutputType | null
    _sum: PromotionSumAggregateOutputType | null
    _min: PromotionMinAggregateOutputType | null
    _max: PromotionMaxAggregateOutputType | null
  }

  type GetPromotionGroupByPayload<T extends PromotionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PromotionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PromotionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PromotionGroupByOutputType[P]>
            : GetScalarType<T[P], PromotionGroupByOutputType[P]>
        }
      >
    >


  export type PromotionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    type?: boolean
    value?: boolean
    isActive?: boolean
    startDate?: boolean
    endDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    products?: boolean | Promotion$productsArgs<ExtArgs>
    _count?: boolean | PromotionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["promotion"]>

  export type PromotionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    type?: boolean
    value?: boolean
    isActive?: boolean
    startDate?: boolean
    endDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["promotion"]>

  export type PromotionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    type?: boolean
    value?: boolean
    isActive?: boolean
    startDate?: boolean
    endDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["promotion"]>

  export type PromotionSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    type?: boolean
    value?: boolean
    isActive?: boolean
    startDate?: boolean
    endDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PromotionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "type" | "value" | "isActive" | "startDate" | "endDate" | "createdAt" | "updatedAt", ExtArgs["result"]["promotion"]>
  export type PromotionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    products?: boolean | Promotion$productsArgs<ExtArgs>
    _count?: boolean | PromotionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PromotionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type PromotionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $PromotionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Promotion"
    objects: {
      products: Prisma.$ProductPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      type: $Enums.PromoType
      value: number | null
      isActive: boolean
      startDate: Date
      endDate: Date
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["promotion"]>
    composites: {}
  }

  type PromotionGetPayload<S extends boolean | null | undefined | PromotionDefaultArgs> = $Result.GetResult<Prisma.$PromotionPayload, S>

  type PromotionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PromotionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PromotionCountAggregateInputType | true
    }

  export interface PromotionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Promotion'], meta: { name: 'Promotion' } }
    /**
     * Find zero or one Promotion that matches the filter.
     * @param {PromotionFindUniqueArgs} args - Arguments to find a Promotion
     * @example
     * // Get one Promotion
     * const promotion = await prisma.promotion.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PromotionFindUniqueArgs>(args: SelectSubset<T, PromotionFindUniqueArgs<ExtArgs>>): Prisma__PromotionClient<$Result.GetResult<Prisma.$PromotionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Promotion that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PromotionFindUniqueOrThrowArgs} args - Arguments to find a Promotion
     * @example
     * // Get one Promotion
     * const promotion = await prisma.promotion.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PromotionFindUniqueOrThrowArgs>(args: SelectSubset<T, PromotionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PromotionClient<$Result.GetResult<Prisma.$PromotionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Promotion that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromotionFindFirstArgs} args - Arguments to find a Promotion
     * @example
     * // Get one Promotion
     * const promotion = await prisma.promotion.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PromotionFindFirstArgs>(args?: SelectSubset<T, PromotionFindFirstArgs<ExtArgs>>): Prisma__PromotionClient<$Result.GetResult<Prisma.$PromotionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Promotion that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromotionFindFirstOrThrowArgs} args - Arguments to find a Promotion
     * @example
     * // Get one Promotion
     * const promotion = await prisma.promotion.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PromotionFindFirstOrThrowArgs>(args?: SelectSubset<T, PromotionFindFirstOrThrowArgs<ExtArgs>>): Prisma__PromotionClient<$Result.GetResult<Prisma.$PromotionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Promotions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromotionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Promotions
     * const promotions = await prisma.promotion.findMany()
     * 
     * // Get first 10 Promotions
     * const promotions = await prisma.promotion.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const promotionWithIdOnly = await prisma.promotion.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PromotionFindManyArgs>(args?: SelectSubset<T, PromotionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PromotionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Promotion.
     * @param {PromotionCreateArgs} args - Arguments to create a Promotion.
     * @example
     * // Create one Promotion
     * const Promotion = await prisma.promotion.create({
     *   data: {
     *     // ... data to create a Promotion
     *   }
     * })
     * 
     */
    create<T extends PromotionCreateArgs>(args: SelectSubset<T, PromotionCreateArgs<ExtArgs>>): Prisma__PromotionClient<$Result.GetResult<Prisma.$PromotionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Promotions.
     * @param {PromotionCreateManyArgs} args - Arguments to create many Promotions.
     * @example
     * // Create many Promotions
     * const promotion = await prisma.promotion.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PromotionCreateManyArgs>(args?: SelectSubset<T, PromotionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Promotions and returns the data saved in the database.
     * @param {PromotionCreateManyAndReturnArgs} args - Arguments to create many Promotions.
     * @example
     * // Create many Promotions
     * const promotion = await prisma.promotion.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Promotions and only return the `id`
     * const promotionWithIdOnly = await prisma.promotion.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PromotionCreateManyAndReturnArgs>(args?: SelectSubset<T, PromotionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PromotionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Promotion.
     * @param {PromotionDeleteArgs} args - Arguments to delete one Promotion.
     * @example
     * // Delete one Promotion
     * const Promotion = await prisma.promotion.delete({
     *   where: {
     *     // ... filter to delete one Promotion
     *   }
     * })
     * 
     */
    delete<T extends PromotionDeleteArgs>(args: SelectSubset<T, PromotionDeleteArgs<ExtArgs>>): Prisma__PromotionClient<$Result.GetResult<Prisma.$PromotionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Promotion.
     * @param {PromotionUpdateArgs} args - Arguments to update one Promotion.
     * @example
     * // Update one Promotion
     * const promotion = await prisma.promotion.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PromotionUpdateArgs>(args: SelectSubset<T, PromotionUpdateArgs<ExtArgs>>): Prisma__PromotionClient<$Result.GetResult<Prisma.$PromotionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Promotions.
     * @param {PromotionDeleteManyArgs} args - Arguments to filter Promotions to delete.
     * @example
     * // Delete a few Promotions
     * const { count } = await prisma.promotion.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PromotionDeleteManyArgs>(args?: SelectSubset<T, PromotionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Promotions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromotionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Promotions
     * const promotion = await prisma.promotion.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PromotionUpdateManyArgs>(args: SelectSubset<T, PromotionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Promotions and returns the data updated in the database.
     * @param {PromotionUpdateManyAndReturnArgs} args - Arguments to update many Promotions.
     * @example
     * // Update many Promotions
     * const promotion = await prisma.promotion.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Promotions and only return the `id`
     * const promotionWithIdOnly = await prisma.promotion.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PromotionUpdateManyAndReturnArgs>(args: SelectSubset<T, PromotionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PromotionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Promotion.
     * @param {PromotionUpsertArgs} args - Arguments to update or create a Promotion.
     * @example
     * // Update or create a Promotion
     * const promotion = await prisma.promotion.upsert({
     *   create: {
     *     // ... data to create a Promotion
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Promotion we want to update
     *   }
     * })
     */
    upsert<T extends PromotionUpsertArgs>(args: SelectSubset<T, PromotionUpsertArgs<ExtArgs>>): Prisma__PromotionClient<$Result.GetResult<Prisma.$PromotionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Promotions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromotionCountArgs} args - Arguments to filter Promotions to count.
     * @example
     * // Count the number of Promotions
     * const count = await prisma.promotion.count({
     *   where: {
     *     // ... the filter for the Promotions we want to count
     *   }
     * })
    **/
    count<T extends PromotionCountArgs>(
      args?: Subset<T, PromotionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PromotionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Promotion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromotionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PromotionAggregateArgs>(args: Subset<T, PromotionAggregateArgs>): Prisma.PrismaPromise<GetPromotionAggregateType<T>>

    /**
     * Group by Promotion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromotionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PromotionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PromotionGroupByArgs['orderBy'] }
        : { orderBy?: PromotionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PromotionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPromotionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Promotion model
   */
  readonly fields: PromotionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Promotion.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PromotionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    products<T extends Promotion$productsArgs<ExtArgs> = {}>(args?: Subset<T, Promotion$productsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Promotion model
   */
  interface PromotionFieldRefs {
    readonly id: FieldRef<"Promotion", 'String'>
    readonly name: FieldRef<"Promotion", 'String'>
    readonly description: FieldRef<"Promotion", 'String'>
    readonly type: FieldRef<"Promotion", 'PromoType'>
    readonly value: FieldRef<"Promotion", 'Float'>
    readonly isActive: FieldRef<"Promotion", 'Boolean'>
    readonly startDate: FieldRef<"Promotion", 'DateTime'>
    readonly endDate: FieldRef<"Promotion", 'DateTime'>
    readonly createdAt: FieldRef<"Promotion", 'DateTime'>
    readonly updatedAt: FieldRef<"Promotion", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Promotion findUnique
   */
  export type PromotionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Promotion
     */
    select?: PromotionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Promotion
     */
    omit?: PromotionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromotionInclude<ExtArgs> | null
    /**
     * Filter, which Promotion to fetch.
     */
    where: PromotionWhereUniqueInput
  }

  /**
   * Promotion findUniqueOrThrow
   */
  export type PromotionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Promotion
     */
    select?: PromotionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Promotion
     */
    omit?: PromotionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromotionInclude<ExtArgs> | null
    /**
     * Filter, which Promotion to fetch.
     */
    where: PromotionWhereUniqueInput
  }

  /**
   * Promotion findFirst
   */
  export type PromotionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Promotion
     */
    select?: PromotionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Promotion
     */
    omit?: PromotionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromotionInclude<ExtArgs> | null
    /**
     * Filter, which Promotion to fetch.
     */
    where?: PromotionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Promotions to fetch.
     */
    orderBy?: PromotionOrderByWithRelationInput | PromotionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Promotions.
     */
    cursor?: PromotionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Promotions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Promotions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Promotions.
     */
    distinct?: PromotionScalarFieldEnum | PromotionScalarFieldEnum[]
  }

  /**
   * Promotion findFirstOrThrow
   */
  export type PromotionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Promotion
     */
    select?: PromotionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Promotion
     */
    omit?: PromotionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromotionInclude<ExtArgs> | null
    /**
     * Filter, which Promotion to fetch.
     */
    where?: PromotionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Promotions to fetch.
     */
    orderBy?: PromotionOrderByWithRelationInput | PromotionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Promotions.
     */
    cursor?: PromotionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Promotions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Promotions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Promotions.
     */
    distinct?: PromotionScalarFieldEnum | PromotionScalarFieldEnum[]
  }

  /**
   * Promotion findMany
   */
  export type PromotionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Promotion
     */
    select?: PromotionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Promotion
     */
    omit?: PromotionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromotionInclude<ExtArgs> | null
    /**
     * Filter, which Promotions to fetch.
     */
    where?: PromotionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Promotions to fetch.
     */
    orderBy?: PromotionOrderByWithRelationInput | PromotionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Promotions.
     */
    cursor?: PromotionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Promotions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Promotions.
     */
    skip?: number
    distinct?: PromotionScalarFieldEnum | PromotionScalarFieldEnum[]
  }

  /**
   * Promotion create
   */
  export type PromotionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Promotion
     */
    select?: PromotionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Promotion
     */
    omit?: PromotionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromotionInclude<ExtArgs> | null
    /**
     * The data needed to create a Promotion.
     */
    data: XOR<PromotionCreateInput, PromotionUncheckedCreateInput>
  }

  /**
   * Promotion createMany
   */
  export type PromotionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Promotions.
     */
    data: PromotionCreateManyInput | PromotionCreateManyInput[]
  }

  /**
   * Promotion createManyAndReturn
   */
  export type PromotionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Promotion
     */
    select?: PromotionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Promotion
     */
    omit?: PromotionOmit<ExtArgs> | null
    /**
     * The data used to create many Promotions.
     */
    data: PromotionCreateManyInput | PromotionCreateManyInput[]
  }

  /**
   * Promotion update
   */
  export type PromotionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Promotion
     */
    select?: PromotionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Promotion
     */
    omit?: PromotionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromotionInclude<ExtArgs> | null
    /**
     * The data needed to update a Promotion.
     */
    data: XOR<PromotionUpdateInput, PromotionUncheckedUpdateInput>
    /**
     * Choose, which Promotion to update.
     */
    where: PromotionWhereUniqueInput
  }

  /**
   * Promotion updateMany
   */
  export type PromotionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Promotions.
     */
    data: XOR<PromotionUpdateManyMutationInput, PromotionUncheckedUpdateManyInput>
    /**
     * Filter which Promotions to update
     */
    where?: PromotionWhereInput
    /**
     * Limit how many Promotions to update.
     */
    limit?: number
  }

  /**
   * Promotion updateManyAndReturn
   */
  export type PromotionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Promotion
     */
    select?: PromotionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Promotion
     */
    omit?: PromotionOmit<ExtArgs> | null
    /**
     * The data used to update Promotions.
     */
    data: XOR<PromotionUpdateManyMutationInput, PromotionUncheckedUpdateManyInput>
    /**
     * Filter which Promotions to update
     */
    where?: PromotionWhereInput
    /**
     * Limit how many Promotions to update.
     */
    limit?: number
  }

  /**
   * Promotion upsert
   */
  export type PromotionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Promotion
     */
    select?: PromotionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Promotion
     */
    omit?: PromotionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromotionInclude<ExtArgs> | null
    /**
     * The filter to search for the Promotion to update in case it exists.
     */
    where: PromotionWhereUniqueInput
    /**
     * In case the Promotion found by the `where` argument doesn't exist, create a new Promotion with this data.
     */
    create: XOR<PromotionCreateInput, PromotionUncheckedCreateInput>
    /**
     * In case the Promotion was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PromotionUpdateInput, PromotionUncheckedUpdateInput>
  }

  /**
   * Promotion delete
   */
  export type PromotionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Promotion
     */
    select?: PromotionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Promotion
     */
    omit?: PromotionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromotionInclude<ExtArgs> | null
    /**
     * Filter which Promotion to delete.
     */
    where: PromotionWhereUniqueInput
  }

  /**
   * Promotion deleteMany
   */
  export type PromotionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Promotions to delete
     */
    where?: PromotionWhereInput
    /**
     * Limit how many Promotions to delete.
     */
    limit?: number
  }

  /**
   * Promotion.products
   */
  export type Promotion$productsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    where?: ProductWhereInput
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    cursor?: ProductWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Promotion without action
   */
  export type PromotionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Promotion
     */
    select?: PromotionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Promotion
     */
    omit?: PromotionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromotionInclude<ExtArgs> | null
  }


  /**
   * Model Voucher
   */

  export type AggregateVoucher = {
    _count: VoucherCountAggregateOutputType | null
    _avg: VoucherAvgAggregateOutputType | null
    _sum: VoucherSumAggregateOutputType | null
    _min: VoucherMinAggregateOutputType | null
    _max: VoucherMaxAggregateOutputType | null
  }

  export type VoucherAvgAggregateOutputType = {
    value: number | null
    usageLimit: number | null
    usedCount: number | null
  }

  export type VoucherSumAggregateOutputType = {
    value: number | null
    usageLimit: number | null
    usedCount: number | null
  }

  export type VoucherMinAggregateOutputType = {
    id: string | null
    code: string | null
    description: string | null
    type: $Enums.PromoType | null
    value: number | null
    usageLimit: number | null
    usedCount: number | null
    isActive: boolean | null
    startDate: Date | null
    endDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VoucherMaxAggregateOutputType = {
    id: string | null
    code: string | null
    description: string | null
    type: $Enums.PromoType | null
    value: number | null
    usageLimit: number | null
    usedCount: number | null
    isActive: boolean | null
    startDate: Date | null
    endDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VoucherCountAggregateOutputType = {
    id: number
    code: number
    description: number
    type: number
    value: number
    usageLimit: number
    usedCount: number
    isActive: number
    startDate: number
    endDate: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type VoucherAvgAggregateInputType = {
    value?: true
    usageLimit?: true
    usedCount?: true
  }

  export type VoucherSumAggregateInputType = {
    value?: true
    usageLimit?: true
    usedCount?: true
  }

  export type VoucherMinAggregateInputType = {
    id?: true
    code?: true
    description?: true
    type?: true
    value?: true
    usageLimit?: true
    usedCount?: true
    isActive?: true
    startDate?: true
    endDate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VoucherMaxAggregateInputType = {
    id?: true
    code?: true
    description?: true
    type?: true
    value?: true
    usageLimit?: true
    usedCount?: true
    isActive?: true
    startDate?: true
    endDate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VoucherCountAggregateInputType = {
    id?: true
    code?: true
    description?: true
    type?: true
    value?: true
    usageLimit?: true
    usedCount?: true
    isActive?: true
    startDate?: true
    endDate?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type VoucherAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Voucher to aggregate.
     */
    where?: VoucherWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Vouchers to fetch.
     */
    orderBy?: VoucherOrderByWithRelationInput | VoucherOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VoucherWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Vouchers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Vouchers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Vouchers
    **/
    _count?: true | VoucherCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: VoucherAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: VoucherSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VoucherMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VoucherMaxAggregateInputType
  }

  export type GetVoucherAggregateType<T extends VoucherAggregateArgs> = {
        [P in keyof T & keyof AggregateVoucher]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVoucher[P]>
      : GetScalarType<T[P], AggregateVoucher[P]>
  }




  export type VoucherGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VoucherWhereInput
    orderBy?: VoucherOrderByWithAggregationInput | VoucherOrderByWithAggregationInput[]
    by: VoucherScalarFieldEnum[] | VoucherScalarFieldEnum
    having?: VoucherScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VoucherCountAggregateInputType | true
    _avg?: VoucherAvgAggregateInputType
    _sum?: VoucherSumAggregateInputType
    _min?: VoucherMinAggregateInputType
    _max?: VoucherMaxAggregateInputType
  }

  export type VoucherGroupByOutputType = {
    id: string
    code: string
    description: string | null
    type: $Enums.PromoType
    value: number
    usageLimit: number | null
    usedCount: number
    isActive: boolean
    startDate: Date
    endDate: Date
    createdAt: Date
    updatedAt: Date
    _count: VoucherCountAggregateOutputType | null
    _avg: VoucherAvgAggregateOutputType | null
    _sum: VoucherSumAggregateOutputType | null
    _min: VoucherMinAggregateOutputType | null
    _max: VoucherMaxAggregateOutputType | null
  }

  type GetVoucherGroupByPayload<T extends VoucherGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VoucherGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VoucherGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VoucherGroupByOutputType[P]>
            : GetScalarType<T[P], VoucherGroupByOutputType[P]>
        }
      >
    >


  export type VoucherSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    description?: boolean
    type?: boolean
    value?: boolean
    usageLimit?: boolean
    usedCount?: boolean
    isActive?: boolean
    startDate?: boolean
    endDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    products?: boolean | Voucher$productsArgs<ExtArgs>
    usages?: boolean | Voucher$usagesArgs<ExtArgs>
    orders?: boolean | Voucher$ordersArgs<ExtArgs>
    _count?: boolean | VoucherCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["voucher"]>

  export type VoucherSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    description?: boolean
    type?: boolean
    value?: boolean
    usageLimit?: boolean
    usedCount?: boolean
    isActive?: boolean
    startDate?: boolean
    endDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["voucher"]>

  export type VoucherSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    description?: boolean
    type?: boolean
    value?: boolean
    usageLimit?: boolean
    usedCount?: boolean
    isActive?: boolean
    startDate?: boolean
    endDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["voucher"]>

  export type VoucherSelectScalar = {
    id?: boolean
    code?: boolean
    description?: boolean
    type?: boolean
    value?: boolean
    usageLimit?: boolean
    usedCount?: boolean
    isActive?: boolean
    startDate?: boolean
    endDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type VoucherOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "code" | "description" | "type" | "value" | "usageLimit" | "usedCount" | "isActive" | "startDate" | "endDate" | "createdAt" | "updatedAt", ExtArgs["result"]["voucher"]>
  export type VoucherInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    products?: boolean | Voucher$productsArgs<ExtArgs>
    usages?: boolean | Voucher$usagesArgs<ExtArgs>
    orders?: boolean | Voucher$ordersArgs<ExtArgs>
    _count?: boolean | VoucherCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type VoucherIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type VoucherIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $VoucherPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Voucher"
    objects: {
      products: Prisma.$ProductPayload<ExtArgs>[]
      usages: Prisma.$VoucherUsagePayload<ExtArgs>[]
      orders: Prisma.$OrderPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      code: string
      description: string | null
      type: $Enums.PromoType
      value: number
      usageLimit: number | null
      usedCount: number
      isActive: boolean
      startDate: Date
      endDate: Date
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["voucher"]>
    composites: {}
  }

  type VoucherGetPayload<S extends boolean | null | undefined | VoucherDefaultArgs> = $Result.GetResult<Prisma.$VoucherPayload, S>

  type VoucherCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VoucherFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VoucherCountAggregateInputType | true
    }

  export interface VoucherDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Voucher'], meta: { name: 'Voucher' } }
    /**
     * Find zero or one Voucher that matches the filter.
     * @param {VoucherFindUniqueArgs} args - Arguments to find a Voucher
     * @example
     * // Get one Voucher
     * const voucher = await prisma.voucher.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VoucherFindUniqueArgs>(args: SelectSubset<T, VoucherFindUniqueArgs<ExtArgs>>): Prisma__VoucherClient<$Result.GetResult<Prisma.$VoucherPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Voucher that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VoucherFindUniqueOrThrowArgs} args - Arguments to find a Voucher
     * @example
     * // Get one Voucher
     * const voucher = await prisma.voucher.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VoucherFindUniqueOrThrowArgs>(args: SelectSubset<T, VoucherFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VoucherClient<$Result.GetResult<Prisma.$VoucherPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Voucher that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VoucherFindFirstArgs} args - Arguments to find a Voucher
     * @example
     * // Get one Voucher
     * const voucher = await prisma.voucher.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VoucherFindFirstArgs>(args?: SelectSubset<T, VoucherFindFirstArgs<ExtArgs>>): Prisma__VoucherClient<$Result.GetResult<Prisma.$VoucherPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Voucher that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VoucherFindFirstOrThrowArgs} args - Arguments to find a Voucher
     * @example
     * // Get one Voucher
     * const voucher = await prisma.voucher.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VoucherFindFirstOrThrowArgs>(args?: SelectSubset<T, VoucherFindFirstOrThrowArgs<ExtArgs>>): Prisma__VoucherClient<$Result.GetResult<Prisma.$VoucherPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Vouchers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VoucherFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Vouchers
     * const vouchers = await prisma.voucher.findMany()
     * 
     * // Get first 10 Vouchers
     * const vouchers = await prisma.voucher.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const voucherWithIdOnly = await prisma.voucher.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VoucherFindManyArgs>(args?: SelectSubset<T, VoucherFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VoucherPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Voucher.
     * @param {VoucherCreateArgs} args - Arguments to create a Voucher.
     * @example
     * // Create one Voucher
     * const Voucher = await prisma.voucher.create({
     *   data: {
     *     // ... data to create a Voucher
     *   }
     * })
     * 
     */
    create<T extends VoucherCreateArgs>(args: SelectSubset<T, VoucherCreateArgs<ExtArgs>>): Prisma__VoucherClient<$Result.GetResult<Prisma.$VoucherPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Vouchers.
     * @param {VoucherCreateManyArgs} args - Arguments to create many Vouchers.
     * @example
     * // Create many Vouchers
     * const voucher = await prisma.voucher.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VoucherCreateManyArgs>(args?: SelectSubset<T, VoucherCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Vouchers and returns the data saved in the database.
     * @param {VoucherCreateManyAndReturnArgs} args - Arguments to create many Vouchers.
     * @example
     * // Create many Vouchers
     * const voucher = await prisma.voucher.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Vouchers and only return the `id`
     * const voucherWithIdOnly = await prisma.voucher.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VoucherCreateManyAndReturnArgs>(args?: SelectSubset<T, VoucherCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VoucherPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Voucher.
     * @param {VoucherDeleteArgs} args - Arguments to delete one Voucher.
     * @example
     * // Delete one Voucher
     * const Voucher = await prisma.voucher.delete({
     *   where: {
     *     // ... filter to delete one Voucher
     *   }
     * })
     * 
     */
    delete<T extends VoucherDeleteArgs>(args: SelectSubset<T, VoucherDeleteArgs<ExtArgs>>): Prisma__VoucherClient<$Result.GetResult<Prisma.$VoucherPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Voucher.
     * @param {VoucherUpdateArgs} args - Arguments to update one Voucher.
     * @example
     * // Update one Voucher
     * const voucher = await prisma.voucher.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VoucherUpdateArgs>(args: SelectSubset<T, VoucherUpdateArgs<ExtArgs>>): Prisma__VoucherClient<$Result.GetResult<Prisma.$VoucherPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Vouchers.
     * @param {VoucherDeleteManyArgs} args - Arguments to filter Vouchers to delete.
     * @example
     * // Delete a few Vouchers
     * const { count } = await prisma.voucher.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VoucherDeleteManyArgs>(args?: SelectSubset<T, VoucherDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Vouchers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VoucherUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Vouchers
     * const voucher = await prisma.voucher.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VoucherUpdateManyArgs>(args: SelectSubset<T, VoucherUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Vouchers and returns the data updated in the database.
     * @param {VoucherUpdateManyAndReturnArgs} args - Arguments to update many Vouchers.
     * @example
     * // Update many Vouchers
     * const voucher = await prisma.voucher.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Vouchers and only return the `id`
     * const voucherWithIdOnly = await prisma.voucher.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends VoucherUpdateManyAndReturnArgs>(args: SelectSubset<T, VoucherUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VoucherPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Voucher.
     * @param {VoucherUpsertArgs} args - Arguments to update or create a Voucher.
     * @example
     * // Update or create a Voucher
     * const voucher = await prisma.voucher.upsert({
     *   create: {
     *     // ... data to create a Voucher
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Voucher we want to update
     *   }
     * })
     */
    upsert<T extends VoucherUpsertArgs>(args: SelectSubset<T, VoucherUpsertArgs<ExtArgs>>): Prisma__VoucherClient<$Result.GetResult<Prisma.$VoucherPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Vouchers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VoucherCountArgs} args - Arguments to filter Vouchers to count.
     * @example
     * // Count the number of Vouchers
     * const count = await prisma.voucher.count({
     *   where: {
     *     // ... the filter for the Vouchers we want to count
     *   }
     * })
    **/
    count<T extends VoucherCountArgs>(
      args?: Subset<T, VoucherCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VoucherCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Voucher.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VoucherAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VoucherAggregateArgs>(args: Subset<T, VoucherAggregateArgs>): Prisma.PrismaPromise<GetVoucherAggregateType<T>>

    /**
     * Group by Voucher.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VoucherGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VoucherGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VoucherGroupByArgs['orderBy'] }
        : { orderBy?: VoucherGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VoucherGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVoucherGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Voucher model
   */
  readonly fields: VoucherFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Voucher.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VoucherClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    products<T extends Voucher$productsArgs<ExtArgs> = {}>(args?: Subset<T, Voucher$productsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    usages<T extends Voucher$usagesArgs<ExtArgs> = {}>(args?: Subset<T, Voucher$usagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VoucherUsagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    orders<T extends Voucher$ordersArgs<ExtArgs> = {}>(args?: Subset<T, Voucher$ordersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Voucher model
   */
  interface VoucherFieldRefs {
    readonly id: FieldRef<"Voucher", 'String'>
    readonly code: FieldRef<"Voucher", 'String'>
    readonly description: FieldRef<"Voucher", 'String'>
    readonly type: FieldRef<"Voucher", 'PromoType'>
    readonly value: FieldRef<"Voucher", 'Float'>
    readonly usageLimit: FieldRef<"Voucher", 'Int'>
    readonly usedCount: FieldRef<"Voucher", 'Int'>
    readonly isActive: FieldRef<"Voucher", 'Boolean'>
    readonly startDate: FieldRef<"Voucher", 'DateTime'>
    readonly endDate: FieldRef<"Voucher", 'DateTime'>
    readonly createdAt: FieldRef<"Voucher", 'DateTime'>
    readonly updatedAt: FieldRef<"Voucher", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Voucher findUnique
   */
  export type VoucherFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Voucher
     */
    select?: VoucherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Voucher
     */
    omit?: VoucherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoucherInclude<ExtArgs> | null
    /**
     * Filter, which Voucher to fetch.
     */
    where: VoucherWhereUniqueInput
  }

  /**
   * Voucher findUniqueOrThrow
   */
  export type VoucherFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Voucher
     */
    select?: VoucherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Voucher
     */
    omit?: VoucherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoucherInclude<ExtArgs> | null
    /**
     * Filter, which Voucher to fetch.
     */
    where: VoucherWhereUniqueInput
  }

  /**
   * Voucher findFirst
   */
  export type VoucherFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Voucher
     */
    select?: VoucherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Voucher
     */
    omit?: VoucherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoucherInclude<ExtArgs> | null
    /**
     * Filter, which Voucher to fetch.
     */
    where?: VoucherWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Vouchers to fetch.
     */
    orderBy?: VoucherOrderByWithRelationInput | VoucherOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Vouchers.
     */
    cursor?: VoucherWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Vouchers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Vouchers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Vouchers.
     */
    distinct?: VoucherScalarFieldEnum | VoucherScalarFieldEnum[]
  }

  /**
   * Voucher findFirstOrThrow
   */
  export type VoucherFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Voucher
     */
    select?: VoucherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Voucher
     */
    omit?: VoucherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoucherInclude<ExtArgs> | null
    /**
     * Filter, which Voucher to fetch.
     */
    where?: VoucherWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Vouchers to fetch.
     */
    orderBy?: VoucherOrderByWithRelationInput | VoucherOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Vouchers.
     */
    cursor?: VoucherWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Vouchers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Vouchers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Vouchers.
     */
    distinct?: VoucherScalarFieldEnum | VoucherScalarFieldEnum[]
  }

  /**
   * Voucher findMany
   */
  export type VoucherFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Voucher
     */
    select?: VoucherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Voucher
     */
    omit?: VoucherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoucherInclude<ExtArgs> | null
    /**
     * Filter, which Vouchers to fetch.
     */
    where?: VoucherWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Vouchers to fetch.
     */
    orderBy?: VoucherOrderByWithRelationInput | VoucherOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Vouchers.
     */
    cursor?: VoucherWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Vouchers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Vouchers.
     */
    skip?: number
    distinct?: VoucherScalarFieldEnum | VoucherScalarFieldEnum[]
  }

  /**
   * Voucher create
   */
  export type VoucherCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Voucher
     */
    select?: VoucherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Voucher
     */
    omit?: VoucherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoucherInclude<ExtArgs> | null
    /**
     * The data needed to create a Voucher.
     */
    data: XOR<VoucherCreateInput, VoucherUncheckedCreateInput>
  }

  /**
   * Voucher createMany
   */
  export type VoucherCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Vouchers.
     */
    data: VoucherCreateManyInput | VoucherCreateManyInput[]
  }

  /**
   * Voucher createManyAndReturn
   */
  export type VoucherCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Voucher
     */
    select?: VoucherSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Voucher
     */
    omit?: VoucherOmit<ExtArgs> | null
    /**
     * The data used to create many Vouchers.
     */
    data: VoucherCreateManyInput | VoucherCreateManyInput[]
  }

  /**
   * Voucher update
   */
  export type VoucherUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Voucher
     */
    select?: VoucherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Voucher
     */
    omit?: VoucherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoucherInclude<ExtArgs> | null
    /**
     * The data needed to update a Voucher.
     */
    data: XOR<VoucherUpdateInput, VoucherUncheckedUpdateInput>
    /**
     * Choose, which Voucher to update.
     */
    where: VoucherWhereUniqueInput
  }

  /**
   * Voucher updateMany
   */
  export type VoucherUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Vouchers.
     */
    data: XOR<VoucherUpdateManyMutationInput, VoucherUncheckedUpdateManyInput>
    /**
     * Filter which Vouchers to update
     */
    where?: VoucherWhereInput
    /**
     * Limit how many Vouchers to update.
     */
    limit?: number
  }

  /**
   * Voucher updateManyAndReturn
   */
  export type VoucherUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Voucher
     */
    select?: VoucherSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Voucher
     */
    omit?: VoucherOmit<ExtArgs> | null
    /**
     * The data used to update Vouchers.
     */
    data: XOR<VoucherUpdateManyMutationInput, VoucherUncheckedUpdateManyInput>
    /**
     * Filter which Vouchers to update
     */
    where?: VoucherWhereInput
    /**
     * Limit how many Vouchers to update.
     */
    limit?: number
  }

  /**
   * Voucher upsert
   */
  export type VoucherUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Voucher
     */
    select?: VoucherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Voucher
     */
    omit?: VoucherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoucherInclude<ExtArgs> | null
    /**
     * The filter to search for the Voucher to update in case it exists.
     */
    where: VoucherWhereUniqueInput
    /**
     * In case the Voucher found by the `where` argument doesn't exist, create a new Voucher with this data.
     */
    create: XOR<VoucherCreateInput, VoucherUncheckedCreateInput>
    /**
     * In case the Voucher was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VoucherUpdateInput, VoucherUncheckedUpdateInput>
  }

  /**
   * Voucher delete
   */
  export type VoucherDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Voucher
     */
    select?: VoucherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Voucher
     */
    omit?: VoucherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoucherInclude<ExtArgs> | null
    /**
     * Filter which Voucher to delete.
     */
    where: VoucherWhereUniqueInput
  }

  /**
   * Voucher deleteMany
   */
  export type VoucherDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Vouchers to delete
     */
    where?: VoucherWhereInput
    /**
     * Limit how many Vouchers to delete.
     */
    limit?: number
  }

  /**
   * Voucher.products
   */
  export type Voucher$productsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    where?: ProductWhereInput
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    cursor?: ProductWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Voucher.usages
   */
  export type Voucher$usagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VoucherUsage
     */
    select?: VoucherUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VoucherUsage
     */
    omit?: VoucherUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoucherUsageInclude<ExtArgs> | null
    where?: VoucherUsageWhereInput
    orderBy?: VoucherUsageOrderByWithRelationInput | VoucherUsageOrderByWithRelationInput[]
    cursor?: VoucherUsageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VoucherUsageScalarFieldEnum | VoucherUsageScalarFieldEnum[]
  }

  /**
   * Voucher.orders
   */
  export type Voucher$ordersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    where?: OrderWhereInput
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    cursor?: OrderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * Voucher without action
   */
  export type VoucherDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Voucher
     */
    select?: VoucherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Voucher
     */
    omit?: VoucherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoucherInclude<ExtArgs> | null
  }


  /**
   * Model VoucherUsage
   */

  export type AggregateVoucherUsage = {
    _count: VoucherUsageCountAggregateOutputType | null
    _min: VoucherUsageMinAggregateOutputType | null
    _max: VoucherUsageMaxAggregateOutputType | null
  }

  export type VoucherUsageMinAggregateOutputType = {
    id: string | null
    voucherId: string | null
    userId: string | null
    usedAt: Date | null
  }

  export type VoucherUsageMaxAggregateOutputType = {
    id: string | null
    voucherId: string | null
    userId: string | null
    usedAt: Date | null
  }

  export type VoucherUsageCountAggregateOutputType = {
    id: number
    voucherId: number
    userId: number
    usedAt: number
    _all: number
  }


  export type VoucherUsageMinAggregateInputType = {
    id?: true
    voucherId?: true
    userId?: true
    usedAt?: true
  }

  export type VoucherUsageMaxAggregateInputType = {
    id?: true
    voucherId?: true
    userId?: true
    usedAt?: true
  }

  export type VoucherUsageCountAggregateInputType = {
    id?: true
    voucherId?: true
    userId?: true
    usedAt?: true
    _all?: true
  }

  export type VoucherUsageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VoucherUsage to aggregate.
     */
    where?: VoucherUsageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VoucherUsages to fetch.
     */
    orderBy?: VoucherUsageOrderByWithRelationInput | VoucherUsageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VoucherUsageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VoucherUsages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VoucherUsages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned VoucherUsages
    **/
    _count?: true | VoucherUsageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VoucherUsageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VoucherUsageMaxAggregateInputType
  }

  export type GetVoucherUsageAggregateType<T extends VoucherUsageAggregateArgs> = {
        [P in keyof T & keyof AggregateVoucherUsage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVoucherUsage[P]>
      : GetScalarType<T[P], AggregateVoucherUsage[P]>
  }




  export type VoucherUsageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VoucherUsageWhereInput
    orderBy?: VoucherUsageOrderByWithAggregationInput | VoucherUsageOrderByWithAggregationInput[]
    by: VoucherUsageScalarFieldEnum[] | VoucherUsageScalarFieldEnum
    having?: VoucherUsageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VoucherUsageCountAggregateInputType | true
    _min?: VoucherUsageMinAggregateInputType
    _max?: VoucherUsageMaxAggregateInputType
  }

  export type VoucherUsageGroupByOutputType = {
    id: string
    voucherId: string
    userId: string
    usedAt: Date
    _count: VoucherUsageCountAggregateOutputType | null
    _min: VoucherUsageMinAggregateOutputType | null
    _max: VoucherUsageMaxAggregateOutputType | null
  }

  type GetVoucherUsageGroupByPayload<T extends VoucherUsageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VoucherUsageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VoucherUsageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VoucherUsageGroupByOutputType[P]>
            : GetScalarType<T[P], VoucherUsageGroupByOutputType[P]>
        }
      >
    >


  export type VoucherUsageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    voucherId?: boolean
    userId?: boolean
    usedAt?: boolean
    voucher?: boolean | VoucherDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["voucherUsage"]>

  export type VoucherUsageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    voucherId?: boolean
    userId?: boolean
    usedAt?: boolean
    voucher?: boolean | VoucherDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["voucherUsage"]>

  export type VoucherUsageSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    voucherId?: boolean
    userId?: boolean
    usedAt?: boolean
    voucher?: boolean | VoucherDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["voucherUsage"]>

  export type VoucherUsageSelectScalar = {
    id?: boolean
    voucherId?: boolean
    userId?: boolean
    usedAt?: boolean
  }

  export type VoucherUsageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "voucherId" | "userId" | "usedAt", ExtArgs["result"]["voucherUsage"]>
  export type VoucherUsageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    voucher?: boolean | VoucherDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type VoucherUsageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    voucher?: boolean | VoucherDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type VoucherUsageIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    voucher?: boolean | VoucherDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $VoucherUsagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "VoucherUsage"
    objects: {
      voucher: Prisma.$VoucherPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      voucherId: string
      userId: string
      usedAt: Date
    }, ExtArgs["result"]["voucherUsage"]>
    composites: {}
  }

  type VoucherUsageGetPayload<S extends boolean | null | undefined | VoucherUsageDefaultArgs> = $Result.GetResult<Prisma.$VoucherUsagePayload, S>

  type VoucherUsageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VoucherUsageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VoucherUsageCountAggregateInputType | true
    }

  export interface VoucherUsageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['VoucherUsage'], meta: { name: 'VoucherUsage' } }
    /**
     * Find zero or one VoucherUsage that matches the filter.
     * @param {VoucherUsageFindUniqueArgs} args - Arguments to find a VoucherUsage
     * @example
     * // Get one VoucherUsage
     * const voucherUsage = await prisma.voucherUsage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VoucherUsageFindUniqueArgs>(args: SelectSubset<T, VoucherUsageFindUniqueArgs<ExtArgs>>): Prisma__VoucherUsageClient<$Result.GetResult<Prisma.$VoucherUsagePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one VoucherUsage that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VoucherUsageFindUniqueOrThrowArgs} args - Arguments to find a VoucherUsage
     * @example
     * // Get one VoucherUsage
     * const voucherUsage = await prisma.voucherUsage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VoucherUsageFindUniqueOrThrowArgs>(args: SelectSubset<T, VoucherUsageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VoucherUsageClient<$Result.GetResult<Prisma.$VoucherUsagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VoucherUsage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VoucherUsageFindFirstArgs} args - Arguments to find a VoucherUsage
     * @example
     * // Get one VoucherUsage
     * const voucherUsage = await prisma.voucherUsage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VoucherUsageFindFirstArgs>(args?: SelectSubset<T, VoucherUsageFindFirstArgs<ExtArgs>>): Prisma__VoucherUsageClient<$Result.GetResult<Prisma.$VoucherUsagePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VoucherUsage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VoucherUsageFindFirstOrThrowArgs} args - Arguments to find a VoucherUsage
     * @example
     * // Get one VoucherUsage
     * const voucherUsage = await prisma.voucherUsage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VoucherUsageFindFirstOrThrowArgs>(args?: SelectSubset<T, VoucherUsageFindFirstOrThrowArgs<ExtArgs>>): Prisma__VoucherUsageClient<$Result.GetResult<Prisma.$VoucherUsagePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more VoucherUsages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VoucherUsageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VoucherUsages
     * const voucherUsages = await prisma.voucherUsage.findMany()
     * 
     * // Get first 10 VoucherUsages
     * const voucherUsages = await prisma.voucherUsage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const voucherUsageWithIdOnly = await prisma.voucherUsage.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VoucherUsageFindManyArgs>(args?: SelectSubset<T, VoucherUsageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VoucherUsagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a VoucherUsage.
     * @param {VoucherUsageCreateArgs} args - Arguments to create a VoucherUsage.
     * @example
     * // Create one VoucherUsage
     * const VoucherUsage = await prisma.voucherUsage.create({
     *   data: {
     *     // ... data to create a VoucherUsage
     *   }
     * })
     * 
     */
    create<T extends VoucherUsageCreateArgs>(args: SelectSubset<T, VoucherUsageCreateArgs<ExtArgs>>): Prisma__VoucherUsageClient<$Result.GetResult<Prisma.$VoucherUsagePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many VoucherUsages.
     * @param {VoucherUsageCreateManyArgs} args - Arguments to create many VoucherUsages.
     * @example
     * // Create many VoucherUsages
     * const voucherUsage = await prisma.voucherUsage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VoucherUsageCreateManyArgs>(args?: SelectSubset<T, VoucherUsageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many VoucherUsages and returns the data saved in the database.
     * @param {VoucherUsageCreateManyAndReturnArgs} args - Arguments to create many VoucherUsages.
     * @example
     * // Create many VoucherUsages
     * const voucherUsage = await prisma.voucherUsage.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many VoucherUsages and only return the `id`
     * const voucherUsageWithIdOnly = await prisma.voucherUsage.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VoucherUsageCreateManyAndReturnArgs>(args?: SelectSubset<T, VoucherUsageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VoucherUsagePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a VoucherUsage.
     * @param {VoucherUsageDeleteArgs} args - Arguments to delete one VoucherUsage.
     * @example
     * // Delete one VoucherUsage
     * const VoucherUsage = await prisma.voucherUsage.delete({
     *   where: {
     *     // ... filter to delete one VoucherUsage
     *   }
     * })
     * 
     */
    delete<T extends VoucherUsageDeleteArgs>(args: SelectSubset<T, VoucherUsageDeleteArgs<ExtArgs>>): Prisma__VoucherUsageClient<$Result.GetResult<Prisma.$VoucherUsagePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one VoucherUsage.
     * @param {VoucherUsageUpdateArgs} args - Arguments to update one VoucherUsage.
     * @example
     * // Update one VoucherUsage
     * const voucherUsage = await prisma.voucherUsage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VoucherUsageUpdateArgs>(args: SelectSubset<T, VoucherUsageUpdateArgs<ExtArgs>>): Prisma__VoucherUsageClient<$Result.GetResult<Prisma.$VoucherUsagePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more VoucherUsages.
     * @param {VoucherUsageDeleteManyArgs} args - Arguments to filter VoucherUsages to delete.
     * @example
     * // Delete a few VoucherUsages
     * const { count } = await prisma.voucherUsage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VoucherUsageDeleteManyArgs>(args?: SelectSubset<T, VoucherUsageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VoucherUsages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VoucherUsageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VoucherUsages
     * const voucherUsage = await prisma.voucherUsage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VoucherUsageUpdateManyArgs>(args: SelectSubset<T, VoucherUsageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VoucherUsages and returns the data updated in the database.
     * @param {VoucherUsageUpdateManyAndReturnArgs} args - Arguments to update many VoucherUsages.
     * @example
     * // Update many VoucherUsages
     * const voucherUsage = await prisma.voucherUsage.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more VoucherUsages and only return the `id`
     * const voucherUsageWithIdOnly = await prisma.voucherUsage.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends VoucherUsageUpdateManyAndReturnArgs>(args: SelectSubset<T, VoucherUsageUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VoucherUsagePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one VoucherUsage.
     * @param {VoucherUsageUpsertArgs} args - Arguments to update or create a VoucherUsage.
     * @example
     * // Update or create a VoucherUsage
     * const voucherUsage = await prisma.voucherUsage.upsert({
     *   create: {
     *     // ... data to create a VoucherUsage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VoucherUsage we want to update
     *   }
     * })
     */
    upsert<T extends VoucherUsageUpsertArgs>(args: SelectSubset<T, VoucherUsageUpsertArgs<ExtArgs>>): Prisma__VoucherUsageClient<$Result.GetResult<Prisma.$VoucherUsagePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of VoucherUsages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VoucherUsageCountArgs} args - Arguments to filter VoucherUsages to count.
     * @example
     * // Count the number of VoucherUsages
     * const count = await prisma.voucherUsage.count({
     *   where: {
     *     // ... the filter for the VoucherUsages we want to count
     *   }
     * })
    **/
    count<T extends VoucherUsageCountArgs>(
      args?: Subset<T, VoucherUsageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VoucherUsageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a VoucherUsage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VoucherUsageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VoucherUsageAggregateArgs>(args: Subset<T, VoucherUsageAggregateArgs>): Prisma.PrismaPromise<GetVoucherUsageAggregateType<T>>

    /**
     * Group by VoucherUsage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VoucherUsageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VoucherUsageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VoucherUsageGroupByArgs['orderBy'] }
        : { orderBy?: VoucherUsageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VoucherUsageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVoucherUsageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the VoucherUsage model
   */
  readonly fields: VoucherUsageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for VoucherUsage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VoucherUsageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    voucher<T extends VoucherDefaultArgs<ExtArgs> = {}>(args?: Subset<T, VoucherDefaultArgs<ExtArgs>>): Prisma__VoucherClient<$Result.GetResult<Prisma.$VoucherPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the VoucherUsage model
   */
  interface VoucherUsageFieldRefs {
    readonly id: FieldRef<"VoucherUsage", 'String'>
    readonly voucherId: FieldRef<"VoucherUsage", 'String'>
    readonly userId: FieldRef<"VoucherUsage", 'String'>
    readonly usedAt: FieldRef<"VoucherUsage", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * VoucherUsage findUnique
   */
  export type VoucherUsageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VoucherUsage
     */
    select?: VoucherUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VoucherUsage
     */
    omit?: VoucherUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoucherUsageInclude<ExtArgs> | null
    /**
     * Filter, which VoucherUsage to fetch.
     */
    where: VoucherUsageWhereUniqueInput
  }

  /**
   * VoucherUsage findUniqueOrThrow
   */
  export type VoucherUsageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VoucherUsage
     */
    select?: VoucherUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VoucherUsage
     */
    omit?: VoucherUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoucherUsageInclude<ExtArgs> | null
    /**
     * Filter, which VoucherUsage to fetch.
     */
    where: VoucherUsageWhereUniqueInput
  }

  /**
   * VoucherUsage findFirst
   */
  export type VoucherUsageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VoucherUsage
     */
    select?: VoucherUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VoucherUsage
     */
    omit?: VoucherUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoucherUsageInclude<ExtArgs> | null
    /**
     * Filter, which VoucherUsage to fetch.
     */
    where?: VoucherUsageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VoucherUsages to fetch.
     */
    orderBy?: VoucherUsageOrderByWithRelationInput | VoucherUsageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VoucherUsages.
     */
    cursor?: VoucherUsageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VoucherUsages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VoucherUsages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VoucherUsages.
     */
    distinct?: VoucherUsageScalarFieldEnum | VoucherUsageScalarFieldEnum[]
  }

  /**
   * VoucherUsage findFirstOrThrow
   */
  export type VoucherUsageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VoucherUsage
     */
    select?: VoucherUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VoucherUsage
     */
    omit?: VoucherUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoucherUsageInclude<ExtArgs> | null
    /**
     * Filter, which VoucherUsage to fetch.
     */
    where?: VoucherUsageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VoucherUsages to fetch.
     */
    orderBy?: VoucherUsageOrderByWithRelationInput | VoucherUsageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VoucherUsages.
     */
    cursor?: VoucherUsageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VoucherUsages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VoucherUsages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VoucherUsages.
     */
    distinct?: VoucherUsageScalarFieldEnum | VoucherUsageScalarFieldEnum[]
  }

  /**
   * VoucherUsage findMany
   */
  export type VoucherUsageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VoucherUsage
     */
    select?: VoucherUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VoucherUsage
     */
    omit?: VoucherUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoucherUsageInclude<ExtArgs> | null
    /**
     * Filter, which VoucherUsages to fetch.
     */
    where?: VoucherUsageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VoucherUsages to fetch.
     */
    orderBy?: VoucherUsageOrderByWithRelationInput | VoucherUsageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing VoucherUsages.
     */
    cursor?: VoucherUsageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VoucherUsages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VoucherUsages.
     */
    skip?: number
    distinct?: VoucherUsageScalarFieldEnum | VoucherUsageScalarFieldEnum[]
  }

  /**
   * VoucherUsage create
   */
  export type VoucherUsageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VoucherUsage
     */
    select?: VoucherUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VoucherUsage
     */
    omit?: VoucherUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoucherUsageInclude<ExtArgs> | null
    /**
     * The data needed to create a VoucherUsage.
     */
    data: XOR<VoucherUsageCreateInput, VoucherUsageUncheckedCreateInput>
  }

  /**
   * VoucherUsage createMany
   */
  export type VoucherUsageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many VoucherUsages.
     */
    data: VoucherUsageCreateManyInput | VoucherUsageCreateManyInput[]
  }

  /**
   * VoucherUsage createManyAndReturn
   */
  export type VoucherUsageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VoucherUsage
     */
    select?: VoucherUsageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VoucherUsage
     */
    omit?: VoucherUsageOmit<ExtArgs> | null
    /**
     * The data used to create many VoucherUsages.
     */
    data: VoucherUsageCreateManyInput | VoucherUsageCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoucherUsageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * VoucherUsage update
   */
  export type VoucherUsageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VoucherUsage
     */
    select?: VoucherUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VoucherUsage
     */
    omit?: VoucherUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoucherUsageInclude<ExtArgs> | null
    /**
     * The data needed to update a VoucherUsage.
     */
    data: XOR<VoucherUsageUpdateInput, VoucherUsageUncheckedUpdateInput>
    /**
     * Choose, which VoucherUsage to update.
     */
    where: VoucherUsageWhereUniqueInput
  }

  /**
   * VoucherUsage updateMany
   */
  export type VoucherUsageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update VoucherUsages.
     */
    data: XOR<VoucherUsageUpdateManyMutationInput, VoucherUsageUncheckedUpdateManyInput>
    /**
     * Filter which VoucherUsages to update
     */
    where?: VoucherUsageWhereInput
    /**
     * Limit how many VoucherUsages to update.
     */
    limit?: number
  }

  /**
   * VoucherUsage updateManyAndReturn
   */
  export type VoucherUsageUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VoucherUsage
     */
    select?: VoucherUsageSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VoucherUsage
     */
    omit?: VoucherUsageOmit<ExtArgs> | null
    /**
     * The data used to update VoucherUsages.
     */
    data: XOR<VoucherUsageUpdateManyMutationInput, VoucherUsageUncheckedUpdateManyInput>
    /**
     * Filter which VoucherUsages to update
     */
    where?: VoucherUsageWhereInput
    /**
     * Limit how many VoucherUsages to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoucherUsageIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * VoucherUsage upsert
   */
  export type VoucherUsageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VoucherUsage
     */
    select?: VoucherUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VoucherUsage
     */
    omit?: VoucherUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoucherUsageInclude<ExtArgs> | null
    /**
     * The filter to search for the VoucherUsage to update in case it exists.
     */
    where: VoucherUsageWhereUniqueInput
    /**
     * In case the VoucherUsage found by the `where` argument doesn't exist, create a new VoucherUsage with this data.
     */
    create: XOR<VoucherUsageCreateInput, VoucherUsageUncheckedCreateInput>
    /**
     * In case the VoucherUsage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VoucherUsageUpdateInput, VoucherUsageUncheckedUpdateInput>
  }

  /**
   * VoucherUsage delete
   */
  export type VoucherUsageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VoucherUsage
     */
    select?: VoucherUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VoucherUsage
     */
    omit?: VoucherUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoucherUsageInclude<ExtArgs> | null
    /**
     * Filter which VoucherUsage to delete.
     */
    where: VoucherUsageWhereUniqueInput
  }

  /**
   * VoucherUsage deleteMany
   */
  export type VoucherUsageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VoucherUsages to delete
     */
    where?: VoucherUsageWhereInput
    /**
     * Limit how many VoucherUsages to delete.
     */
    limit?: number
  }

  /**
   * VoucherUsage without action
   */
  export type VoucherUsageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VoucherUsage
     */
    select?: VoucherUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VoucherUsage
     */
    omit?: VoucherUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoucherUsageInclude<ExtArgs> | null
  }


  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    firstName: string | null
    lastName: string | null
    name: string | null
    userName: string | null
    email: string | null
    password: string | null
    emailVerified: Date | null
    image: string | null
    role: $Enums.UserRole | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    firstName: string | null
    lastName: string | null
    name: string | null
    userName: string | null
    email: string | null
    password: string | null
    emailVerified: Date | null
    image: string | null
    role: $Enums.UserRole | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    firstName: number
    lastName: number
    name: number
    userName: number
    email: number
    password: number
    emailVerified: number
    image: number
    role: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    firstName?: true
    lastName?: true
    name?: true
    userName?: true
    email?: true
    password?: true
    emailVerified?: true
    image?: true
    role?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    firstName?: true
    lastName?: true
    name?: true
    userName?: true
    email?: true
    password?: true
    emailVerified?: true
    image?: true
    role?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    firstName?: true
    lastName?: true
    name?: true
    userName?: true
    email?: true
    password?: true
    emailVerified?: true
    image?: true
    role?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    firstName: string | null
    lastName: string | null
    name: string | null
    userName: string | null
    email: string
    password: string
    emailVerified: Date | null
    image: string | null
    role: $Enums.UserRole
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    firstName?: boolean
    lastName?: boolean
    name?: boolean
    userName?: boolean
    email?: boolean
    password?: boolean
    emailVerified?: boolean
    image?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    orders?: boolean | User$ordersArgs<ExtArgs>
    accounts?: boolean | User$accountsArgs<ExtArgs>
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    vouchers?: boolean | User$vouchersArgs<ExtArgs>
    Authenticator?: boolean | User$AuthenticatorArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    firstName?: boolean
    lastName?: boolean
    name?: boolean
    userName?: boolean
    email?: boolean
    password?: boolean
    emailVerified?: boolean
    image?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    firstName?: boolean
    lastName?: boolean
    name?: boolean
    userName?: boolean
    email?: boolean
    password?: boolean
    emailVerified?: boolean
    image?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    firstName?: boolean
    lastName?: boolean
    name?: boolean
    userName?: boolean
    email?: boolean
    password?: boolean
    emailVerified?: boolean
    image?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "firstName" | "lastName" | "name" | "userName" | "email" | "password" | "emailVerified" | "image" | "role" | "createdAt" | "updatedAt", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    orders?: boolean | User$ordersArgs<ExtArgs>
    accounts?: boolean | User$accountsArgs<ExtArgs>
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    vouchers?: boolean | User$vouchersArgs<ExtArgs>
    Authenticator?: boolean | User$AuthenticatorArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      orders: Prisma.$OrderPayload<ExtArgs>[]
      accounts: Prisma.$AccountPayload<ExtArgs>[]
      sessions: Prisma.$SessionPayload<ExtArgs>[]
      vouchers: Prisma.$VoucherUsagePayload<ExtArgs>[]
      Authenticator: Prisma.$AuthenticatorPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      firstName: string | null
      lastName: string | null
      name: string | null
      userName: string | null
      email: string
      password: string
      emailVerified: Date | null
      image: string | null
      role: $Enums.UserRole
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    orders<T extends User$ordersArgs<ExtArgs> = {}>(args?: Subset<T, User$ordersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    accounts<T extends User$accountsArgs<ExtArgs> = {}>(args?: Subset<T, User$accountsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    sessions<T extends User$sessionsArgs<ExtArgs> = {}>(args?: Subset<T, User$sessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    vouchers<T extends User$vouchersArgs<ExtArgs> = {}>(args?: Subset<T, User$vouchersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VoucherUsagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Authenticator<T extends User$AuthenticatorArgs<ExtArgs> = {}>(args?: Subset<T, User$AuthenticatorArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuthenticatorPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly firstName: FieldRef<"User", 'String'>
    readonly lastName: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly userName: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly emailVerified: FieldRef<"User", 'DateTime'>
    readonly image: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'UserRole'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.orders
   */
  export type User$ordersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    where?: OrderWhereInput
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    cursor?: OrderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * User.accounts
   */
  export type User$accountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    where?: AccountWhereInput
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    cursor?: AccountWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * User.sessions
   */
  export type User$sessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    cursor?: SessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * User.vouchers
   */
  export type User$vouchersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VoucherUsage
     */
    select?: VoucherUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VoucherUsage
     */
    omit?: VoucherUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoucherUsageInclude<ExtArgs> | null
    where?: VoucherUsageWhereInput
    orderBy?: VoucherUsageOrderByWithRelationInput | VoucherUsageOrderByWithRelationInput[]
    cursor?: VoucherUsageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VoucherUsageScalarFieldEnum | VoucherUsageScalarFieldEnum[]
  }

  /**
   * User.Authenticator
   */
  export type User$AuthenticatorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Authenticator
     */
    select?: AuthenticatorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Authenticator
     */
    omit?: AuthenticatorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuthenticatorInclude<ExtArgs> | null
    where?: AuthenticatorWhereInput
    orderBy?: AuthenticatorOrderByWithRelationInput | AuthenticatorOrderByWithRelationInput[]
    cursor?: AuthenticatorWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AuthenticatorScalarFieldEnum | AuthenticatorScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Authenticator
   */

  export type AggregateAuthenticator = {
    _count: AuthenticatorCountAggregateOutputType | null
    _avg: AuthenticatorAvgAggregateOutputType | null
    _sum: AuthenticatorSumAggregateOutputType | null
    _min: AuthenticatorMinAggregateOutputType | null
    _max: AuthenticatorMaxAggregateOutputType | null
  }

  export type AuthenticatorAvgAggregateOutputType = {
    counter: number | null
  }

  export type AuthenticatorSumAggregateOutputType = {
    counter: number | null
  }

  export type AuthenticatorMinAggregateOutputType = {
    credentialID: string | null
    userId: string | null
    providerAccountId: string | null
    credentialPublicKey: string | null
    counter: number | null
    credentialDeviceType: string | null
    credentialBackedUp: boolean | null
    transports: string | null
  }

  export type AuthenticatorMaxAggregateOutputType = {
    credentialID: string | null
    userId: string | null
    providerAccountId: string | null
    credentialPublicKey: string | null
    counter: number | null
    credentialDeviceType: string | null
    credentialBackedUp: boolean | null
    transports: string | null
  }

  export type AuthenticatorCountAggregateOutputType = {
    credentialID: number
    userId: number
    providerAccountId: number
    credentialPublicKey: number
    counter: number
    credentialDeviceType: number
    credentialBackedUp: number
    transports: number
    _all: number
  }


  export type AuthenticatorAvgAggregateInputType = {
    counter?: true
  }

  export type AuthenticatorSumAggregateInputType = {
    counter?: true
  }

  export type AuthenticatorMinAggregateInputType = {
    credentialID?: true
    userId?: true
    providerAccountId?: true
    credentialPublicKey?: true
    counter?: true
    credentialDeviceType?: true
    credentialBackedUp?: true
    transports?: true
  }

  export type AuthenticatorMaxAggregateInputType = {
    credentialID?: true
    userId?: true
    providerAccountId?: true
    credentialPublicKey?: true
    counter?: true
    credentialDeviceType?: true
    credentialBackedUp?: true
    transports?: true
  }

  export type AuthenticatorCountAggregateInputType = {
    credentialID?: true
    userId?: true
    providerAccountId?: true
    credentialPublicKey?: true
    counter?: true
    credentialDeviceType?: true
    credentialBackedUp?: true
    transports?: true
    _all?: true
  }

  export type AuthenticatorAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Authenticator to aggregate.
     */
    where?: AuthenticatorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Authenticators to fetch.
     */
    orderBy?: AuthenticatorOrderByWithRelationInput | AuthenticatorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AuthenticatorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Authenticators from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Authenticators.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Authenticators
    **/
    _count?: true | AuthenticatorCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AuthenticatorAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AuthenticatorSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AuthenticatorMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AuthenticatorMaxAggregateInputType
  }

  export type GetAuthenticatorAggregateType<T extends AuthenticatorAggregateArgs> = {
        [P in keyof T & keyof AggregateAuthenticator]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAuthenticator[P]>
      : GetScalarType<T[P], AggregateAuthenticator[P]>
  }




  export type AuthenticatorGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuthenticatorWhereInput
    orderBy?: AuthenticatorOrderByWithAggregationInput | AuthenticatorOrderByWithAggregationInput[]
    by: AuthenticatorScalarFieldEnum[] | AuthenticatorScalarFieldEnum
    having?: AuthenticatorScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AuthenticatorCountAggregateInputType | true
    _avg?: AuthenticatorAvgAggregateInputType
    _sum?: AuthenticatorSumAggregateInputType
    _min?: AuthenticatorMinAggregateInputType
    _max?: AuthenticatorMaxAggregateInputType
  }

  export type AuthenticatorGroupByOutputType = {
    credentialID: string
    userId: string
    providerAccountId: string
    credentialPublicKey: string
    counter: number
    credentialDeviceType: string
    credentialBackedUp: boolean
    transports: string | null
    _count: AuthenticatorCountAggregateOutputType | null
    _avg: AuthenticatorAvgAggregateOutputType | null
    _sum: AuthenticatorSumAggregateOutputType | null
    _min: AuthenticatorMinAggregateOutputType | null
    _max: AuthenticatorMaxAggregateOutputType | null
  }

  type GetAuthenticatorGroupByPayload<T extends AuthenticatorGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AuthenticatorGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AuthenticatorGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AuthenticatorGroupByOutputType[P]>
            : GetScalarType<T[P], AuthenticatorGroupByOutputType[P]>
        }
      >
    >


  export type AuthenticatorSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    credentialID?: boolean
    userId?: boolean
    providerAccountId?: boolean
    credentialPublicKey?: boolean
    counter?: boolean
    credentialDeviceType?: boolean
    credentialBackedUp?: boolean
    transports?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["authenticator"]>

  export type AuthenticatorSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    credentialID?: boolean
    userId?: boolean
    providerAccountId?: boolean
    credentialPublicKey?: boolean
    counter?: boolean
    credentialDeviceType?: boolean
    credentialBackedUp?: boolean
    transports?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["authenticator"]>

  export type AuthenticatorSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    credentialID?: boolean
    userId?: boolean
    providerAccountId?: boolean
    credentialPublicKey?: boolean
    counter?: boolean
    credentialDeviceType?: boolean
    credentialBackedUp?: boolean
    transports?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["authenticator"]>

  export type AuthenticatorSelectScalar = {
    credentialID?: boolean
    userId?: boolean
    providerAccountId?: boolean
    credentialPublicKey?: boolean
    counter?: boolean
    credentialDeviceType?: boolean
    credentialBackedUp?: boolean
    transports?: boolean
  }

  export type AuthenticatorOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"credentialID" | "userId" | "providerAccountId" | "credentialPublicKey" | "counter" | "credentialDeviceType" | "credentialBackedUp" | "transports", ExtArgs["result"]["authenticator"]>
  export type AuthenticatorInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AuthenticatorIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AuthenticatorIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AuthenticatorPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Authenticator"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      credentialID: string
      userId: string
      providerAccountId: string
      credentialPublicKey: string
      counter: number
      credentialDeviceType: string
      credentialBackedUp: boolean
      transports: string | null
    }, ExtArgs["result"]["authenticator"]>
    composites: {}
  }

  type AuthenticatorGetPayload<S extends boolean | null | undefined | AuthenticatorDefaultArgs> = $Result.GetResult<Prisma.$AuthenticatorPayload, S>

  type AuthenticatorCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AuthenticatorFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AuthenticatorCountAggregateInputType | true
    }

  export interface AuthenticatorDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Authenticator'], meta: { name: 'Authenticator' } }
    /**
     * Find zero or one Authenticator that matches the filter.
     * @param {AuthenticatorFindUniqueArgs} args - Arguments to find a Authenticator
     * @example
     * // Get one Authenticator
     * const authenticator = await prisma.authenticator.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AuthenticatorFindUniqueArgs>(args: SelectSubset<T, AuthenticatorFindUniqueArgs<ExtArgs>>): Prisma__AuthenticatorClient<$Result.GetResult<Prisma.$AuthenticatorPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Authenticator that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AuthenticatorFindUniqueOrThrowArgs} args - Arguments to find a Authenticator
     * @example
     * // Get one Authenticator
     * const authenticator = await prisma.authenticator.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AuthenticatorFindUniqueOrThrowArgs>(args: SelectSubset<T, AuthenticatorFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AuthenticatorClient<$Result.GetResult<Prisma.$AuthenticatorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Authenticator that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuthenticatorFindFirstArgs} args - Arguments to find a Authenticator
     * @example
     * // Get one Authenticator
     * const authenticator = await prisma.authenticator.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AuthenticatorFindFirstArgs>(args?: SelectSubset<T, AuthenticatorFindFirstArgs<ExtArgs>>): Prisma__AuthenticatorClient<$Result.GetResult<Prisma.$AuthenticatorPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Authenticator that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuthenticatorFindFirstOrThrowArgs} args - Arguments to find a Authenticator
     * @example
     * // Get one Authenticator
     * const authenticator = await prisma.authenticator.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AuthenticatorFindFirstOrThrowArgs>(args?: SelectSubset<T, AuthenticatorFindFirstOrThrowArgs<ExtArgs>>): Prisma__AuthenticatorClient<$Result.GetResult<Prisma.$AuthenticatorPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Authenticators that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuthenticatorFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Authenticators
     * const authenticators = await prisma.authenticator.findMany()
     * 
     * // Get first 10 Authenticators
     * const authenticators = await prisma.authenticator.findMany({ take: 10 })
     * 
     * // Only select the `credentialID`
     * const authenticatorWithCredentialIDOnly = await prisma.authenticator.findMany({ select: { credentialID: true } })
     * 
     */
    findMany<T extends AuthenticatorFindManyArgs>(args?: SelectSubset<T, AuthenticatorFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuthenticatorPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Authenticator.
     * @param {AuthenticatorCreateArgs} args - Arguments to create a Authenticator.
     * @example
     * // Create one Authenticator
     * const Authenticator = await prisma.authenticator.create({
     *   data: {
     *     // ... data to create a Authenticator
     *   }
     * })
     * 
     */
    create<T extends AuthenticatorCreateArgs>(args: SelectSubset<T, AuthenticatorCreateArgs<ExtArgs>>): Prisma__AuthenticatorClient<$Result.GetResult<Prisma.$AuthenticatorPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Authenticators.
     * @param {AuthenticatorCreateManyArgs} args - Arguments to create many Authenticators.
     * @example
     * // Create many Authenticators
     * const authenticator = await prisma.authenticator.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AuthenticatorCreateManyArgs>(args?: SelectSubset<T, AuthenticatorCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Authenticators and returns the data saved in the database.
     * @param {AuthenticatorCreateManyAndReturnArgs} args - Arguments to create many Authenticators.
     * @example
     * // Create many Authenticators
     * const authenticator = await prisma.authenticator.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Authenticators and only return the `credentialID`
     * const authenticatorWithCredentialIDOnly = await prisma.authenticator.createManyAndReturn({
     *   select: { credentialID: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AuthenticatorCreateManyAndReturnArgs>(args?: SelectSubset<T, AuthenticatorCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuthenticatorPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Authenticator.
     * @param {AuthenticatorDeleteArgs} args - Arguments to delete one Authenticator.
     * @example
     * // Delete one Authenticator
     * const Authenticator = await prisma.authenticator.delete({
     *   where: {
     *     // ... filter to delete one Authenticator
     *   }
     * })
     * 
     */
    delete<T extends AuthenticatorDeleteArgs>(args: SelectSubset<T, AuthenticatorDeleteArgs<ExtArgs>>): Prisma__AuthenticatorClient<$Result.GetResult<Prisma.$AuthenticatorPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Authenticator.
     * @param {AuthenticatorUpdateArgs} args - Arguments to update one Authenticator.
     * @example
     * // Update one Authenticator
     * const authenticator = await prisma.authenticator.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AuthenticatorUpdateArgs>(args: SelectSubset<T, AuthenticatorUpdateArgs<ExtArgs>>): Prisma__AuthenticatorClient<$Result.GetResult<Prisma.$AuthenticatorPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Authenticators.
     * @param {AuthenticatorDeleteManyArgs} args - Arguments to filter Authenticators to delete.
     * @example
     * // Delete a few Authenticators
     * const { count } = await prisma.authenticator.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AuthenticatorDeleteManyArgs>(args?: SelectSubset<T, AuthenticatorDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Authenticators.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuthenticatorUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Authenticators
     * const authenticator = await prisma.authenticator.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AuthenticatorUpdateManyArgs>(args: SelectSubset<T, AuthenticatorUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Authenticators and returns the data updated in the database.
     * @param {AuthenticatorUpdateManyAndReturnArgs} args - Arguments to update many Authenticators.
     * @example
     * // Update many Authenticators
     * const authenticator = await prisma.authenticator.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Authenticators and only return the `credentialID`
     * const authenticatorWithCredentialIDOnly = await prisma.authenticator.updateManyAndReturn({
     *   select: { credentialID: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AuthenticatorUpdateManyAndReturnArgs>(args: SelectSubset<T, AuthenticatorUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuthenticatorPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Authenticator.
     * @param {AuthenticatorUpsertArgs} args - Arguments to update or create a Authenticator.
     * @example
     * // Update or create a Authenticator
     * const authenticator = await prisma.authenticator.upsert({
     *   create: {
     *     // ... data to create a Authenticator
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Authenticator we want to update
     *   }
     * })
     */
    upsert<T extends AuthenticatorUpsertArgs>(args: SelectSubset<T, AuthenticatorUpsertArgs<ExtArgs>>): Prisma__AuthenticatorClient<$Result.GetResult<Prisma.$AuthenticatorPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Authenticators.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuthenticatorCountArgs} args - Arguments to filter Authenticators to count.
     * @example
     * // Count the number of Authenticators
     * const count = await prisma.authenticator.count({
     *   where: {
     *     // ... the filter for the Authenticators we want to count
     *   }
     * })
    **/
    count<T extends AuthenticatorCountArgs>(
      args?: Subset<T, AuthenticatorCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AuthenticatorCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Authenticator.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuthenticatorAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AuthenticatorAggregateArgs>(args: Subset<T, AuthenticatorAggregateArgs>): Prisma.PrismaPromise<GetAuthenticatorAggregateType<T>>

    /**
     * Group by Authenticator.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuthenticatorGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AuthenticatorGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AuthenticatorGroupByArgs['orderBy'] }
        : { orderBy?: AuthenticatorGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AuthenticatorGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAuthenticatorGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Authenticator model
   */
  readonly fields: AuthenticatorFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Authenticator.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AuthenticatorClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Authenticator model
   */
  interface AuthenticatorFieldRefs {
    readonly credentialID: FieldRef<"Authenticator", 'String'>
    readonly userId: FieldRef<"Authenticator", 'String'>
    readonly providerAccountId: FieldRef<"Authenticator", 'String'>
    readonly credentialPublicKey: FieldRef<"Authenticator", 'String'>
    readonly counter: FieldRef<"Authenticator", 'Int'>
    readonly credentialDeviceType: FieldRef<"Authenticator", 'String'>
    readonly credentialBackedUp: FieldRef<"Authenticator", 'Boolean'>
    readonly transports: FieldRef<"Authenticator", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Authenticator findUnique
   */
  export type AuthenticatorFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Authenticator
     */
    select?: AuthenticatorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Authenticator
     */
    omit?: AuthenticatorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuthenticatorInclude<ExtArgs> | null
    /**
     * Filter, which Authenticator to fetch.
     */
    where: AuthenticatorWhereUniqueInput
  }

  /**
   * Authenticator findUniqueOrThrow
   */
  export type AuthenticatorFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Authenticator
     */
    select?: AuthenticatorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Authenticator
     */
    omit?: AuthenticatorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuthenticatorInclude<ExtArgs> | null
    /**
     * Filter, which Authenticator to fetch.
     */
    where: AuthenticatorWhereUniqueInput
  }

  /**
   * Authenticator findFirst
   */
  export type AuthenticatorFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Authenticator
     */
    select?: AuthenticatorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Authenticator
     */
    omit?: AuthenticatorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuthenticatorInclude<ExtArgs> | null
    /**
     * Filter, which Authenticator to fetch.
     */
    where?: AuthenticatorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Authenticators to fetch.
     */
    orderBy?: AuthenticatorOrderByWithRelationInput | AuthenticatorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Authenticators.
     */
    cursor?: AuthenticatorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Authenticators from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Authenticators.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Authenticators.
     */
    distinct?: AuthenticatorScalarFieldEnum | AuthenticatorScalarFieldEnum[]
  }

  /**
   * Authenticator findFirstOrThrow
   */
  export type AuthenticatorFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Authenticator
     */
    select?: AuthenticatorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Authenticator
     */
    omit?: AuthenticatorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuthenticatorInclude<ExtArgs> | null
    /**
     * Filter, which Authenticator to fetch.
     */
    where?: AuthenticatorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Authenticators to fetch.
     */
    orderBy?: AuthenticatorOrderByWithRelationInput | AuthenticatorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Authenticators.
     */
    cursor?: AuthenticatorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Authenticators from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Authenticators.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Authenticators.
     */
    distinct?: AuthenticatorScalarFieldEnum | AuthenticatorScalarFieldEnum[]
  }

  /**
   * Authenticator findMany
   */
  export type AuthenticatorFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Authenticator
     */
    select?: AuthenticatorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Authenticator
     */
    omit?: AuthenticatorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuthenticatorInclude<ExtArgs> | null
    /**
     * Filter, which Authenticators to fetch.
     */
    where?: AuthenticatorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Authenticators to fetch.
     */
    orderBy?: AuthenticatorOrderByWithRelationInput | AuthenticatorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Authenticators.
     */
    cursor?: AuthenticatorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Authenticators from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Authenticators.
     */
    skip?: number
    distinct?: AuthenticatorScalarFieldEnum | AuthenticatorScalarFieldEnum[]
  }

  /**
   * Authenticator create
   */
  export type AuthenticatorCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Authenticator
     */
    select?: AuthenticatorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Authenticator
     */
    omit?: AuthenticatorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuthenticatorInclude<ExtArgs> | null
    /**
     * The data needed to create a Authenticator.
     */
    data: XOR<AuthenticatorCreateInput, AuthenticatorUncheckedCreateInput>
  }

  /**
   * Authenticator createMany
   */
  export type AuthenticatorCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Authenticators.
     */
    data: AuthenticatorCreateManyInput | AuthenticatorCreateManyInput[]
  }

  /**
   * Authenticator createManyAndReturn
   */
  export type AuthenticatorCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Authenticator
     */
    select?: AuthenticatorSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Authenticator
     */
    omit?: AuthenticatorOmit<ExtArgs> | null
    /**
     * The data used to create many Authenticators.
     */
    data: AuthenticatorCreateManyInput | AuthenticatorCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuthenticatorIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Authenticator update
   */
  export type AuthenticatorUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Authenticator
     */
    select?: AuthenticatorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Authenticator
     */
    omit?: AuthenticatorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuthenticatorInclude<ExtArgs> | null
    /**
     * The data needed to update a Authenticator.
     */
    data: XOR<AuthenticatorUpdateInput, AuthenticatorUncheckedUpdateInput>
    /**
     * Choose, which Authenticator to update.
     */
    where: AuthenticatorWhereUniqueInput
  }

  /**
   * Authenticator updateMany
   */
  export type AuthenticatorUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Authenticators.
     */
    data: XOR<AuthenticatorUpdateManyMutationInput, AuthenticatorUncheckedUpdateManyInput>
    /**
     * Filter which Authenticators to update
     */
    where?: AuthenticatorWhereInput
    /**
     * Limit how many Authenticators to update.
     */
    limit?: number
  }

  /**
   * Authenticator updateManyAndReturn
   */
  export type AuthenticatorUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Authenticator
     */
    select?: AuthenticatorSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Authenticator
     */
    omit?: AuthenticatorOmit<ExtArgs> | null
    /**
     * The data used to update Authenticators.
     */
    data: XOR<AuthenticatorUpdateManyMutationInput, AuthenticatorUncheckedUpdateManyInput>
    /**
     * Filter which Authenticators to update
     */
    where?: AuthenticatorWhereInput
    /**
     * Limit how many Authenticators to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuthenticatorIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Authenticator upsert
   */
  export type AuthenticatorUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Authenticator
     */
    select?: AuthenticatorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Authenticator
     */
    omit?: AuthenticatorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuthenticatorInclude<ExtArgs> | null
    /**
     * The filter to search for the Authenticator to update in case it exists.
     */
    where: AuthenticatorWhereUniqueInput
    /**
     * In case the Authenticator found by the `where` argument doesn't exist, create a new Authenticator with this data.
     */
    create: XOR<AuthenticatorCreateInput, AuthenticatorUncheckedCreateInput>
    /**
     * In case the Authenticator was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AuthenticatorUpdateInput, AuthenticatorUncheckedUpdateInput>
  }

  /**
   * Authenticator delete
   */
  export type AuthenticatorDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Authenticator
     */
    select?: AuthenticatorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Authenticator
     */
    omit?: AuthenticatorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuthenticatorInclude<ExtArgs> | null
    /**
     * Filter which Authenticator to delete.
     */
    where: AuthenticatorWhereUniqueInput
  }

  /**
   * Authenticator deleteMany
   */
  export type AuthenticatorDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Authenticators to delete
     */
    where?: AuthenticatorWhereInput
    /**
     * Limit how many Authenticators to delete.
     */
    limit?: number
  }

  /**
   * Authenticator without action
   */
  export type AuthenticatorDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Authenticator
     */
    select?: AuthenticatorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Authenticator
     */
    omit?: AuthenticatorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuthenticatorInclude<ExtArgs> | null
  }


  /**
   * Model Order
   */

  export type AggregateOrder = {
    _count: OrderCountAggregateOutputType | null
    _avg: OrderAvgAggregateOutputType | null
    _sum: OrderSumAggregateOutputType | null
    _min: OrderMinAggregateOutputType | null
    _max: OrderMaxAggregateOutputType | null
  }

  export type OrderAvgAggregateOutputType = {
    totalPrice: number | null
  }

  export type OrderSumAggregateOutputType = {
    totalPrice: number | null
  }

  export type OrderMinAggregateOutputType = {
    id: string | null
    email: string | null
    name: string | null
    userId: string | null
    voucherId: string | null
    totalPrice: number | null
    status: $Enums.OrderStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OrderMaxAggregateOutputType = {
    id: string | null
    email: string | null
    name: string | null
    userId: string | null
    voucherId: string | null
    totalPrice: number | null
    status: $Enums.OrderStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OrderCountAggregateOutputType = {
    id: number
    email: number
    name: number
    userId: number
    voucherId: number
    totalPrice: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type OrderAvgAggregateInputType = {
    totalPrice?: true
  }

  export type OrderSumAggregateInputType = {
    totalPrice?: true
  }

  export type OrderMinAggregateInputType = {
    id?: true
    email?: true
    name?: true
    userId?: true
    voucherId?: true
    totalPrice?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OrderMaxAggregateInputType = {
    id?: true
    email?: true
    name?: true
    userId?: true
    voucherId?: true
    totalPrice?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OrderCountAggregateInputType = {
    id?: true
    email?: true
    name?: true
    userId?: true
    voucherId?: true
    totalPrice?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type OrderAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Order to aggregate.
     */
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Orders
    **/
    _count?: true | OrderCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OrderAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OrderSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrderMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrderMaxAggregateInputType
  }

  export type GetOrderAggregateType<T extends OrderAggregateArgs> = {
        [P in keyof T & keyof AggregateOrder]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrder[P]>
      : GetScalarType<T[P], AggregateOrder[P]>
  }




  export type OrderGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderWhereInput
    orderBy?: OrderOrderByWithAggregationInput | OrderOrderByWithAggregationInput[]
    by: OrderScalarFieldEnum[] | OrderScalarFieldEnum
    having?: OrderScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrderCountAggregateInputType | true
    _avg?: OrderAvgAggregateInputType
    _sum?: OrderSumAggregateInputType
    _min?: OrderMinAggregateInputType
    _max?: OrderMaxAggregateInputType
  }

  export type OrderGroupByOutputType = {
    id: string
    email: string
    name: string | null
    userId: string | null
    voucherId: string | null
    totalPrice: number
    status: $Enums.OrderStatus
    createdAt: Date
    updatedAt: Date
    _count: OrderCountAggregateOutputType | null
    _avg: OrderAvgAggregateOutputType | null
    _sum: OrderSumAggregateOutputType | null
    _min: OrderMinAggregateOutputType | null
    _max: OrderMaxAggregateOutputType | null
  }

  type GetOrderGroupByPayload<T extends OrderGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OrderGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrderGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrderGroupByOutputType[P]>
            : GetScalarType<T[P], OrderGroupByOutputType[P]>
        }
      >
    >


  export type OrderSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    name?: boolean
    userId?: boolean
    voucherId?: boolean
    totalPrice?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | Order$userArgs<ExtArgs>
    products?: boolean | Order$productsArgs<ExtArgs>
    voucher?: boolean | Order$voucherArgs<ExtArgs>
    _count?: boolean | OrderCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["order"]>

  export type OrderSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    name?: boolean
    userId?: boolean
    voucherId?: boolean
    totalPrice?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | Order$userArgs<ExtArgs>
    voucher?: boolean | Order$voucherArgs<ExtArgs>
  }, ExtArgs["result"]["order"]>

  export type OrderSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    name?: boolean
    userId?: boolean
    voucherId?: boolean
    totalPrice?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | Order$userArgs<ExtArgs>
    voucher?: boolean | Order$voucherArgs<ExtArgs>
  }, ExtArgs["result"]["order"]>

  export type OrderSelectScalar = {
    id?: boolean
    email?: boolean
    name?: boolean
    userId?: boolean
    voucherId?: boolean
    totalPrice?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type OrderOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "email" | "name" | "userId" | "voucherId" | "totalPrice" | "status" | "createdAt" | "updatedAt", ExtArgs["result"]["order"]>
  export type OrderInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | Order$userArgs<ExtArgs>
    products?: boolean | Order$productsArgs<ExtArgs>
    voucher?: boolean | Order$voucherArgs<ExtArgs>
    _count?: boolean | OrderCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type OrderIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | Order$userArgs<ExtArgs>
    voucher?: boolean | Order$voucherArgs<ExtArgs>
  }
  export type OrderIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | Order$userArgs<ExtArgs>
    voucher?: boolean | Order$voucherArgs<ExtArgs>
  }

  export type $OrderPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Order"
    objects: {
      user: Prisma.$UserPayload<ExtArgs> | null
      products: Prisma.$ProductPayload<ExtArgs>[]
      voucher: Prisma.$VoucherPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      name: string | null
      userId: string | null
      voucherId: string | null
      totalPrice: number
      status: $Enums.OrderStatus
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["order"]>
    composites: {}
  }

  type OrderGetPayload<S extends boolean | null | undefined | OrderDefaultArgs> = $Result.GetResult<Prisma.$OrderPayload, S>

  type OrderCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OrderFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OrderCountAggregateInputType | true
    }

  export interface OrderDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Order'], meta: { name: 'Order' } }
    /**
     * Find zero or one Order that matches the filter.
     * @param {OrderFindUniqueArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OrderFindUniqueArgs>(args: SelectSubset<T, OrderFindUniqueArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Order that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OrderFindUniqueOrThrowArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OrderFindUniqueOrThrowArgs>(args: SelectSubset<T, OrderFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Order that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderFindFirstArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OrderFindFirstArgs>(args?: SelectSubset<T, OrderFindFirstArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Order that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderFindFirstOrThrowArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OrderFindFirstOrThrowArgs>(args?: SelectSubset<T, OrderFindFirstOrThrowArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Orders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Orders
     * const orders = await prisma.order.findMany()
     * 
     * // Get first 10 Orders
     * const orders = await prisma.order.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const orderWithIdOnly = await prisma.order.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OrderFindManyArgs>(args?: SelectSubset<T, OrderFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Order.
     * @param {OrderCreateArgs} args - Arguments to create a Order.
     * @example
     * // Create one Order
     * const Order = await prisma.order.create({
     *   data: {
     *     // ... data to create a Order
     *   }
     * })
     * 
     */
    create<T extends OrderCreateArgs>(args: SelectSubset<T, OrderCreateArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Orders.
     * @param {OrderCreateManyArgs} args - Arguments to create many Orders.
     * @example
     * // Create many Orders
     * const order = await prisma.order.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OrderCreateManyArgs>(args?: SelectSubset<T, OrderCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Orders and returns the data saved in the database.
     * @param {OrderCreateManyAndReturnArgs} args - Arguments to create many Orders.
     * @example
     * // Create many Orders
     * const order = await prisma.order.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Orders and only return the `id`
     * const orderWithIdOnly = await prisma.order.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OrderCreateManyAndReturnArgs>(args?: SelectSubset<T, OrderCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Order.
     * @param {OrderDeleteArgs} args - Arguments to delete one Order.
     * @example
     * // Delete one Order
     * const Order = await prisma.order.delete({
     *   where: {
     *     // ... filter to delete one Order
     *   }
     * })
     * 
     */
    delete<T extends OrderDeleteArgs>(args: SelectSubset<T, OrderDeleteArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Order.
     * @param {OrderUpdateArgs} args - Arguments to update one Order.
     * @example
     * // Update one Order
     * const order = await prisma.order.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OrderUpdateArgs>(args: SelectSubset<T, OrderUpdateArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Orders.
     * @param {OrderDeleteManyArgs} args - Arguments to filter Orders to delete.
     * @example
     * // Delete a few Orders
     * const { count } = await prisma.order.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OrderDeleteManyArgs>(args?: SelectSubset<T, OrderDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Orders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Orders
     * const order = await prisma.order.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OrderUpdateManyArgs>(args: SelectSubset<T, OrderUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Orders and returns the data updated in the database.
     * @param {OrderUpdateManyAndReturnArgs} args - Arguments to update many Orders.
     * @example
     * // Update many Orders
     * const order = await prisma.order.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Orders and only return the `id`
     * const orderWithIdOnly = await prisma.order.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends OrderUpdateManyAndReturnArgs>(args: SelectSubset<T, OrderUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Order.
     * @param {OrderUpsertArgs} args - Arguments to update or create a Order.
     * @example
     * // Update or create a Order
     * const order = await prisma.order.upsert({
     *   create: {
     *     // ... data to create a Order
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Order we want to update
     *   }
     * })
     */
    upsert<T extends OrderUpsertArgs>(args: SelectSubset<T, OrderUpsertArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Orders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderCountArgs} args - Arguments to filter Orders to count.
     * @example
     * // Count the number of Orders
     * const count = await prisma.order.count({
     *   where: {
     *     // ... the filter for the Orders we want to count
     *   }
     * })
    **/
    count<T extends OrderCountArgs>(
      args?: Subset<T, OrderCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrderCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Order.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrderAggregateArgs>(args: Subset<T, OrderAggregateArgs>): Prisma.PrismaPromise<GetOrderAggregateType<T>>

    /**
     * Group by Order.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OrderGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrderGroupByArgs['orderBy'] }
        : { orderBy?: OrderGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OrderGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrderGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Order model
   */
  readonly fields: OrderFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Order.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OrderClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends Order$userArgs<ExtArgs> = {}>(args?: Subset<T, Order$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    products<T extends Order$productsArgs<ExtArgs> = {}>(args?: Subset<T, Order$productsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    voucher<T extends Order$voucherArgs<ExtArgs> = {}>(args?: Subset<T, Order$voucherArgs<ExtArgs>>): Prisma__VoucherClient<$Result.GetResult<Prisma.$VoucherPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Order model
   */
  interface OrderFieldRefs {
    readonly id: FieldRef<"Order", 'String'>
    readonly email: FieldRef<"Order", 'String'>
    readonly name: FieldRef<"Order", 'String'>
    readonly userId: FieldRef<"Order", 'String'>
    readonly voucherId: FieldRef<"Order", 'String'>
    readonly totalPrice: FieldRef<"Order", 'Float'>
    readonly status: FieldRef<"Order", 'OrderStatus'>
    readonly createdAt: FieldRef<"Order", 'DateTime'>
    readonly updatedAt: FieldRef<"Order", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Order findUnique
   */
  export type OrderFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Order to fetch.
     */
    where: OrderWhereUniqueInput
  }

  /**
   * Order findUniqueOrThrow
   */
  export type OrderFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Order to fetch.
     */
    where: OrderWhereUniqueInput
  }

  /**
   * Order findFirst
   */
  export type OrderFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Order to fetch.
     */
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Orders.
     */
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Orders.
     */
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * Order findFirstOrThrow
   */
  export type OrderFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Order to fetch.
     */
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Orders.
     */
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Orders.
     */
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * Order findMany
   */
  export type OrderFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Orders to fetch.
     */
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Orders.
     */
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * Order create
   */
  export type OrderCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * The data needed to create a Order.
     */
    data: XOR<OrderCreateInput, OrderUncheckedCreateInput>
  }

  /**
   * Order createMany
   */
  export type OrderCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Orders.
     */
    data: OrderCreateManyInput | OrderCreateManyInput[]
  }

  /**
   * Order createManyAndReturn
   */
  export type OrderCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * The data used to create many Orders.
     */
    data: OrderCreateManyInput | OrderCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Order update
   */
  export type OrderUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * The data needed to update a Order.
     */
    data: XOR<OrderUpdateInput, OrderUncheckedUpdateInput>
    /**
     * Choose, which Order to update.
     */
    where: OrderWhereUniqueInput
  }

  /**
   * Order updateMany
   */
  export type OrderUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Orders.
     */
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyInput>
    /**
     * Filter which Orders to update
     */
    where?: OrderWhereInput
    /**
     * Limit how many Orders to update.
     */
    limit?: number
  }

  /**
   * Order updateManyAndReturn
   */
  export type OrderUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * The data used to update Orders.
     */
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyInput>
    /**
     * Filter which Orders to update
     */
    where?: OrderWhereInput
    /**
     * Limit how many Orders to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Order upsert
   */
  export type OrderUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * The filter to search for the Order to update in case it exists.
     */
    where: OrderWhereUniqueInput
    /**
     * In case the Order found by the `where` argument doesn't exist, create a new Order with this data.
     */
    create: XOR<OrderCreateInput, OrderUncheckedCreateInput>
    /**
     * In case the Order was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OrderUpdateInput, OrderUncheckedUpdateInput>
  }

  /**
   * Order delete
   */
  export type OrderDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter which Order to delete.
     */
    where: OrderWhereUniqueInput
  }

  /**
   * Order deleteMany
   */
  export type OrderDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Orders to delete
     */
    where?: OrderWhereInput
    /**
     * Limit how many Orders to delete.
     */
    limit?: number
  }

  /**
   * Order.user
   */
  export type Order$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Order.products
   */
  export type Order$productsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    where?: ProductWhereInput
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    cursor?: ProductWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Order.voucher
   */
  export type Order$voucherArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Voucher
     */
    select?: VoucherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Voucher
     */
    omit?: VoucherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoucherInclude<ExtArgs> | null
    where?: VoucherWhereInput
  }

  /**
   * Order without action
   */
  export type OrderDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
  }


  /**
   * Model Menu
   */

  export type AggregateMenu = {
    _count: MenuCountAggregateOutputType | null
    _avg: MenuAvgAggregateOutputType | null
    _sum: MenuSumAggregateOutputType | null
    _min: MenuMinAggregateOutputType | null
    _max: MenuMaxAggregateOutputType | null
  }

  export type MenuAvgAggregateOutputType = {
    order: number | null
  }

  export type MenuSumAggregateOutputType = {
    order: number | null
  }

  export type MenuMinAggregateOutputType = {
    id: string | null
    title: string | null
    slug: string | null
    type: $Enums.MenuType | null
    order: number | null
    icon: string | null
    parentId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MenuMaxAggregateOutputType = {
    id: string | null
    title: string | null
    slug: string | null
    type: $Enums.MenuType | null
    order: number | null
    icon: string | null
    parentId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MenuCountAggregateOutputType = {
    id: number
    title: number
    slug: number
    type: number
    order: number
    icon: number
    parentId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MenuAvgAggregateInputType = {
    order?: true
  }

  export type MenuSumAggregateInputType = {
    order?: true
  }

  export type MenuMinAggregateInputType = {
    id?: true
    title?: true
    slug?: true
    type?: true
    order?: true
    icon?: true
    parentId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MenuMaxAggregateInputType = {
    id?: true
    title?: true
    slug?: true
    type?: true
    order?: true
    icon?: true
    parentId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MenuCountAggregateInputType = {
    id?: true
    title?: true
    slug?: true
    type?: true
    order?: true
    icon?: true
    parentId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MenuAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Menu to aggregate.
     */
    where?: MenuWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Menus to fetch.
     */
    orderBy?: MenuOrderByWithRelationInput | MenuOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MenuWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Menus from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Menus.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Menus
    **/
    _count?: true | MenuCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MenuAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MenuSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MenuMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MenuMaxAggregateInputType
  }

  export type GetMenuAggregateType<T extends MenuAggregateArgs> = {
        [P in keyof T & keyof AggregateMenu]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMenu[P]>
      : GetScalarType<T[P], AggregateMenu[P]>
  }




  export type MenuGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MenuWhereInput
    orderBy?: MenuOrderByWithAggregationInput | MenuOrderByWithAggregationInput[]
    by: MenuScalarFieldEnum[] | MenuScalarFieldEnum
    having?: MenuScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MenuCountAggregateInputType | true
    _avg?: MenuAvgAggregateInputType
    _sum?: MenuSumAggregateInputType
    _min?: MenuMinAggregateInputType
    _max?: MenuMaxAggregateInputType
  }

  export type MenuGroupByOutputType = {
    id: string
    title: string
    slug: string
    type: $Enums.MenuType
    order: number
    icon: string | null
    parentId: string | null
    createdAt: Date
    updatedAt: Date
    _count: MenuCountAggregateOutputType | null
    _avg: MenuAvgAggregateOutputType | null
    _sum: MenuSumAggregateOutputType | null
    _min: MenuMinAggregateOutputType | null
    _max: MenuMaxAggregateOutputType | null
  }

  type GetMenuGroupByPayload<T extends MenuGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MenuGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MenuGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MenuGroupByOutputType[P]>
            : GetScalarType<T[P], MenuGroupByOutputType[P]>
        }
      >
    >


  export type MenuSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    slug?: boolean
    type?: boolean
    order?: boolean
    icon?: boolean
    parentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    parent?: boolean | Menu$parentArgs<ExtArgs>
    children?: boolean | Menu$childrenArgs<ExtArgs>
    _count?: boolean | MenuCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["menu"]>

  export type MenuSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    slug?: boolean
    type?: boolean
    order?: boolean
    icon?: boolean
    parentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    parent?: boolean | Menu$parentArgs<ExtArgs>
  }, ExtArgs["result"]["menu"]>

  export type MenuSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    slug?: boolean
    type?: boolean
    order?: boolean
    icon?: boolean
    parentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    parent?: boolean | Menu$parentArgs<ExtArgs>
  }, ExtArgs["result"]["menu"]>

  export type MenuSelectScalar = {
    id?: boolean
    title?: boolean
    slug?: boolean
    type?: boolean
    order?: boolean
    icon?: boolean
    parentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type MenuOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "slug" | "type" | "order" | "icon" | "parentId" | "createdAt" | "updatedAt", ExtArgs["result"]["menu"]>
  export type MenuInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    parent?: boolean | Menu$parentArgs<ExtArgs>
    children?: boolean | Menu$childrenArgs<ExtArgs>
    _count?: boolean | MenuCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type MenuIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    parent?: boolean | Menu$parentArgs<ExtArgs>
  }
  export type MenuIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    parent?: boolean | Menu$parentArgs<ExtArgs>
  }

  export type $MenuPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Menu"
    objects: {
      parent: Prisma.$MenuPayload<ExtArgs> | null
      children: Prisma.$MenuPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      slug: string
      type: $Enums.MenuType
      order: number
      icon: string | null
      parentId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["menu"]>
    composites: {}
  }

  type MenuGetPayload<S extends boolean | null | undefined | MenuDefaultArgs> = $Result.GetResult<Prisma.$MenuPayload, S>

  type MenuCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MenuFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MenuCountAggregateInputType | true
    }

  export interface MenuDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Menu'], meta: { name: 'Menu' } }
    /**
     * Find zero or one Menu that matches the filter.
     * @param {MenuFindUniqueArgs} args - Arguments to find a Menu
     * @example
     * // Get one Menu
     * const menu = await prisma.menu.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MenuFindUniqueArgs>(args: SelectSubset<T, MenuFindUniqueArgs<ExtArgs>>): Prisma__MenuClient<$Result.GetResult<Prisma.$MenuPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Menu that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MenuFindUniqueOrThrowArgs} args - Arguments to find a Menu
     * @example
     * // Get one Menu
     * const menu = await prisma.menu.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MenuFindUniqueOrThrowArgs>(args: SelectSubset<T, MenuFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MenuClient<$Result.GetResult<Prisma.$MenuPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Menu that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MenuFindFirstArgs} args - Arguments to find a Menu
     * @example
     * // Get one Menu
     * const menu = await prisma.menu.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MenuFindFirstArgs>(args?: SelectSubset<T, MenuFindFirstArgs<ExtArgs>>): Prisma__MenuClient<$Result.GetResult<Prisma.$MenuPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Menu that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MenuFindFirstOrThrowArgs} args - Arguments to find a Menu
     * @example
     * // Get one Menu
     * const menu = await prisma.menu.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MenuFindFirstOrThrowArgs>(args?: SelectSubset<T, MenuFindFirstOrThrowArgs<ExtArgs>>): Prisma__MenuClient<$Result.GetResult<Prisma.$MenuPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Menus that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MenuFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Menus
     * const menus = await prisma.menu.findMany()
     * 
     * // Get first 10 Menus
     * const menus = await prisma.menu.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const menuWithIdOnly = await prisma.menu.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MenuFindManyArgs>(args?: SelectSubset<T, MenuFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MenuPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Menu.
     * @param {MenuCreateArgs} args - Arguments to create a Menu.
     * @example
     * // Create one Menu
     * const Menu = await prisma.menu.create({
     *   data: {
     *     // ... data to create a Menu
     *   }
     * })
     * 
     */
    create<T extends MenuCreateArgs>(args: SelectSubset<T, MenuCreateArgs<ExtArgs>>): Prisma__MenuClient<$Result.GetResult<Prisma.$MenuPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Menus.
     * @param {MenuCreateManyArgs} args - Arguments to create many Menus.
     * @example
     * // Create many Menus
     * const menu = await prisma.menu.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MenuCreateManyArgs>(args?: SelectSubset<T, MenuCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Menus and returns the data saved in the database.
     * @param {MenuCreateManyAndReturnArgs} args - Arguments to create many Menus.
     * @example
     * // Create many Menus
     * const menu = await prisma.menu.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Menus and only return the `id`
     * const menuWithIdOnly = await prisma.menu.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MenuCreateManyAndReturnArgs>(args?: SelectSubset<T, MenuCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MenuPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Menu.
     * @param {MenuDeleteArgs} args - Arguments to delete one Menu.
     * @example
     * // Delete one Menu
     * const Menu = await prisma.menu.delete({
     *   where: {
     *     // ... filter to delete one Menu
     *   }
     * })
     * 
     */
    delete<T extends MenuDeleteArgs>(args: SelectSubset<T, MenuDeleteArgs<ExtArgs>>): Prisma__MenuClient<$Result.GetResult<Prisma.$MenuPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Menu.
     * @param {MenuUpdateArgs} args - Arguments to update one Menu.
     * @example
     * // Update one Menu
     * const menu = await prisma.menu.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MenuUpdateArgs>(args: SelectSubset<T, MenuUpdateArgs<ExtArgs>>): Prisma__MenuClient<$Result.GetResult<Prisma.$MenuPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Menus.
     * @param {MenuDeleteManyArgs} args - Arguments to filter Menus to delete.
     * @example
     * // Delete a few Menus
     * const { count } = await prisma.menu.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MenuDeleteManyArgs>(args?: SelectSubset<T, MenuDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Menus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MenuUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Menus
     * const menu = await prisma.menu.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MenuUpdateManyArgs>(args: SelectSubset<T, MenuUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Menus and returns the data updated in the database.
     * @param {MenuUpdateManyAndReturnArgs} args - Arguments to update many Menus.
     * @example
     * // Update many Menus
     * const menu = await prisma.menu.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Menus and only return the `id`
     * const menuWithIdOnly = await prisma.menu.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MenuUpdateManyAndReturnArgs>(args: SelectSubset<T, MenuUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MenuPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Menu.
     * @param {MenuUpsertArgs} args - Arguments to update or create a Menu.
     * @example
     * // Update or create a Menu
     * const menu = await prisma.menu.upsert({
     *   create: {
     *     // ... data to create a Menu
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Menu we want to update
     *   }
     * })
     */
    upsert<T extends MenuUpsertArgs>(args: SelectSubset<T, MenuUpsertArgs<ExtArgs>>): Prisma__MenuClient<$Result.GetResult<Prisma.$MenuPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Menus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MenuCountArgs} args - Arguments to filter Menus to count.
     * @example
     * // Count the number of Menus
     * const count = await prisma.menu.count({
     *   where: {
     *     // ... the filter for the Menus we want to count
     *   }
     * })
    **/
    count<T extends MenuCountArgs>(
      args?: Subset<T, MenuCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MenuCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Menu.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MenuAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MenuAggregateArgs>(args: Subset<T, MenuAggregateArgs>): Prisma.PrismaPromise<GetMenuAggregateType<T>>

    /**
     * Group by Menu.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MenuGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MenuGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MenuGroupByArgs['orderBy'] }
        : { orderBy?: MenuGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MenuGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMenuGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Menu model
   */
  readonly fields: MenuFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Menu.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MenuClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    parent<T extends Menu$parentArgs<ExtArgs> = {}>(args?: Subset<T, Menu$parentArgs<ExtArgs>>): Prisma__MenuClient<$Result.GetResult<Prisma.$MenuPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    children<T extends Menu$childrenArgs<ExtArgs> = {}>(args?: Subset<T, Menu$childrenArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MenuPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Menu model
   */
  interface MenuFieldRefs {
    readonly id: FieldRef<"Menu", 'String'>
    readonly title: FieldRef<"Menu", 'String'>
    readonly slug: FieldRef<"Menu", 'String'>
    readonly type: FieldRef<"Menu", 'MenuType'>
    readonly order: FieldRef<"Menu", 'Int'>
    readonly icon: FieldRef<"Menu", 'String'>
    readonly parentId: FieldRef<"Menu", 'String'>
    readonly createdAt: FieldRef<"Menu", 'DateTime'>
    readonly updatedAt: FieldRef<"Menu", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Menu findUnique
   */
  export type MenuFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Menu
     */
    select?: MenuSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Menu
     */
    omit?: MenuOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenuInclude<ExtArgs> | null
    /**
     * Filter, which Menu to fetch.
     */
    where: MenuWhereUniqueInput
  }

  /**
   * Menu findUniqueOrThrow
   */
  export type MenuFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Menu
     */
    select?: MenuSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Menu
     */
    omit?: MenuOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenuInclude<ExtArgs> | null
    /**
     * Filter, which Menu to fetch.
     */
    where: MenuWhereUniqueInput
  }

  /**
   * Menu findFirst
   */
  export type MenuFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Menu
     */
    select?: MenuSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Menu
     */
    omit?: MenuOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenuInclude<ExtArgs> | null
    /**
     * Filter, which Menu to fetch.
     */
    where?: MenuWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Menus to fetch.
     */
    orderBy?: MenuOrderByWithRelationInput | MenuOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Menus.
     */
    cursor?: MenuWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Menus from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Menus.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Menus.
     */
    distinct?: MenuScalarFieldEnum | MenuScalarFieldEnum[]
  }

  /**
   * Menu findFirstOrThrow
   */
  export type MenuFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Menu
     */
    select?: MenuSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Menu
     */
    omit?: MenuOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenuInclude<ExtArgs> | null
    /**
     * Filter, which Menu to fetch.
     */
    where?: MenuWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Menus to fetch.
     */
    orderBy?: MenuOrderByWithRelationInput | MenuOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Menus.
     */
    cursor?: MenuWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Menus from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Menus.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Menus.
     */
    distinct?: MenuScalarFieldEnum | MenuScalarFieldEnum[]
  }

  /**
   * Menu findMany
   */
  export type MenuFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Menu
     */
    select?: MenuSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Menu
     */
    omit?: MenuOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenuInclude<ExtArgs> | null
    /**
     * Filter, which Menus to fetch.
     */
    where?: MenuWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Menus to fetch.
     */
    orderBy?: MenuOrderByWithRelationInput | MenuOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Menus.
     */
    cursor?: MenuWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Menus from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Menus.
     */
    skip?: number
    distinct?: MenuScalarFieldEnum | MenuScalarFieldEnum[]
  }

  /**
   * Menu create
   */
  export type MenuCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Menu
     */
    select?: MenuSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Menu
     */
    omit?: MenuOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenuInclude<ExtArgs> | null
    /**
     * The data needed to create a Menu.
     */
    data: XOR<MenuCreateInput, MenuUncheckedCreateInput>
  }

  /**
   * Menu createMany
   */
  export type MenuCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Menus.
     */
    data: MenuCreateManyInput | MenuCreateManyInput[]
  }

  /**
   * Menu createManyAndReturn
   */
  export type MenuCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Menu
     */
    select?: MenuSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Menu
     */
    omit?: MenuOmit<ExtArgs> | null
    /**
     * The data used to create many Menus.
     */
    data: MenuCreateManyInput | MenuCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenuIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Menu update
   */
  export type MenuUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Menu
     */
    select?: MenuSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Menu
     */
    omit?: MenuOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenuInclude<ExtArgs> | null
    /**
     * The data needed to update a Menu.
     */
    data: XOR<MenuUpdateInput, MenuUncheckedUpdateInput>
    /**
     * Choose, which Menu to update.
     */
    where: MenuWhereUniqueInput
  }

  /**
   * Menu updateMany
   */
  export type MenuUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Menus.
     */
    data: XOR<MenuUpdateManyMutationInput, MenuUncheckedUpdateManyInput>
    /**
     * Filter which Menus to update
     */
    where?: MenuWhereInput
    /**
     * Limit how many Menus to update.
     */
    limit?: number
  }

  /**
   * Menu updateManyAndReturn
   */
  export type MenuUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Menu
     */
    select?: MenuSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Menu
     */
    omit?: MenuOmit<ExtArgs> | null
    /**
     * The data used to update Menus.
     */
    data: XOR<MenuUpdateManyMutationInput, MenuUncheckedUpdateManyInput>
    /**
     * Filter which Menus to update
     */
    where?: MenuWhereInput
    /**
     * Limit how many Menus to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenuIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Menu upsert
   */
  export type MenuUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Menu
     */
    select?: MenuSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Menu
     */
    omit?: MenuOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenuInclude<ExtArgs> | null
    /**
     * The filter to search for the Menu to update in case it exists.
     */
    where: MenuWhereUniqueInput
    /**
     * In case the Menu found by the `where` argument doesn't exist, create a new Menu with this data.
     */
    create: XOR<MenuCreateInput, MenuUncheckedCreateInput>
    /**
     * In case the Menu was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MenuUpdateInput, MenuUncheckedUpdateInput>
  }

  /**
   * Menu delete
   */
  export type MenuDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Menu
     */
    select?: MenuSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Menu
     */
    omit?: MenuOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenuInclude<ExtArgs> | null
    /**
     * Filter which Menu to delete.
     */
    where: MenuWhereUniqueInput
  }

  /**
   * Menu deleteMany
   */
  export type MenuDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Menus to delete
     */
    where?: MenuWhereInput
    /**
     * Limit how many Menus to delete.
     */
    limit?: number
  }

  /**
   * Menu.parent
   */
  export type Menu$parentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Menu
     */
    select?: MenuSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Menu
     */
    omit?: MenuOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenuInclude<ExtArgs> | null
    where?: MenuWhereInput
  }

  /**
   * Menu.children
   */
  export type Menu$childrenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Menu
     */
    select?: MenuSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Menu
     */
    omit?: MenuOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenuInclude<ExtArgs> | null
    where?: MenuWhereInput
    orderBy?: MenuOrderByWithRelationInput | MenuOrderByWithRelationInput[]
    cursor?: MenuWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MenuScalarFieldEnum | MenuScalarFieldEnum[]
  }

  /**
   * Menu without action
   */
  export type MenuDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Menu
     */
    select?: MenuSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Menu
     */
    omit?: MenuOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenuInclude<ExtArgs> | null
  }


  /**
   * Model FooterInfo
   */

  export type AggregateFooterInfo = {
    _count: FooterInfoCountAggregateOutputType | null
    _avg: FooterInfoAvgAggregateOutputType | null
    _sum: FooterInfoSumAggregateOutputType | null
    _min: FooterInfoMinAggregateOutputType | null
    _max: FooterInfoMaxAggregateOutputType | null
  }

  export type FooterInfoAvgAggregateOutputType = {
    order: number | null
  }

  export type FooterInfoSumAggregateOutputType = {
    order: number | null
  }

  export type FooterInfoMinAggregateOutputType = {
    id: string | null
    label: string | null
    value: string | null
    type: $Enums.FooterInfoType | null
    icon: string | null
    order: number | null
  }

  export type FooterInfoMaxAggregateOutputType = {
    id: string | null
    label: string | null
    value: string | null
    type: $Enums.FooterInfoType | null
    icon: string | null
    order: number | null
  }

  export type FooterInfoCountAggregateOutputType = {
    id: number
    label: number
    value: number
    type: number
    icon: number
    order: number
    _all: number
  }


  export type FooterInfoAvgAggregateInputType = {
    order?: true
  }

  export type FooterInfoSumAggregateInputType = {
    order?: true
  }

  export type FooterInfoMinAggregateInputType = {
    id?: true
    label?: true
    value?: true
    type?: true
    icon?: true
    order?: true
  }

  export type FooterInfoMaxAggregateInputType = {
    id?: true
    label?: true
    value?: true
    type?: true
    icon?: true
    order?: true
  }

  export type FooterInfoCountAggregateInputType = {
    id?: true
    label?: true
    value?: true
    type?: true
    icon?: true
    order?: true
    _all?: true
  }

  export type FooterInfoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FooterInfo to aggregate.
     */
    where?: FooterInfoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FooterInfos to fetch.
     */
    orderBy?: FooterInfoOrderByWithRelationInput | FooterInfoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FooterInfoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FooterInfos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FooterInfos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FooterInfos
    **/
    _count?: true | FooterInfoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FooterInfoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FooterInfoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FooterInfoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FooterInfoMaxAggregateInputType
  }

  export type GetFooterInfoAggregateType<T extends FooterInfoAggregateArgs> = {
        [P in keyof T & keyof AggregateFooterInfo]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFooterInfo[P]>
      : GetScalarType<T[P], AggregateFooterInfo[P]>
  }




  export type FooterInfoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FooterInfoWhereInput
    orderBy?: FooterInfoOrderByWithAggregationInput | FooterInfoOrderByWithAggregationInput[]
    by: FooterInfoScalarFieldEnum[] | FooterInfoScalarFieldEnum
    having?: FooterInfoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FooterInfoCountAggregateInputType | true
    _avg?: FooterInfoAvgAggregateInputType
    _sum?: FooterInfoSumAggregateInputType
    _min?: FooterInfoMinAggregateInputType
    _max?: FooterInfoMaxAggregateInputType
  }

  export type FooterInfoGroupByOutputType = {
    id: string
    label: string
    value: string
    type: $Enums.FooterInfoType
    icon: string | null
    order: number
    _count: FooterInfoCountAggregateOutputType | null
    _avg: FooterInfoAvgAggregateOutputType | null
    _sum: FooterInfoSumAggregateOutputType | null
    _min: FooterInfoMinAggregateOutputType | null
    _max: FooterInfoMaxAggregateOutputType | null
  }

  type GetFooterInfoGroupByPayload<T extends FooterInfoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FooterInfoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FooterInfoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FooterInfoGroupByOutputType[P]>
            : GetScalarType<T[P], FooterInfoGroupByOutputType[P]>
        }
      >
    >


  export type FooterInfoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    label?: boolean
    value?: boolean
    type?: boolean
    icon?: boolean
    order?: boolean
  }, ExtArgs["result"]["footerInfo"]>

  export type FooterInfoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    label?: boolean
    value?: boolean
    type?: boolean
    icon?: boolean
    order?: boolean
  }, ExtArgs["result"]["footerInfo"]>

  export type FooterInfoSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    label?: boolean
    value?: boolean
    type?: boolean
    icon?: boolean
    order?: boolean
  }, ExtArgs["result"]["footerInfo"]>

  export type FooterInfoSelectScalar = {
    id?: boolean
    label?: boolean
    value?: boolean
    type?: boolean
    icon?: boolean
    order?: boolean
  }

  export type FooterInfoOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "label" | "value" | "type" | "icon" | "order", ExtArgs["result"]["footerInfo"]>

  export type $FooterInfoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FooterInfo"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      label: string
      value: string
      type: $Enums.FooterInfoType
      icon: string | null
      order: number
    }, ExtArgs["result"]["footerInfo"]>
    composites: {}
  }

  type FooterInfoGetPayload<S extends boolean | null | undefined | FooterInfoDefaultArgs> = $Result.GetResult<Prisma.$FooterInfoPayload, S>

  type FooterInfoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FooterInfoFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FooterInfoCountAggregateInputType | true
    }

  export interface FooterInfoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FooterInfo'], meta: { name: 'FooterInfo' } }
    /**
     * Find zero or one FooterInfo that matches the filter.
     * @param {FooterInfoFindUniqueArgs} args - Arguments to find a FooterInfo
     * @example
     * // Get one FooterInfo
     * const footerInfo = await prisma.footerInfo.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FooterInfoFindUniqueArgs>(args: SelectSubset<T, FooterInfoFindUniqueArgs<ExtArgs>>): Prisma__FooterInfoClient<$Result.GetResult<Prisma.$FooterInfoPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one FooterInfo that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FooterInfoFindUniqueOrThrowArgs} args - Arguments to find a FooterInfo
     * @example
     * // Get one FooterInfo
     * const footerInfo = await prisma.footerInfo.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FooterInfoFindUniqueOrThrowArgs>(args: SelectSubset<T, FooterInfoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FooterInfoClient<$Result.GetResult<Prisma.$FooterInfoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FooterInfo that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FooterInfoFindFirstArgs} args - Arguments to find a FooterInfo
     * @example
     * // Get one FooterInfo
     * const footerInfo = await prisma.footerInfo.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FooterInfoFindFirstArgs>(args?: SelectSubset<T, FooterInfoFindFirstArgs<ExtArgs>>): Prisma__FooterInfoClient<$Result.GetResult<Prisma.$FooterInfoPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FooterInfo that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FooterInfoFindFirstOrThrowArgs} args - Arguments to find a FooterInfo
     * @example
     * // Get one FooterInfo
     * const footerInfo = await prisma.footerInfo.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FooterInfoFindFirstOrThrowArgs>(args?: SelectSubset<T, FooterInfoFindFirstOrThrowArgs<ExtArgs>>): Prisma__FooterInfoClient<$Result.GetResult<Prisma.$FooterInfoPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more FooterInfos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FooterInfoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FooterInfos
     * const footerInfos = await prisma.footerInfo.findMany()
     * 
     * // Get first 10 FooterInfos
     * const footerInfos = await prisma.footerInfo.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const footerInfoWithIdOnly = await prisma.footerInfo.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FooterInfoFindManyArgs>(args?: SelectSubset<T, FooterInfoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FooterInfoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a FooterInfo.
     * @param {FooterInfoCreateArgs} args - Arguments to create a FooterInfo.
     * @example
     * // Create one FooterInfo
     * const FooterInfo = await prisma.footerInfo.create({
     *   data: {
     *     // ... data to create a FooterInfo
     *   }
     * })
     * 
     */
    create<T extends FooterInfoCreateArgs>(args: SelectSubset<T, FooterInfoCreateArgs<ExtArgs>>): Prisma__FooterInfoClient<$Result.GetResult<Prisma.$FooterInfoPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many FooterInfos.
     * @param {FooterInfoCreateManyArgs} args - Arguments to create many FooterInfos.
     * @example
     * // Create many FooterInfos
     * const footerInfo = await prisma.footerInfo.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FooterInfoCreateManyArgs>(args?: SelectSubset<T, FooterInfoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FooterInfos and returns the data saved in the database.
     * @param {FooterInfoCreateManyAndReturnArgs} args - Arguments to create many FooterInfos.
     * @example
     * // Create many FooterInfos
     * const footerInfo = await prisma.footerInfo.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many FooterInfos and only return the `id`
     * const footerInfoWithIdOnly = await prisma.footerInfo.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FooterInfoCreateManyAndReturnArgs>(args?: SelectSubset<T, FooterInfoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FooterInfoPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a FooterInfo.
     * @param {FooterInfoDeleteArgs} args - Arguments to delete one FooterInfo.
     * @example
     * // Delete one FooterInfo
     * const FooterInfo = await prisma.footerInfo.delete({
     *   where: {
     *     // ... filter to delete one FooterInfo
     *   }
     * })
     * 
     */
    delete<T extends FooterInfoDeleteArgs>(args: SelectSubset<T, FooterInfoDeleteArgs<ExtArgs>>): Prisma__FooterInfoClient<$Result.GetResult<Prisma.$FooterInfoPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one FooterInfo.
     * @param {FooterInfoUpdateArgs} args - Arguments to update one FooterInfo.
     * @example
     * // Update one FooterInfo
     * const footerInfo = await prisma.footerInfo.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FooterInfoUpdateArgs>(args: SelectSubset<T, FooterInfoUpdateArgs<ExtArgs>>): Prisma__FooterInfoClient<$Result.GetResult<Prisma.$FooterInfoPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more FooterInfos.
     * @param {FooterInfoDeleteManyArgs} args - Arguments to filter FooterInfos to delete.
     * @example
     * // Delete a few FooterInfos
     * const { count } = await prisma.footerInfo.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FooterInfoDeleteManyArgs>(args?: SelectSubset<T, FooterInfoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FooterInfos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FooterInfoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FooterInfos
     * const footerInfo = await prisma.footerInfo.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FooterInfoUpdateManyArgs>(args: SelectSubset<T, FooterInfoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FooterInfos and returns the data updated in the database.
     * @param {FooterInfoUpdateManyAndReturnArgs} args - Arguments to update many FooterInfos.
     * @example
     * // Update many FooterInfos
     * const footerInfo = await prisma.footerInfo.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more FooterInfos and only return the `id`
     * const footerInfoWithIdOnly = await prisma.footerInfo.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FooterInfoUpdateManyAndReturnArgs>(args: SelectSubset<T, FooterInfoUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FooterInfoPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one FooterInfo.
     * @param {FooterInfoUpsertArgs} args - Arguments to update or create a FooterInfo.
     * @example
     * // Update or create a FooterInfo
     * const footerInfo = await prisma.footerInfo.upsert({
     *   create: {
     *     // ... data to create a FooterInfo
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FooterInfo we want to update
     *   }
     * })
     */
    upsert<T extends FooterInfoUpsertArgs>(args: SelectSubset<T, FooterInfoUpsertArgs<ExtArgs>>): Prisma__FooterInfoClient<$Result.GetResult<Prisma.$FooterInfoPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of FooterInfos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FooterInfoCountArgs} args - Arguments to filter FooterInfos to count.
     * @example
     * // Count the number of FooterInfos
     * const count = await prisma.footerInfo.count({
     *   where: {
     *     // ... the filter for the FooterInfos we want to count
     *   }
     * })
    **/
    count<T extends FooterInfoCountArgs>(
      args?: Subset<T, FooterInfoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FooterInfoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FooterInfo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FooterInfoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FooterInfoAggregateArgs>(args: Subset<T, FooterInfoAggregateArgs>): Prisma.PrismaPromise<GetFooterInfoAggregateType<T>>

    /**
     * Group by FooterInfo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FooterInfoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FooterInfoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FooterInfoGroupByArgs['orderBy'] }
        : { orderBy?: FooterInfoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FooterInfoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFooterInfoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FooterInfo model
   */
  readonly fields: FooterInfoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FooterInfo.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FooterInfoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FooterInfo model
   */
  interface FooterInfoFieldRefs {
    readonly id: FieldRef<"FooterInfo", 'String'>
    readonly label: FieldRef<"FooterInfo", 'String'>
    readonly value: FieldRef<"FooterInfo", 'String'>
    readonly type: FieldRef<"FooterInfo", 'FooterInfoType'>
    readonly icon: FieldRef<"FooterInfo", 'String'>
    readonly order: FieldRef<"FooterInfo", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * FooterInfo findUnique
   */
  export type FooterInfoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FooterInfo
     */
    select?: FooterInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FooterInfo
     */
    omit?: FooterInfoOmit<ExtArgs> | null
    /**
     * Filter, which FooterInfo to fetch.
     */
    where: FooterInfoWhereUniqueInput
  }

  /**
   * FooterInfo findUniqueOrThrow
   */
  export type FooterInfoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FooterInfo
     */
    select?: FooterInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FooterInfo
     */
    omit?: FooterInfoOmit<ExtArgs> | null
    /**
     * Filter, which FooterInfo to fetch.
     */
    where: FooterInfoWhereUniqueInput
  }

  /**
   * FooterInfo findFirst
   */
  export type FooterInfoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FooterInfo
     */
    select?: FooterInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FooterInfo
     */
    omit?: FooterInfoOmit<ExtArgs> | null
    /**
     * Filter, which FooterInfo to fetch.
     */
    where?: FooterInfoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FooterInfos to fetch.
     */
    orderBy?: FooterInfoOrderByWithRelationInput | FooterInfoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FooterInfos.
     */
    cursor?: FooterInfoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FooterInfos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FooterInfos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FooterInfos.
     */
    distinct?: FooterInfoScalarFieldEnum | FooterInfoScalarFieldEnum[]
  }

  /**
   * FooterInfo findFirstOrThrow
   */
  export type FooterInfoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FooterInfo
     */
    select?: FooterInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FooterInfo
     */
    omit?: FooterInfoOmit<ExtArgs> | null
    /**
     * Filter, which FooterInfo to fetch.
     */
    where?: FooterInfoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FooterInfos to fetch.
     */
    orderBy?: FooterInfoOrderByWithRelationInput | FooterInfoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FooterInfos.
     */
    cursor?: FooterInfoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FooterInfos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FooterInfos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FooterInfos.
     */
    distinct?: FooterInfoScalarFieldEnum | FooterInfoScalarFieldEnum[]
  }

  /**
   * FooterInfo findMany
   */
  export type FooterInfoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FooterInfo
     */
    select?: FooterInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FooterInfo
     */
    omit?: FooterInfoOmit<ExtArgs> | null
    /**
     * Filter, which FooterInfos to fetch.
     */
    where?: FooterInfoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FooterInfos to fetch.
     */
    orderBy?: FooterInfoOrderByWithRelationInput | FooterInfoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FooterInfos.
     */
    cursor?: FooterInfoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FooterInfos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FooterInfos.
     */
    skip?: number
    distinct?: FooterInfoScalarFieldEnum | FooterInfoScalarFieldEnum[]
  }

  /**
   * FooterInfo create
   */
  export type FooterInfoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FooterInfo
     */
    select?: FooterInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FooterInfo
     */
    omit?: FooterInfoOmit<ExtArgs> | null
    /**
     * The data needed to create a FooterInfo.
     */
    data: XOR<FooterInfoCreateInput, FooterInfoUncheckedCreateInput>
  }

  /**
   * FooterInfo createMany
   */
  export type FooterInfoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FooterInfos.
     */
    data: FooterInfoCreateManyInput | FooterInfoCreateManyInput[]
  }

  /**
   * FooterInfo createManyAndReturn
   */
  export type FooterInfoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FooterInfo
     */
    select?: FooterInfoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FooterInfo
     */
    omit?: FooterInfoOmit<ExtArgs> | null
    /**
     * The data used to create many FooterInfos.
     */
    data: FooterInfoCreateManyInput | FooterInfoCreateManyInput[]
  }

  /**
   * FooterInfo update
   */
  export type FooterInfoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FooterInfo
     */
    select?: FooterInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FooterInfo
     */
    omit?: FooterInfoOmit<ExtArgs> | null
    /**
     * The data needed to update a FooterInfo.
     */
    data: XOR<FooterInfoUpdateInput, FooterInfoUncheckedUpdateInput>
    /**
     * Choose, which FooterInfo to update.
     */
    where: FooterInfoWhereUniqueInput
  }

  /**
   * FooterInfo updateMany
   */
  export type FooterInfoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FooterInfos.
     */
    data: XOR<FooterInfoUpdateManyMutationInput, FooterInfoUncheckedUpdateManyInput>
    /**
     * Filter which FooterInfos to update
     */
    where?: FooterInfoWhereInput
    /**
     * Limit how many FooterInfos to update.
     */
    limit?: number
  }

  /**
   * FooterInfo updateManyAndReturn
   */
  export type FooterInfoUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FooterInfo
     */
    select?: FooterInfoSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FooterInfo
     */
    omit?: FooterInfoOmit<ExtArgs> | null
    /**
     * The data used to update FooterInfos.
     */
    data: XOR<FooterInfoUpdateManyMutationInput, FooterInfoUncheckedUpdateManyInput>
    /**
     * Filter which FooterInfos to update
     */
    where?: FooterInfoWhereInput
    /**
     * Limit how many FooterInfos to update.
     */
    limit?: number
  }

  /**
   * FooterInfo upsert
   */
  export type FooterInfoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FooterInfo
     */
    select?: FooterInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FooterInfo
     */
    omit?: FooterInfoOmit<ExtArgs> | null
    /**
     * The filter to search for the FooterInfo to update in case it exists.
     */
    where: FooterInfoWhereUniqueInput
    /**
     * In case the FooterInfo found by the `where` argument doesn't exist, create a new FooterInfo with this data.
     */
    create: XOR<FooterInfoCreateInput, FooterInfoUncheckedCreateInput>
    /**
     * In case the FooterInfo was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FooterInfoUpdateInput, FooterInfoUncheckedUpdateInput>
  }

  /**
   * FooterInfo delete
   */
  export type FooterInfoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FooterInfo
     */
    select?: FooterInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FooterInfo
     */
    omit?: FooterInfoOmit<ExtArgs> | null
    /**
     * Filter which FooterInfo to delete.
     */
    where: FooterInfoWhereUniqueInput
  }

  /**
   * FooterInfo deleteMany
   */
  export type FooterInfoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FooterInfos to delete
     */
    where?: FooterInfoWhereInput
    /**
     * Limit how many FooterInfos to delete.
     */
    limit?: number
  }

  /**
   * FooterInfo without action
   */
  export type FooterInfoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FooterInfo
     */
    select?: FooterInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FooterInfo
     */
    omit?: FooterInfoOmit<ExtArgs> | null
  }


  /**
   * Model Account
   */

  export type AggregateAccount = {
    _count: AccountCountAggregateOutputType | null
    _avg: AccountAvgAggregateOutputType | null
    _sum: AccountSumAggregateOutputType | null
    _min: AccountMinAggregateOutputType | null
    _max: AccountMaxAggregateOutputType | null
  }

  export type AccountAvgAggregateOutputType = {
    expires_at: number | null
  }

  export type AccountSumAggregateOutputType = {
    expires_at: number | null
  }

  export type AccountMinAggregateOutputType = {
    id: string | null
    userId: string | null
    type: string | null
    provider: string | null
    providerAccountId: string | null
    refresh_token: string | null
    access_token: string | null
    expires_at: number | null
    token_type: string | null
    scope: string | null
    id_token: string | null
    session_state: string | null
  }

  export type AccountMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    type: string | null
    provider: string | null
    providerAccountId: string | null
    refresh_token: string | null
    access_token: string | null
    expires_at: number | null
    token_type: string | null
    scope: string | null
    id_token: string | null
    session_state: string | null
  }

  export type AccountCountAggregateOutputType = {
    id: number
    userId: number
    type: number
    provider: number
    providerAccountId: number
    refresh_token: number
    access_token: number
    expires_at: number
    token_type: number
    scope: number
    id_token: number
    session_state: number
    _all: number
  }


  export type AccountAvgAggregateInputType = {
    expires_at?: true
  }

  export type AccountSumAggregateInputType = {
    expires_at?: true
  }

  export type AccountMinAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    provider?: true
    providerAccountId?: true
    refresh_token?: true
    access_token?: true
    expires_at?: true
    token_type?: true
    scope?: true
    id_token?: true
    session_state?: true
  }

  export type AccountMaxAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    provider?: true
    providerAccountId?: true
    refresh_token?: true
    access_token?: true
    expires_at?: true
    token_type?: true
    scope?: true
    id_token?: true
    session_state?: true
  }

  export type AccountCountAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    provider?: true
    providerAccountId?: true
    refresh_token?: true
    access_token?: true
    expires_at?: true
    token_type?: true
    scope?: true
    id_token?: true
    session_state?: true
    _all?: true
  }

  export type AccountAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Account to aggregate.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Accounts
    **/
    _count?: true | AccountCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AccountAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AccountSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AccountMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AccountMaxAggregateInputType
  }

  export type GetAccountAggregateType<T extends AccountAggregateArgs> = {
        [P in keyof T & keyof AggregateAccount]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAccount[P]>
      : GetScalarType<T[P], AggregateAccount[P]>
  }




  export type AccountGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountWhereInput
    orderBy?: AccountOrderByWithAggregationInput | AccountOrderByWithAggregationInput[]
    by: AccountScalarFieldEnum[] | AccountScalarFieldEnum
    having?: AccountScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AccountCountAggregateInputType | true
    _avg?: AccountAvgAggregateInputType
    _sum?: AccountSumAggregateInputType
    _min?: AccountMinAggregateInputType
    _max?: AccountMaxAggregateInputType
  }

  export type AccountGroupByOutputType = {
    id: string
    userId: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token: string | null
    access_token: string | null
    expires_at: number | null
    token_type: string | null
    scope: string | null
    id_token: string | null
    session_state: string | null
    _count: AccountCountAggregateOutputType | null
    _avg: AccountAvgAggregateOutputType | null
    _sum: AccountSumAggregateOutputType | null
    _min: AccountMinAggregateOutputType | null
    _max: AccountMaxAggregateOutputType | null
  }

  type GetAccountGroupByPayload<T extends AccountGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AccountGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AccountGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AccountGroupByOutputType[P]>
            : GetScalarType<T[P], AccountGroupByOutputType[P]>
        }
      >
    >


  export type AccountSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    provider?: boolean
    providerAccountId?: boolean
    refresh_token?: boolean
    access_token?: boolean
    expires_at?: boolean
    token_type?: boolean
    scope?: boolean
    id_token?: boolean
    session_state?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>

  export type AccountSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    provider?: boolean
    providerAccountId?: boolean
    refresh_token?: boolean
    access_token?: boolean
    expires_at?: boolean
    token_type?: boolean
    scope?: boolean
    id_token?: boolean
    session_state?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>

  export type AccountSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    provider?: boolean
    providerAccountId?: boolean
    refresh_token?: boolean
    access_token?: boolean
    expires_at?: boolean
    token_type?: boolean
    scope?: boolean
    id_token?: boolean
    session_state?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>

  export type AccountSelectScalar = {
    id?: boolean
    userId?: boolean
    type?: boolean
    provider?: boolean
    providerAccountId?: boolean
    refresh_token?: boolean
    access_token?: boolean
    expires_at?: boolean
    token_type?: boolean
    scope?: boolean
    id_token?: boolean
    session_state?: boolean
  }

  export type AccountOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "type" | "provider" | "providerAccountId" | "refresh_token" | "access_token" | "expires_at" | "token_type" | "scope" | "id_token" | "session_state", ExtArgs["result"]["account"]>
  export type AccountInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AccountIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AccountIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AccountPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Account"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      type: string
      provider: string
      providerAccountId: string
      refresh_token: string | null
      access_token: string | null
      expires_at: number | null
      token_type: string | null
      scope: string | null
      id_token: string | null
      session_state: string | null
    }, ExtArgs["result"]["account"]>
    composites: {}
  }

  type AccountGetPayload<S extends boolean | null | undefined | AccountDefaultArgs> = $Result.GetResult<Prisma.$AccountPayload, S>

  type AccountCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AccountFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AccountCountAggregateInputType | true
    }

  export interface AccountDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Account'], meta: { name: 'Account' } }
    /**
     * Find zero or one Account that matches the filter.
     * @param {AccountFindUniqueArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AccountFindUniqueArgs>(args: SelectSubset<T, AccountFindUniqueArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Account that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AccountFindUniqueOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AccountFindUniqueOrThrowArgs>(args: SelectSubset<T, AccountFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Account that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindFirstArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AccountFindFirstArgs>(args?: SelectSubset<T, AccountFindFirstArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Account that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindFirstOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AccountFindFirstOrThrowArgs>(args?: SelectSubset<T, AccountFindFirstOrThrowArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Accounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Accounts
     * const accounts = await prisma.account.findMany()
     * 
     * // Get first 10 Accounts
     * const accounts = await prisma.account.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const accountWithIdOnly = await prisma.account.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AccountFindManyArgs>(args?: SelectSubset<T, AccountFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Account.
     * @param {AccountCreateArgs} args - Arguments to create a Account.
     * @example
     * // Create one Account
     * const Account = await prisma.account.create({
     *   data: {
     *     // ... data to create a Account
     *   }
     * })
     * 
     */
    create<T extends AccountCreateArgs>(args: SelectSubset<T, AccountCreateArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Accounts.
     * @param {AccountCreateManyArgs} args - Arguments to create many Accounts.
     * @example
     * // Create many Accounts
     * const account = await prisma.account.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AccountCreateManyArgs>(args?: SelectSubset<T, AccountCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Accounts and returns the data saved in the database.
     * @param {AccountCreateManyAndReturnArgs} args - Arguments to create many Accounts.
     * @example
     * // Create many Accounts
     * const account = await prisma.account.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Accounts and only return the `id`
     * const accountWithIdOnly = await prisma.account.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AccountCreateManyAndReturnArgs>(args?: SelectSubset<T, AccountCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Account.
     * @param {AccountDeleteArgs} args - Arguments to delete one Account.
     * @example
     * // Delete one Account
     * const Account = await prisma.account.delete({
     *   where: {
     *     // ... filter to delete one Account
     *   }
     * })
     * 
     */
    delete<T extends AccountDeleteArgs>(args: SelectSubset<T, AccountDeleteArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Account.
     * @param {AccountUpdateArgs} args - Arguments to update one Account.
     * @example
     * // Update one Account
     * const account = await prisma.account.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AccountUpdateArgs>(args: SelectSubset<T, AccountUpdateArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Accounts.
     * @param {AccountDeleteManyArgs} args - Arguments to filter Accounts to delete.
     * @example
     * // Delete a few Accounts
     * const { count } = await prisma.account.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AccountDeleteManyArgs>(args?: SelectSubset<T, AccountDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Accounts
     * const account = await prisma.account.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AccountUpdateManyArgs>(args: SelectSubset<T, AccountUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Accounts and returns the data updated in the database.
     * @param {AccountUpdateManyAndReturnArgs} args - Arguments to update many Accounts.
     * @example
     * // Update many Accounts
     * const account = await prisma.account.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Accounts and only return the `id`
     * const accountWithIdOnly = await prisma.account.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AccountUpdateManyAndReturnArgs>(args: SelectSubset<T, AccountUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Account.
     * @param {AccountUpsertArgs} args - Arguments to update or create a Account.
     * @example
     * // Update or create a Account
     * const account = await prisma.account.upsert({
     *   create: {
     *     // ... data to create a Account
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Account we want to update
     *   }
     * })
     */
    upsert<T extends AccountUpsertArgs>(args: SelectSubset<T, AccountUpsertArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountCountArgs} args - Arguments to filter Accounts to count.
     * @example
     * // Count the number of Accounts
     * const count = await prisma.account.count({
     *   where: {
     *     // ... the filter for the Accounts we want to count
     *   }
     * })
    **/
    count<T extends AccountCountArgs>(
      args?: Subset<T, AccountCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AccountCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AccountAggregateArgs>(args: Subset<T, AccountAggregateArgs>): Prisma.PrismaPromise<GetAccountAggregateType<T>>

    /**
     * Group by Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AccountGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AccountGroupByArgs['orderBy'] }
        : { orderBy?: AccountGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AccountGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAccountGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Account model
   */
  readonly fields: AccountFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Account.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AccountClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Account model
   */
  interface AccountFieldRefs {
    readonly id: FieldRef<"Account", 'String'>
    readonly userId: FieldRef<"Account", 'String'>
    readonly type: FieldRef<"Account", 'String'>
    readonly provider: FieldRef<"Account", 'String'>
    readonly providerAccountId: FieldRef<"Account", 'String'>
    readonly refresh_token: FieldRef<"Account", 'String'>
    readonly access_token: FieldRef<"Account", 'String'>
    readonly expires_at: FieldRef<"Account", 'Int'>
    readonly token_type: FieldRef<"Account", 'String'>
    readonly scope: FieldRef<"Account", 'String'>
    readonly id_token: FieldRef<"Account", 'String'>
    readonly session_state: FieldRef<"Account", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Account findUnique
   */
  export type AccountFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account findUniqueOrThrow
   */
  export type AccountFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account findFirst
   */
  export type AccountFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Accounts.
     */
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account findFirstOrThrow
   */
  export type AccountFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Accounts.
     */
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account findMany
   */
  export type AccountFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Accounts to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account create
   */
  export type AccountCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The data needed to create a Account.
     */
    data: XOR<AccountCreateInput, AccountUncheckedCreateInput>
  }

  /**
   * Account createMany
   */
  export type AccountCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Accounts.
     */
    data: AccountCreateManyInput | AccountCreateManyInput[]
  }

  /**
   * Account createManyAndReturn
   */
  export type AccountCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * The data used to create many Accounts.
     */
    data: AccountCreateManyInput | AccountCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Account update
   */
  export type AccountUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The data needed to update a Account.
     */
    data: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>
    /**
     * Choose, which Account to update.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account updateMany
   */
  export type AccountUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Accounts.
     */
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyInput>
    /**
     * Filter which Accounts to update
     */
    where?: AccountWhereInput
    /**
     * Limit how many Accounts to update.
     */
    limit?: number
  }

  /**
   * Account updateManyAndReturn
   */
  export type AccountUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * The data used to update Accounts.
     */
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyInput>
    /**
     * Filter which Accounts to update
     */
    where?: AccountWhereInput
    /**
     * Limit how many Accounts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Account upsert
   */
  export type AccountUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The filter to search for the Account to update in case it exists.
     */
    where: AccountWhereUniqueInput
    /**
     * In case the Account found by the `where` argument doesn't exist, create a new Account with this data.
     */
    create: XOR<AccountCreateInput, AccountUncheckedCreateInput>
    /**
     * In case the Account was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>
  }

  /**
   * Account delete
   */
  export type AccountDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter which Account to delete.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account deleteMany
   */
  export type AccountDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Accounts to delete
     */
    where?: AccountWhereInput
    /**
     * Limit how many Accounts to delete.
     */
    limit?: number
  }

  /**
   * Account without action
   */
  export type AccountDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
  }


  /**
   * Model Session
   */

  export type AggregateSession = {
    _count: SessionCountAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  export type SessionMinAggregateOutputType = {
    id: string | null
    sessionToken: string | null
    userId: string | null
    expires: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SessionMaxAggregateOutputType = {
    id: string | null
    sessionToken: string | null
    userId: string | null
    expires: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SessionCountAggregateOutputType = {
    id: number
    sessionToken: number
    userId: number
    expires: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SessionMinAggregateInputType = {
    id?: true
    sessionToken?: true
    userId?: true
    expires?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SessionMaxAggregateInputType = {
    id?: true
    sessionToken?: true
    userId?: true
    expires?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SessionCountAggregateInputType = {
    id?: true
    sessionToken?: true
    userId?: true
    expires?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Session to aggregate.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Sessions
    **/
    _count?: true | SessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SessionMaxAggregateInputType
  }

  export type GetSessionAggregateType<T extends SessionAggregateArgs> = {
        [P in keyof T & keyof AggregateSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSession[P]>
      : GetScalarType<T[P], AggregateSession[P]>
  }




  export type SessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithAggregationInput | SessionOrderByWithAggregationInput[]
    by: SessionScalarFieldEnum[] | SessionScalarFieldEnum
    having?: SessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SessionCountAggregateInputType | true
    _min?: SessionMinAggregateInputType
    _max?: SessionMaxAggregateInputType
  }

  export type SessionGroupByOutputType = {
    id: string
    sessionToken: string
    userId: string
    expires: Date
    createdAt: Date
    updatedAt: Date
    _count: SessionCountAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  type GetSessionGroupByPayload<T extends SessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SessionGroupByOutputType[P]>
            : GetScalarType<T[P], SessionGroupByOutputType[P]>
        }
      >
    >


  export type SessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionToken?: boolean
    userId?: boolean
    expires?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionToken?: boolean
    userId?: boolean
    expires?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionToken?: boolean
    userId?: boolean
    expires?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectScalar = {
    id?: boolean
    sessionToken?: boolean
    userId?: boolean
    expires?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SessionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "sessionToken" | "userId" | "expires" | "createdAt" | "updatedAt", ExtArgs["result"]["session"]>
  export type SessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SessionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SessionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $SessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Session"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      sessionToken: string
      userId: string
      expires: Date
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["session"]>
    composites: {}
  }

  type SessionGetPayload<S extends boolean | null | undefined | SessionDefaultArgs> = $Result.GetResult<Prisma.$SessionPayload, S>

  type SessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SessionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SessionCountAggregateInputType | true
    }

  export interface SessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Session'], meta: { name: 'Session' } }
    /**
     * Find zero or one Session that matches the filter.
     * @param {SessionFindUniqueArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SessionFindUniqueArgs>(args: SelectSubset<T, SessionFindUniqueArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Session that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SessionFindUniqueOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SessionFindUniqueOrThrowArgs>(args: SelectSubset<T, SessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Session that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SessionFindFirstArgs>(args?: SelectSubset<T, SessionFindFirstArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Session that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SessionFindFirstOrThrowArgs>(args?: SelectSubset<T, SessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Sessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sessions
     * const sessions = await prisma.session.findMany()
     * 
     * // Get first 10 Sessions
     * const sessions = await prisma.session.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sessionWithIdOnly = await prisma.session.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SessionFindManyArgs>(args?: SelectSubset<T, SessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Session.
     * @param {SessionCreateArgs} args - Arguments to create a Session.
     * @example
     * // Create one Session
     * const Session = await prisma.session.create({
     *   data: {
     *     // ... data to create a Session
     *   }
     * })
     * 
     */
    create<T extends SessionCreateArgs>(args: SelectSubset<T, SessionCreateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Sessions.
     * @param {SessionCreateManyArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SessionCreateManyArgs>(args?: SelectSubset<T, SessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Sessions and returns the data saved in the database.
     * @param {SessionCreateManyAndReturnArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Sessions and only return the `id`
     * const sessionWithIdOnly = await prisma.session.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SessionCreateManyAndReturnArgs>(args?: SelectSubset<T, SessionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Session.
     * @param {SessionDeleteArgs} args - Arguments to delete one Session.
     * @example
     * // Delete one Session
     * const Session = await prisma.session.delete({
     *   where: {
     *     // ... filter to delete one Session
     *   }
     * })
     * 
     */
    delete<T extends SessionDeleteArgs>(args: SelectSubset<T, SessionDeleteArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Session.
     * @param {SessionUpdateArgs} args - Arguments to update one Session.
     * @example
     * // Update one Session
     * const session = await prisma.session.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SessionUpdateArgs>(args: SelectSubset<T, SessionUpdateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Sessions.
     * @param {SessionDeleteManyArgs} args - Arguments to filter Sessions to delete.
     * @example
     * // Delete a few Sessions
     * const { count } = await prisma.session.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SessionDeleteManyArgs>(args?: SelectSubset<T, SessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sessions
     * const session = await prisma.session.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SessionUpdateManyArgs>(args: SelectSubset<T, SessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions and returns the data updated in the database.
     * @param {SessionUpdateManyAndReturnArgs} args - Arguments to update many Sessions.
     * @example
     * // Update many Sessions
     * const session = await prisma.session.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Sessions and only return the `id`
     * const sessionWithIdOnly = await prisma.session.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SessionUpdateManyAndReturnArgs>(args: SelectSubset<T, SessionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Session.
     * @param {SessionUpsertArgs} args - Arguments to update or create a Session.
     * @example
     * // Update or create a Session
     * const session = await prisma.session.upsert({
     *   create: {
     *     // ... data to create a Session
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Session we want to update
     *   }
     * })
     */
    upsert<T extends SessionUpsertArgs>(args: SelectSubset<T, SessionUpsertArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionCountArgs} args - Arguments to filter Sessions to count.
     * @example
     * // Count the number of Sessions
     * const count = await prisma.session.count({
     *   where: {
     *     // ... the filter for the Sessions we want to count
     *   }
     * })
    **/
    count<T extends SessionCountArgs>(
      args?: Subset<T, SessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SessionAggregateArgs>(args: Subset<T, SessionAggregateArgs>): Prisma.PrismaPromise<GetSessionAggregateType<T>>

    /**
     * Group by Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SessionGroupByArgs['orderBy'] }
        : { orderBy?: SessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Session model
   */
  readonly fields: SessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Session.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Session model
   */
  interface SessionFieldRefs {
    readonly id: FieldRef<"Session", 'String'>
    readonly sessionToken: FieldRef<"Session", 'String'>
    readonly userId: FieldRef<"Session", 'String'>
    readonly expires: FieldRef<"Session", 'DateTime'>
    readonly createdAt: FieldRef<"Session", 'DateTime'>
    readonly updatedAt: FieldRef<"Session", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Session findUnique
   */
  export type SessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findUniqueOrThrow
   */
  export type SessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findFirst
   */
  export type SessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findFirstOrThrow
   */
  export type SessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findMany
   */
  export type SessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Sessions to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session create
   */
  export type SessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to create a Session.
     */
    data: XOR<SessionCreateInput, SessionUncheckedCreateInput>
  }

  /**
   * Session createMany
   */
  export type SessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[]
  }

  /**
   * Session createManyAndReturn
   */
  export type SessionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Session update
   */
  export type SessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to update a Session.
     */
    data: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
    /**
     * Choose, which Session to update.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session updateMany
   */
  export type SessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Sessions.
     */
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyInput>
    /**
     * Filter which Sessions to update
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to update.
     */
    limit?: number
  }

  /**
   * Session updateManyAndReturn
   */
  export type SessionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * The data used to update Sessions.
     */
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyInput>
    /**
     * Filter which Sessions to update
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Session upsert
   */
  export type SessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The filter to search for the Session to update in case it exists.
     */
    where: SessionWhereUniqueInput
    /**
     * In case the Session found by the `where` argument doesn't exist, create a new Session with this data.
     */
    create: XOR<SessionCreateInput, SessionUncheckedCreateInput>
    /**
     * In case the Session was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
  }

  /**
   * Session delete
   */
  export type SessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter which Session to delete.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session deleteMany
   */
  export type SessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sessions to delete
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to delete.
     */
    limit?: number
  }

  /**
   * Session without action
   */
  export type SessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
  }


  /**
   * Model VerificationToken
   */

  export type AggregateVerificationToken = {
    _count: VerificationTokenCountAggregateOutputType | null
    _min: VerificationTokenMinAggregateOutputType | null
    _max: VerificationTokenMaxAggregateOutputType | null
  }

  export type VerificationTokenMinAggregateOutputType = {
    identifier: string | null
    token: string | null
    expires: Date | null
  }

  export type VerificationTokenMaxAggregateOutputType = {
    identifier: string | null
    token: string | null
    expires: Date | null
  }

  export type VerificationTokenCountAggregateOutputType = {
    identifier: number
    token: number
    expires: number
    _all: number
  }


  export type VerificationTokenMinAggregateInputType = {
    identifier?: true
    token?: true
    expires?: true
  }

  export type VerificationTokenMaxAggregateInputType = {
    identifier?: true
    token?: true
    expires?: true
  }

  export type VerificationTokenCountAggregateInputType = {
    identifier?: true
    token?: true
    expires?: true
    _all?: true
  }

  export type VerificationTokenAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VerificationToken to aggregate.
     */
    where?: VerificationTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationTokens to fetch.
     */
    orderBy?: VerificationTokenOrderByWithRelationInput | VerificationTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VerificationTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned VerificationTokens
    **/
    _count?: true | VerificationTokenCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VerificationTokenMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VerificationTokenMaxAggregateInputType
  }

  export type GetVerificationTokenAggregateType<T extends VerificationTokenAggregateArgs> = {
        [P in keyof T & keyof AggregateVerificationToken]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVerificationToken[P]>
      : GetScalarType<T[P], AggregateVerificationToken[P]>
  }




  export type VerificationTokenGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VerificationTokenWhereInput
    orderBy?: VerificationTokenOrderByWithAggregationInput | VerificationTokenOrderByWithAggregationInput[]
    by: VerificationTokenScalarFieldEnum[] | VerificationTokenScalarFieldEnum
    having?: VerificationTokenScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VerificationTokenCountAggregateInputType | true
    _min?: VerificationTokenMinAggregateInputType
    _max?: VerificationTokenMaxAggregateInputType
  }

  export type VerificationTokenGroupByOutputType = {
    identifier: string
    token: string
    expires: Date
    _count: VerificationTokenCountAggregateOutputType | null
    _min: VerificationTokenMinAggregateOutputType | null
    _max: VerificationTokenMaxAggregateOutputType | null
  }

  type GetVerificationTokenGroupByPayload<T extends VerificationTokenGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VerificationTokenGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VerificationTokenGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VerificationTokenGroupByOutputType[P]>
            : GetScalarType<T[P], VerificationTokenGroupByOutputType[P]>
        }
      >
    >


  export type VerificationTokenSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    identifier?: boolean
    token?: boolean
    expires?: boolean
  }, ExtArgs["result"]["verificationToken"]>

  export type VerificationTokenSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    identifier?: boolean
    token?: boolean
    expires?: boolean
  }, ExtArgs["result"]["verificationToken"]>

  export type VerificationTokenSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    identifier?: boolean
    token?: boolean
    expires?: boolean
  }, ExtArgs["result"]["verificationToken"]>

  export type VerificationTokenSelectScalar = {
    identifier?: boolean
    token?: boolean
    expires?: boolean
  }

  export type VerificationTokenOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"identifier" | "token" | "expires", ExtArgs["result"]["verificationToken"]>

  export type $VerificationTokenPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "VerificationToken"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      identifier: string
      token: string
      expires: Date
    }, ExtArgs["result"]["verificationToken"]>
    composites: {}
  }

  type VerificationTokenGetPayload<S extends boolean | null | undefined | VerificationTokenDefaultArgs> = $Result.GetResult<Prisma.$VerificationTokenPayload, S>

  type VerificationTokenCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VerificationTokenFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VerificationTokenCountAggregateInputType | true
    }

  export interface VerificationTokenDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['VerificationToken'], meta: { name: 'VerificationToken' } }
    /**
     * Find zero or one VerificationToken that matches the filter.
     * @param {VerificationTokenFindUniqueArgs} args - Arguments to find a VerificationToken
     * @example
     * // Get one VerificationToken
     * const verificationToken = await prisma.verificationToken.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VerificationTokenFindUniqueArgs>(args: SelectSubset<T, VerificationTokenFindUniqueArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one VerificationToken that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VerificationTokenFindUniqueOrThrowArgs} args - Arguments to find a VerificationToken
     * @example
     * // Get one VerificationToken
     * const verificationToken = await prisma.verificationToken.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VerificationTokenFindUniqueOrThrowArgs>(args: SelectSubset<T, VerificationTokenFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VerificationToken that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenFindFirstArgs} args - Arguments to find a VerificationToken
     * @example
     * // Get one VerificationToken
     * const verificationToken = await prisma.verificationToken.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VerificationTokenFindFirstArgs>(args?: SelectSubset<T, VerificationTokenFindFirstArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VerificationToken that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenFindFirstOrThrowArgs} args - Arguments to find a VerificationToken
     * @example
     * // Get one VerificationToken
     * const verificationToken = await prisma.verificationToken.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VerificationTokenFindFirstOrThrowArgs>(args?: SelectSubset<T, VerificationTokenFindFirstOrThrowArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more VerificationTokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VerificationTokens
     * const verificationTokens = await prisma.verificationToken.findMany()
     * 
     * // Get first 10 VerificationTokens
     * const verificationTokens = await prisma.verificationToken.findMany({ take: 10 })
     * 
     * // Only select the `identifier`
     * const verificationTokenWithIdentifierOnly = await prisma.verificationToken.findMany({ select: { identifier: true } })
     * 
     */
    findMany<T extends VerificationTokenFindManyArgs>(args?: SelectSubset<T, VerificationTokenFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a VerificationToken.
     * @param {VerificationTokenCreateArgs} args - Arguments to create a VerificationToken.
     * @example
     * // Create one VerificationToken
     * const VerificationToken = await prisma.verificationToken.create({
     *   data: {
     *     // ... data to create a VerificationToken
     *   }
     * })
     * 
     */
    create<T extends VerificationTokenCreateArgs>(args: SelectSubset<T, VerificationTokenCreateArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many VerificationTokens.
     * @param {VerificationTokenCreateManyArgs} args - Arguments to create many VerificationTokens.
     * @example
     * // Create many VerificationTokens
     * const verificationToken = await prisma.verificationToken.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VerificationTokenCreateManyArgs>(args?: SelectSubset<T, VerificationTokenCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many VerificationTokens and returns the data saved in the database.
     * @param {VerificationTokenCreateManyAndReturnArgs} args - Arguments to create many VerificationTokens.
     * @example
     * // Create many VerificationTokens
     * const verificationToken = await prisma.verificationToken.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many VerificationTokens and only return the `identifier`
     * const verificationTokenWithIdentifierOnly = await prisma.verificationToken.createManyAndReturn({
     *   select: { identifier: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VerificationTokenCreateManyAndReturnArgs>(args?: SelectSubset<T, VerificationTokenCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a VerificationToken.
     * @param {VerificationTokenDeleteArgs} args - Arguments to delete one VerificationToken.
     * @example
     * // Delete one VerificationToken
     * const VerificationToken = await prisma.verificationToken.delete({
     *   where: {
     *     // ... filter to delete one VerificationToken
     *   }
     * })
     * 
     */
    delete<T extends VerificationTokenDeleteArgs>(args: SelectSubset<T, VerificationTokenDeleteArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one VerificationToken.
     * @param {VerificationTokenUpdateArgs} args - Arguments to update one VerificationToken.
     * @example
     * // Update one VerificationToken
     * const verificationToken = await prisma.verificationToken.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VerificationTokenUpdateArgs>(args: SelectSubset<T, VerificationTokenUpdateArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more VerificationTokens.
     * @param {VerificationTokenDeleteManyArgs} args - Arguments to filter VerificationTokens to delete.
     * @example
     * // Delete a few VerificationTokens
     * const { count } = await prisma.verificationToken.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VerificationTokenDeleteManyArgs>(args?: SelectSubset<T, VerificationTokenDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VerificationTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VerificationTokens
     * const verificationToken = await prisma.verificationToken.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VerificationTokenUpdateManyArgs>(args: SelectSubset<T, VerificationTokenUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VerificationTokens and returns the data updated in the database.
     * @param {VerificationTokenUpdateManyAndReturnArgs} args - Arguments to update many VerificationTokens.
     * @example
     * // Update many VerificationTokens
     * const verificationToken = await prisma.verificationToken.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more VerificationTokens and only return the `identifier`
     * const verificationTokenWithIdentifierOnly = await prisma.verificationToken.updateManyAndReturn({
     *   select: { identifier: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends VerificationTokenUpdateManyAndReturnArgs>(args: SelectSubset<T, VerificationTokenUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one VerificationToken.
     * @param {VerificationTokenUpsertArgs} args - Arguments to update or create a VerificationToken.
     * @example
     * // Update or create a VerificationToken
     * const verificationToken = await prisma.verificationToken.upsert({
     *   create: {
     *     // ... data to create a VerificationToken
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VerificationToken we want to update
     *   }
     * })
     */
    upsert<T extends VerificationTokenUpsertArgs>(args: SelectSubset<T, VerificationTokenUpsertArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of VerificationTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenCountArgs} args - Arguments to filter VerificationTokens to count.
     * @example
     * // Count the number of VerificationTokens
     * const count = await prisma.verificationToken.count({
     *   where: {
     *     // ... the filter for the VerificationTokens we want to count
     *   }
     * })
    **/
    count<T extends VerificationTokenCountArgs>(
      args?: Subset<T, VerificationTokenCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VerificationTokenCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a VerificationToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VerificationTokenAggregateArgs>(args: Subset<T, VerificationTokenAggregateArgs>): Prisma.PrismaPromise<GetVerificationTokenAggregateType<T>>

    /**
     * Group by VerificationToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VerificationTokenGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VerificationTokenGroupByArgs['orderBy'] }
        : { orderBy?: VerificationTokenGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VerificationTokenGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVerificationTokenGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the VerificationToken model
   */
  readonly fields: VerificationTokenFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for VerificationToken.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VerificationTokenClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the VerificationToken model
   */
  interface VerificationTokenFieldRefs {
    readonly identifier: FieldRef<"VerificationToken", 'String'>
    readonly token: FieldRef<"VerificationToken", 'String'>
    readonly expires: FieldRef<"VerificationToken", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * VerificationToken findUnique
   */
  export type VerificationTokenFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * Filter, which VerificationToken to fetch.
     */
    where: VerificationTokenWhereUniqueInput
  }

  /**
   * VerificationToken findUniqueOrThrow
   */
  export type VerificationTokenFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * Filter, which VerificationToken to fetch.
     */
    where: VerificationTokenWhereUniqueInput
  }

  /**
   * VerificationToken findFirst
   */
  export type VerificationTokenFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * Filter, which VerificationToken to fetch.
     */
    where?: VerificationTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationTokens to fetch.
     */
    orderBy?: VerificationTokenOrderByWithRelationInput | VerificationTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VerificationTokens.
     */
    cursor?: VerificationTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VerificationTokens.
     */
    distinct?: VerificationTokenScalarFieldEnum | VerificationTokenScalarFieldEnum[]
  }

  /**
   * VerificationToken findFirstOrThrow
   */
  export type VerificationTokenFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * Filter, which VerificationToken to fetch.
     */
    where?: VerificationTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationTokens to fetch.
     */
    orderBy?: VerificationTokenOrderByWithRelationInput | VerificationTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VerificationTokens.
     */
    cursor?: VerificationTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VerificationTokens.
     */
    distinct?: VerificationTokenScalarFieldEnum | VerificationTokenScalarFieldEnum[]
  }

  /**
   * VerificationToken findMany
   */
  export type VerificationTokenFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * Filter, which VerificationTokens to fetch.
     */
    where?: VerificationTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationTokens to fetch.
     */
    orderBy?: VerificationTokenOrderByWithRelationInput | VerificationTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing VerificationTokens.
     */
    cursor?: VerificationTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationTokens.
     */
    skip?: number
    distinct?: VerificationTokenScalarFieldEnum | VerificationTokenScalarFieldEnum[]
  }

  /**
   * VerificationToken create
   */
  export type VerificationTokenCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * The data needed to create a VerificationToken.
     */
    data: XOR<VerificationTokenCreateInput, VerificationTokenUncheckedCreateInput>
  }

  /**
   * VerificationToken createMany
   */
  export type VerificationTokenCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many VerificationTokens.
     */
    data: VerificationTokenCreateManyInput | VerificationTokenCreateManyInput[]
  }

  /**
   * VerificationToken createManyAndReturn
   */
  export type VerificationTokenCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * The data used to create many VerificationTokens.
     */
    data: VerificationTokenCreateManyInput | VerificationTokenCreateManyInput[]
  }

  /**
   * VerificationToken update
   */
  export type VerificationTokenUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * The data needed to update a VerificationToken.
     */
    data: XOR<VerificationTokenUpdateInput, VerificationTokenUncheckedUpdateInput>
    /**
     * Choose, which VerificationToken to update.
     */
    where: VerificationTokenWhereUniqueInput
  }

  /**
   * VerificationToken updateMany
   */
  export type VerificationTokenUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update VerificationTokens.
     */
    data: XOR<VerificationTokenUpdateManyMutationInput, VerificationTokenUncheckedUpdateManyInput>
    /**
     * Filter which VerificationTokens to update
     */
    where?: VerificationTokenWhereInput
    /**
     * Limit how many VerificationTokens to update.
     */
    limit?: number
  }

  /**
   * VerificationToken updateManyAndReturn
   */
  export type VerificationTokenUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * The data used to update VerificationTokens.
     */
    data: XOR<VerificationTokenUpdateManyMutationInput, VerificationTokenUncheckedUpdateManyInput>
    /**
     * Filter which VerificationTokens to update
     */
    where?: VerificationTokenWhereInput
    /**
     * Limit how many VerificationTokens to update.
     */
    limit?: number
  }

  /**
   * VerificationToken upsert
   */
  export type VerificationTokenUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * The filter to search for the VerificationToken to update in case it exists.
     */
    where: VerificationTokenWhereUniqueInput
    /**
     * In case the VerificationToken found by the `where` argument doesn't exist, create a new VerificationToken with this data.
     */
    create: XOR<VerificationTokenCreateInput, VerificationTokenUncheckedCreateInput>
    /**
     * In case the VerificationToken was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VerificationTokenUpdateInput, VerificationTokenUncheckedUpdateInput>
  }

  /**
   * VerificationToken delete
   */
  export type VerificationTokenDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * Filter which VerificationToken to delete.
     */
    where: VerificationTokenWhereUniqueInput
  }

  /**
   * VerificationToken deleteMany
   */
  export type VerificationTokenDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VerificationTokens to delete
     */
    where?: VerificationTokenWhereInput
    /**
     * Limit how many VerificationTokens to delete.
     */
    limit?: number
  }

  /**
   * VerificationToken without action
   */
  export type VerificationTokenDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
  }


  /**
   * Model LandingPage
   */

  export type AggregateLandingPage = {
    _count: LandingPageCountAggregateOutputType | null
    _min: LandingPageMinAggregateOutputType | null
    _max: LandingPageMaxAggregateOutputType | null
  }

  export type LandingPageMinAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    description: string | null
    image: string | null
    lpDesignStyleId: string | null
    marketingTools: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LandingPageMaxAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    description: string | null
    image: string | null
    lpDesignStyleId: string | null
    marketingTools: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LandingPageCountAggregateOutputType = {
    id: number
    name: number
    slug: number
    description: number
    image: number
    lpDesignStyleId: number
    marketingTools: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type LandingPageMinAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    description?: true
    image?: true
    lpDesignStyleId?: true
    marketingTools?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LandingPageMaxAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    description?: true
    image?: true
    lpDesignStyleId?: true
    marketingTools?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LandingPageCountAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    description?: true
    image?: true
    lpDesignStyleId?: true
    marketingTools?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type LandingPageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LandingPage to aggregate.
     */
    where?: LandingPageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LandingPages to fetch.
     */
    orderBy?: LandingPageOrderByWithRelationInput | LandingPageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LandingPageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LandingPages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LandingPages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LandingPages
    **/
    _count?: true | LandingPageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LandingPageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LandingPageMaxAggregateInputType
  }

  export type GetLandingPageAggregateType<T extends LandingPageAggregateArgs> = {
        [P in keyof T & keyof AggregateLandingPage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLandingPage[P]>
      : GetScalarType<T[P], AggregateLandingPage[P]>
  }




  export type LandingPageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LandingPageWhereInput
    orderBy?: LandingPageOrderByWithAggregationInput | LandingPageOrderByWithAggregationInput[]
    by: LandingPageScalarFieldEnum[] | LandingPageScalarFieldEnum
    having?: LandingPageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LandingPageCountAggregateInputType | true
    _min?: LandingPageMinAggregateInputType
    _max?: LandingPageMaxAggregateInputType
  }

  export type LandingPageGroupByOutputType = {
    id: string
    name: string
    slug: string
    description: string
    image: string
    lpDesignStyleId: string | null
    marketingTools: string | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: LandingPageCountAggregateOutputType | null
    _min: LandingPageMinAggregateOutputType | null
    _max: LandingPageMaxAggregateOutputType | null
  }

  type GetLandingPageGroupByPayload<T extends LandingPageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LandingPageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LandingPageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LandingPageGroupByOutputType[P]>
            : GetScalarType<T[P], LandingPageGroupByOutputType[P]>
        }
      >
    >


  export type LandingPageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    description?: boolean
    image?: boolean
    lpDesignStyleId?: boolean
    marketingTools?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lpFor?: boolean | LandingPage$lpForArgs<ExtArgs>
    lpContentTypes?: boolean | LandingPage$lpContentTypesArgs<ExtArgs>
    lpDesignStyle?: boolean | LandingPage$lpDesignStyleArgs<ExtArgs>
    _count?: boolean | LandingPageCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["landingPage"]>

  export type LandingPageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    description?: boolean
    image?: boolean
    lpDesignStyleId?: boolean
    marketingTools?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lpDesignStyle?: boolean | LandingPage$lpDesignStyleArgs<ExtArgs>
  }, ExtArgs["result"]["landingPage"]>

  export type LandingPageSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    description?: boolean
    image?: boolean
    lpDesignStyleId?: boolean
    marketingTools?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lpDesignStyle?: boolean | LandingPage$lpDesignStyleArgs<ExtArgs>
  }, ExtArgs["result"]["landingPage"]>

  export type LandingPageSelectScalar = {
    id?: boolean
    name?: boolean
    slug?: boolean
    description?: boolean
    image?: boolean
    lpDesignStyleId?: boolean
    marketingTools?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type LandingPageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "slug" | "description" | "image" | "lpDesignStyleId" | "marketingTools" | "isActive" | "createdAt" | "updatedAt", ExtArgs["result"]["landingPage"]>
  export type LandingPageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lpFor?: boolean | LandingPage$lpForArgs<ExtArgs>
    lpContentTypes?: boolean | LandingPage$lpContentTypesArgs<ExtArgs>
    lpDesignStyle?: boolean | LandingPage$lpDesignStyleArgs<ExtArgs>
    _count?: boolean | LandingPageCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type LandingPageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lpDesignStyle?: boolean | LandingPage$lpDesignStyleArgs<ExtArgs>
  }
  export type LandingPageIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lpDesignStyle?: boolean | LandingPage$lpDesignStyleArgs<ExtArgs>
  }

  export type $LandingPagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LandingPage"
    objects: {
      lpFor: Prisma.$LpForPayload<ExtArgs>[]
      lpContentTypes: Prisma.$LpContentTypePayload<ExtArgs>[]
      lpDesignStyle: Prisma.$LpDesignStylePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      slug: string
      description: string
      image: string
      lpDesignStyleId: string | null
      marketingTools: string | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["landingPage"]>
    composites: {}
  }

  type LandingPageGetPayload<S extends boolean | null | undefined | LandingPageDefaultArgs> = $Result.GetResult<Prisma.$LandingPagePayload, S>

  type LandingPageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LandingPageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LandingPageCountAggregateInputType | true
    }

  export interface LandingPageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LandingPage'], meta: { name: 'LandingPage' } }
    /**
     * Find zero or one LandingPage that matches the filter.
     * @param {LandingPageFindUniqueArgs} args - Arguments to find a LandingPage
     * @example
     * // Get one LandingPage
     * const landingPage = await prisma.landingPage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LandingPageFindUniqueArgs>(args: SelectSubset<T, LandingPageFindUniqueArgs<ExtArgs>>): Prisma__LandingPageClient<$Result.GetResult<Prisma.$LandingPagePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one LandingPage that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LandingPageFindUniqueOrThrowArgs} args - Arguments to find a LandingPage
     * @example
     * // Get one LandingPage
     * const landingPage = await prisma.landingPage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LandingPageFindUniqueOrThrowArgs>(args: SelectSubset<T, LandingPageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LandingPageClient<$Result.GetResult<Prisma.$LandingPagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LandingPage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LandingPageFindFirstArgs} args - Arguments to find a LandingPage
     * @example
     * // Get one LandingPage
     * const landingPage = await prisma.landingPage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LandingPageFindFirstArgs>(args?: SelectSubset<T, LandingPageFindFirstArgs<ExtArgs>>): Prisma__LandingPageClient<$Result.GetResult<Prisma.$LandingPagePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LandingPage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LandingPageFindFirstOrThrowArgs} args - Arguments to find a LandingPage
     * @example
     * // Get one LandingPage
     * const landingPage = await prisma.landingPage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LandingPageFindFirstOrThrowArgs>(args?: SelectSubset<T, LandingPageFindFirstOrThrowArgs<ExtArgs>>): Prisma__LandingPageClient<$Result.GetResult<Prisma.$LandingPagePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more LandingPages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LandingPageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LandingPages
     * const landingPages = await prisma.landingPage.findMany()
     * 
     * // Get first 10 LandingPages
     * const landingPages = await prisma.landingPage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const landingPageWithIdOnly = await prisma.landingPage.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LandingPageFindManyArgs>(args?: SelectSubset<T, LandingPageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LandingPagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a LandingPage.
     * @param {LandingPageCreateArgs} args - Arguments to create a LandingPage.
     * @example
     * // Create one LandingPage
     * const LandingPage = await prisma.landingPage.create({
     *   data: {
     *     // ... data to create a LandingPage
     *   }
     * })
     * 
     */
    create<T extends LandingPageCreateArgs>(args: SelectSubset<T, LandingPageCreateArgs<ExtArgs>>): Prisma__LandingPageClient<$Result.GetResult<Prisma.$LandingPagePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many LandingPages.
     * @param {LandingPageCreateManyArgs} args - Arguments to create many LandingPages.
     * @example
     * // Create many LandingPages
     * const landingPage = await prisma.landingPage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LandingPageCreateManyArgs>(args?: SelectSubset<T, LandingPageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many LandingPages and returns the data saved in the database.
     * @param {LandingPageCreateManyAndReturnArgs} args - Arguments to create many LandingPages.
     * @example
     * // Create many LandingPages
     * const landingPage = await prisma.landingPage.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many LandingPages and only return the `id`
     * const landingPageWithIdOnly = await prisma.landingPage.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LandingPageCreateManyAndReturnArgs>(args?: SelectSubset<T, LandingPageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LandingPagePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a LandingPage.
     * @param {LandingPageDeleteArgs} args - Arguments to delete one LandingPage.
     * @example
     * // Delete one LandingPage
     * const LandingPage = await prisma.landingPage.delete({
     *   where: {
     *     // ... filter to delete one LandingPage
     *   }
     * })
     * 
     */
    delete<T extends LandingPageDeleteArgs>(args: SelectSubset<T, LandingPageDeleteArgs<ExtArgs>>): Prisma__LandingPageClient<$Result.GetResult<Prisma.$LandingPagePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one LandingPage.
     * @param {LandingPageUpdateArgs} args - Arguments to update one LandingPage.
     * @example
     * // Update one LandingPage
     * const landingPage = await prisma.landingPage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LandingPageUpdateArgs>(args: SelectSubset<T, LandingPageUpdateArgs<ExtArgs>>): Prisma__LandingPageClient<$Result.GetResult<Prisma.$LandingPagePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more LandingPages.
     * @param {LandingPageDeleteManyArgs} args - Arguments to filter LandingPages to delete.
     * @example
     * // Delete a few LandingPages
     * const { count } = await prisma.landingPage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LandingPageDeleteManyArgs>(args?: SelectSubset<T, LandingPageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LandingPages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LandingPageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LandingPages
     * const landingPage = await prisma.landingPage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LandingPageUpdateManyArgs>(args: SelectSubset<T, LandingPageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LandingPages and returns the data updated in the database.
     * @param {LandingPageUpdateManyAndReturnArgs} args - Arguments to update many LandingPages.
     * @example
     * // Update many LandingPages
     * const landingPage = await prisma.landingPage.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more LandingPages and only return the `id`
     * const landingPageWithIdOnly = await prisma.landingPage.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LandingPageUpdateManyAndReturnArgs>(args: SelectSubset<T, LandingPageUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LandingPagePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one LandingPage.
     * @param {LandingPageUpsertArgs} args - Arguments to update or create a LandingPage.
     * @example
     * // Update or create a LandingPage
     * const landingPage = await prisma.landingPage.upsert({
     *   create: {
     *     // ... data to create a LandingPage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LandingPage we want to update
     *   }
     * })
     */
    upsert<T extends LandingPageUpsertArgs>(args: SelectSubset<T, LandingPageUpsertArgs<ExtArgs>>): Prisma__LandingPageClient<$Result.GetResult<Prisma.$LandingPagePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of LandingPages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LandingPageCountArgs} args - Arguments to filter LandingPages to count.
     * @example
     * // Count the number of LandingPages
     * const count = await prisma.landingPage.count({
     *   where: {
     *     // ... the filter for the LandingPages we want to count
     *   }
     * })
    **/
    count<T extends LandingPageCountArgs>(
      args?: Subset<T, LandingPageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LandingPageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LandingPage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LandingPageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LandingPageAggregateArgs>(args: Subset<T, LandingPageAggregateArgs>): Prisma.PrismaPromise<GetLandingPageAggregateType<T>>

    /**
     * Group by LandingPage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LandingPageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LandingPageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LandingPageGroupByArgs['orderBy'] }
        : { orderBy?: LandingPageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LandingPageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLandingPageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LandingPage model
   */
  readonly fields: LandingPageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LandingPage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LandingPageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    lpFor<T extends LandingPage$lpForArgs<ExtArgs> = {}>(args?: Subset<T, LandingPage$lpForArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LpForPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    lpContentTypes<T extends LandingPage$lpContentTypesArgs<ExtArgs> = {}>(args?: Subset<T, LandingPage$lpContentTypesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LpContentTypePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    lpDesignStyle<T extends LandingPage$lpDesignStyleArgs<ExtArgs> = {}>(args?: Subset<T, LandingPage$lpDesignStyleArgs<ExtArgs>>): Prisma__LpDesignStyleClient<$Result.GetResult<Prisma.$LpDesignStylePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LandingPage model
   */
  interface LandingPageFieldRefs {
    readonly id: FieldRef<"LandingPage", 'String'>
    readonly name: FieldRef<"LandingPage", 'String'>
    readonly slug: FieldRef<"LandingPage", 'String'>
    readonly description: FieldRef<"LandingPage", 'String'>
    readonly image: FieldRef<"LandingPage", 'String'>
    readonly lpDesignStyleId: FieldRef<"LandingPage", 'String'>
    readonly marketingTools: FieldRef<"LandingPage", 'String'>
    readonly isActive: FieldRef<"LandingPage", 'Boolean'>
    readonly createdAt: FieldRef<"LandingPage", 'DateTime'>
    readonly updatedAt: FieldRef<"LandingPage", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * LandingPage findUnique
   */
  export type LandingPageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LandingPage
     */
    select?: LandingPageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LandingPage
     */
    omit?: LandingPageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LandingPageInclude<ExtArgs> | null
    /**
     * Filter, which LandingPage to fetch.
     */
    where: LandingPageWhereUniqueInput
  }

  /**
   * LandingPage findUniqueOrThrow
   */
  export type LandingPageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LandingPage
     */
    select?: LandingPageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LandingPage
     */
    omit?: LandingPageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LandingPageInclude<ExtArgs> | null
    /**
     * Filter, which LandingPage to fetch.
     */
    where: LandingPageWhereUniqueInput
  }

  /**
   * LandingPage findFirst
   */
  export type LandingPageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LandingPage
     */
    select?: LandingPageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LandingPage
     */
    omit?: LandingPageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LandingPageInclude<ExtArgs> | null
    /**
     * Filter, which LandingPage to fetch.
     */
    where?: LandingPageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LandingPages to fetch.
     */
    orderBy?: LandingPageOrderByWithRelationInput | LandingPageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LandingPages.
     */
    cursor?: LandingPageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LandingPages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LandingPages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LandingPages.
     */
    distinct?: LandingPageScalarFieldEnum | LandingPageScalarFieldEnum[]
  }

  /**
   * LandingPage findFirstOrThrow
   */
  export type LandingPageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LandingPage
     */
    select?: LandingPageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LandingPage
     */
    omit?: LandingPageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LandingPageInclude<ExtArgs> | null
    /**
     * Filter, which LandingPage to fetch.
     */
    where?: LandingPageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LandingPages to fetch.
     */
    orderBy?: LandingPageOrderByWithRelationInput | LandingPageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LandingPages.
     */
    cursor?: LandingPageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LandingPages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LandingPages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LandingPages.
     */
    distinct?: LandingPageScalarFieldEnum | LandingPageScalarFieldEnum[]
  }

  /**
   * LandingPage findMany
   */
  export type LandingPageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LandingPage
     */
    select?: LandingPageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LandingPage
     */
    omit?: LandingPageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LandingPageInclude<ExtArgs> | null
    /**
     * Filter, which LandingPages to fetch.
     */
    where?: LandingPageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LandingPages to fetch.
     */
    orderBy?: LandingPageOrderByWithRelationInput | LandingPageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LandingPages.
     */
    cursor?: LandingPageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LandingPages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LandingPages.
     */
    skip?: number
    distinct?: LandingPageScalarFieldEnum | LandingPageScalarFieldEnum[]
  }

  /**
   * LandingPage create
   */
  export type LandingPageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LandingPage
     */
    select?: LandingPageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LandingPage
     */
    omit?: LandingPageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LandingPageInclude<ExtArgs> | null
    /**
     * The data needed to create a LandingPage.
     */
    data: XOR<LandingPageCreateInput, LandingPageUncheckedCreateInput>
  }

  /**
   * LandingPage createMany
   */
  export type LandingPageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LandingPages.
     */
    data: LandingPageCreateManyInput | LandingPageCreateManyInput[]
  }

  /**
   * LandingPage createManyAndReturn
   */
  export type LandingPageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LandingPage
     */
    select?: LandingPageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LandingPage
     */
    omit?: LandingPageOmit<ExtArgs> | null
    /**
     * The data used to create many LandingPages.
     */
    data: LandingPageCreateManyInput | LandingPageCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LandingPageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * LandingPage update
   */
  export type LandingPageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LandingPage
     */
    select?: LandingPageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LandingPage
     */
    omit?: LandingPageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LandingPageInclude<ExtArgs> | null
    /**
     * The data needed to update a LandingPage.
     */
    data: XOR<LandingPageUpdateInput, LandingPageUncheckedUpdateInput>
    /**
     * Choose, which LandingPage to update.
     */
    where: LandingPageWhereUniqueInput
  }

  /**
   * LandingPage updateMany
   */
  export type LandingPageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LandingPages.
     */
    data: XOR<LandingPageUpdateManyMutationInput, LandingPageUncheckedUpdateManyInput>
    /**
     * Filter which LandingPages to update
     */
    where?: LandingPageWhereInput
    /**
     * Limit how many LandingPages to update.
     */
    limit?: number
  }

  /**
   * LandingPage updateManyAndReturn
   */
  export type LandingPageUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LandingPage
     */
    select?: LandingPageSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LandingPage
     */
    omit?: LandingPageOmit<ExtArgs> | null
    /**
     * The data used to update LandingPages.
     */
    data: XOR<LandingPageUpdateManyMutationInput, LandingPageUncheckedUpdateManyInput>
    /**
     * Filter which LandingPages to update
     */
    where?: LandingPageWhereInput
    /**
     * Limit how many LandingPages to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LandingPageIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * LandingPage upsert
   */
  export type LandingPageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LandingPage
     */
    select?: LandingPageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LandingPage
     */
    omit?: LandingPageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LandingPageInclude<ExtArgs> | null
    /**
     * The filter to search for the LandingPage to update in case it exists.
     */
    where: LandingPageWhereUniqueInput
    /**
     * In case the LandingPage found by the `where` argument doesn't exist, create a new LandingPage with this data.
     */
    create: XOR<LandingPageCreateInput, LandingPageUncheckedCreateInput>
    /**
     * In case the LandingPage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LandingPageUpdateInput, LandingPageUncheckedUpdateInput>
  }

  /**
   * LandingPage delete
   */
  export type LandingPageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LandingPage
     */
    select?: LandingPageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LandingPage
     */
    omit?: LandingPageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LandingPageInclude<ExtArgs> | null
    /**
     * Filter which LandingPage to delete.
     */
    where: LandingPageWhereUniqueInput
  }

  /**
   * LandingPage deleteMany
   */
  export type LandingPageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LandingPages to delete
     */
    where?: LandingPageWhereInput
    /**
     * Limit how many LandingPages to delete.
     */
    limit?: number
  }

  /**
   * LandingPage.lpFor
   */
  export type LandingPage$lpForArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LpFor
     */
    select?: LpForSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LpFor
     */
    omit?: LpForOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LpForInclude<ExtArgs> | null
    where?: LpForWhereInput
    orderBy?: LpForOrderByWithRelationInput | LpForOrderByWithRelationInput[]
    cursor?: LpForWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LpForScalarFieldEnum | LpForScalarFieldEnum[]
  }

  /**
   * LandingPage.lpContentTypes
   */
  export type LandingPage$lpContentTypesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LpContentType
     */
    select?: LpContentTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LpContentType
     */
    omit?: LpContentTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LpContentTypeInclude<ExtArgs> | null
    where?: LpContentTypeWhereInput
    orderBy?: LpContentTypeOrderByWithRelationInput | LpContentTypeOrderByWithRelationInput[]
    cursor?: LpContentTypeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LpContentTypeScalarFieldEnum | LpContentTypeScalarFieldEnum[]
  }

  /**
   * LandingPage.lpDesignStyle
   */
  export type LandingPage$lpDesignStyleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LpDesignStyle
     */
    select?: LpDesignStyleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LpDesignStyle
     */
    omit?: LpDesignStyleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LpDesignStyleInclude<ExtArgs> | null
    where?: LpDesignStyleWhereInput
  }

  /**
   * LandingPage without action
   */
  export type LandingPageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LandingPage
     */
    select?: LandingPageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LandingPage
     */
    omit?: LandingPageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LandingPageInclude<ExtArgs> | null
  }


  /**
   * Model LpFor
   */

  export type AggregateLpFor = {
    _count: LpForCountAggregateOutputType | null
    _min: LpForMinAggregateOutputType | null
    _max: LpForMaxAggregateOutputType | null
  }

  export type LpForMinAggregateOutputType = {
    id: string | null
    description: string | null
  }

  export type LpForMaxAggregateOutputType = {
    id: string | null
    description: string | null
  }

  export type LpForCountAggregateOutputType = {
    id: number
    description: number
    _all: number
  }


  export type LpForMinAggregateInputType = {
    id?: true
    description?: true
  }

  export type LpForMaxAggregateInputType = {
    id?: true
    description?: true
  }

  export type LpForCountAggregateInputType = {
    id?: true
    description?: true
    _all?: true
  }

  export type LpForAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LpFor to aggregate.
     */
    where?: LpForWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LpFors to fetch.
     */
    orderBy?: LpForOrderByWithRelationInput | LpForOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LpForWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LpFors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LpFors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LpFors
    **/
    _count?: true | LpForCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LpForMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LpForMaxAggregateInputType
  }

  export type GetLpForAggregateType<T extends LpForAggregateArgs> = {
        [P in keyof T & keyof AggregateLpFor]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLpFor[P]>
      : GetScalarType<T[P], AggregateLpFor[P]>
  }




  export type LpForGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LpForWhereInput
    orderBy?: LpForOrderByWithAggregationInput | LpForOrderByWithAggregationInput[]
    by: LpForScalarFieldEnum[] | LpForScalarFieldEnum
    having?: LpForScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LpForCountAggregateInputType | true
    _min?: LpForMinAggregateInputType
    _max?: LpForMaxAggregateInputType
  }

  export type LpForGroupByOutputType = {
    id: string
    description: string | null
    _count: LpForCountAggregateOutputType | null
    _min: LpForMinAggregateOutputType | null
    _max: LpForMaxAggregateOutputType | null
  }

  type GetLpForGroupByPayload<T extends LpForGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LpForGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LpForGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LpForGroupByOutputType[P]>
            : GetScalarType<T[P], LpForGroupByOutputType[P]>
        }
      >
    >


  export type LpForSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    description?: boolean
    landingPages?: boolean | LpFor$landingPagesArgs<ExtArgs>
    _count?: boolean | LpForCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["lpFor"]>

  export type LpForSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    description?: boolean
  }, ExtArgs["result"]["lpFor"]>

  export type LpForSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    description?: boolean
  }, ExtArgs["result"]["lpFor"]>

  export type LpForSelectScalar = {
    id?: boolean
    description?: boolean
  }

  export type LpForOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "description", ExtArgs["result"]["lpFor"]>
  export type LpForInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    landingPages?: boolean | LpFor$landingPagesArgs<ExtArgs>
    _count?: boolean | LpForCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type LpForIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type LpForIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $LpForPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LpFor"
    objects: {
      landingPages: Prisma.$LandingPagePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      description: string | null
    }, ExtArgs["result"]["lpFor"]>
    composites: {}
  }

  type LpForGetPayload<S extends boolean | null | undefined | LpForDefaultArgs> = $Result.GetResult<Prisma.$LpForPayload, S>

  type LpForCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LpForFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LpForCountAggregateInputType | true
    }

  export interface LpForDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LpFor'], meta: { name: 'LpFor' } }
    /**
     * Find zero or one LpFor that matches the filter.
     * @param {LpForFindUniqueArgs} args - Arguments to find a LpFor
     * @example
     * // Get one LpFor
     * const lpFor = await prisma.lpFor.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LpForFindUniqueArgs>(args: SelectSubset<T, LpForFindUniqueArgs<ExtArgs>>): Prisma__LpForClient<$Result.GetResult<Prisma.$LpForPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one LpFor that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LpForFindUniqueOrThrowArgs} args - Arguments to find a LpFor
     * @example
     * // Get one LpFor
     * const lpFor = await prisma.lpFor.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LpForFindUniqueOrThrowArgs>(args: SelectSubset<T, LpForFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LpForClient<$Result.GetResult<Prisma.$LpForPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LpFor that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LpForFindFirstArgs} args - Arguments to find a LpFor
     * @example
     * // Get one LpFor
     * const lpFor = await prisma.lpFor.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LpForFindFirstArgs>(args?: SelectSubset<T, LpForFindFirstArgs<ExtArgs>>): Prisma__LpForClient<$Result.GetResult<Prisma.$LpForPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LpFor that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LpForFindFirstOrThrowArgs} args - Arguments to find a LpFor
     * @example
     * // Get one LpFor
     * const lpFor = await prisma.lpFor.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LpForFindFirstOrThrowArgs>(args?: SelectSubset<T, LpForFindFirstOrThrowArgs<ExtArgs>>): Prisma__LpForClient<$Result.GetResult<Prisma.$LpForPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more LpFors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LpForFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LpFors
     * const lpFors = await prisma.lpFor.findMany()
     * 
     * // Get first 10 LpFors
     * const lpFors = await prisma.lpFor.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const lpForWithIdOnly = await prisma.lpFor.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LpForFindManyArgs>(args?: SelectSubset<T, LpForFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LpForPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a LpFor.
     * @param {LpForCreateArgs} args - Arguments to create a LpFor.
     * @example
     * // Create one LpFor
     * const LpFor = await prisma.lpFor.create({
     *   data: {
     *     // ... data to create a LpFor
     *   }
     * })
     * 
     */
    create<T extends LpForCreateArgs>(args: SelectSubset<T, LpForCreateArgs<ExtArgs>>): Prisma__LpForClient<$Result.GetResult<Prisma.$LpForPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many LpFors.
     * @param {LpForCreateManyArgs} args - Arguments to create many LpFors.
     * @example
     * // Create many LpFors
     * const lpFor = await prisma.lpFor.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LpForCreateManyArgs>(args?: SelectSubset<T, LpForCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many LpFors and returns the data saved in the database.
     * @param {LpForCreateManyAndReturnArgs} args - Arguments to create many LpFors.
     * @example
     * // Create many LpFors
     * const lpFor = await prisma.lpFor.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many LpFors and only return the `id`
     * const lpForWithIdOnly = await prisma.lpFor.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LpForCreateManyAndReturnArgs>(args?: SelectSubset<T, LpForCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LpForPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a LpFor.
     * @param {LpForDeleteArgs} args - Arguments to delete one LpFor.
     * @example
     * // Delete one LpFor
     * const LpFor = await prisma.lpFor.delete({
     *   where: {
     *     // ... filter to delete one LpFor
     *   }
     * })
     * 
     */
    delete<T extends LpForDeleteArgs>(args: SelectSubset<T, LpForDeleteArgs<ExtArgs>>): Prisma__LpForClient<$Result.GetResult<Prisma.$LpForPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one LpFor.
     * @param {LpForUpdateArgs} args - Arguments to update one LpFor.
     * @example
     * // Update one LpFor
     * const lpFor = await prisma.lpFor.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LpForUpdateArgs>(args: SelectSubset<T, LpForUpdateArgs<ExtArgs>>): Prisma__LpForClient<$Result.GetResult<Prisma.$LpForPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more LpFors.
     * @param {LpForDeleteManyArgs} args - Arguments to filter LpFors to delete.
     * @example
     * // Delete a few LpFors
     * const { count } = await prisma.lpFor.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LpForDeleteManyArgs>(args?: SelectSubset<T, LpForDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LpFors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LpForUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LpFors
     * const lpFor = await prisma.lpFor.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LpForUpdateManyArgs>(args: SelectSubset<T, LpForUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LpFors and returns the data updated in the database.
     * @param {LpForUpdateManyAndReturnArgs} args - Arguments to update many LpFors.
     * @example
     * // Update many LpFors
     * const lpFor = await prisma.lpFor.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more LpFors and only return the `id`
     * const lpForWithIdOnly = await prisma.lpFor.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LpForUpdateManyAndReturnArgs>(args: SelectSubset<T, LpForUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LpForPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one LpFor.
     * @param {LpForUpsertArgs} args - Arguments to update or create a LpFor.
     * @example
     * // Update or create a LpFor
     * const lpFor = await prisma.lpFor.upsert({
     *   create: {
     *     // ... data to create a LpFor
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LpFor we want to update
     *   }
     * })
     */
    upsert<T extends LpForUpsertArgs>(args: SelectSubset<T, LpForUpsertArgs<ExtArgs>>): Prisma__LpForClient<$Result.GetResult<Prisma.$LpForPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of LpFors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LpForCountArgs} args - Arguments to filter LpFors to count.
     * @example
     * // Count the number of LpFors
     * const count = await prisma.lpFor.count({
     *   where: {
     *     // ... the filter for the LpFors we want to count
     *   }
     * })
    **/
    count<T extends LpForCountArgs>(
      args?: Subset<T, LpForCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LpForCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LpFor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LpForAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LpForAggregateArgs>(args: Subset<T, LpForAggregateArgs>): Prisma.PrismaPromise<GetLpForAggregateType<T>>

    /**
     * Group by LpFor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LpForGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LpForGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LpForGroupByArgs['orderBy'] }
        : { orderBy?: LpForGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LpForGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLpForGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LpFor model
   */
  readonly fields: LpForFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LpFor.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LpForClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    landingPages<T extends LpFor$landingPagesArgs<ExtArgs> = {}>(args?: Subset<T, LpFor$landingPagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LandingPagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LpFor model
   */
  interface LpForFieldRefs {
    readonly id: FieldRef<"LpFor", 'String'>
    readonly description: FieldRef<"LpFor", 'String'>
  }
    

  // Custom InputTypes
  /**
   * LpFor findUnique
   */
  export type LpForFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LpFor
     */
    select?: LpForSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LpFor
     */
    omit?: LpForOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LpForInclude<ExtArgs> | null
    /**
     * Filter, which LpFor to fetch.
     */
    where: LpForWhereUniqueInput
  }

  /**
   * LpFor findUniqueOrThrow
   */
  export type LpForFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LpFor
     */
    select?: LpForSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LpFor
     */
    omit?: LpForOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LpForInclude<ExtArgs> | null
    /**
     * Filter, which LpFor to fetch.
     */
    where: LpForWhereUniqueInput
  }

  /**
   * LpFor findFirst
   */
  export type LpForFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LpFor
     */
    select?: LpForSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LpFor
     */
    omit?: LpForOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LpForInclude<ExtArgs> | null
    /**
     * Filter, which LpFor to fetch.
     */
    where?: LpForWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LpFors to fetch.
     */
    orderBy?: LpForOrderByWithRelationInput | LpForOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LpFors.
     */
    cursor?: LpForWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LpFors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LpFors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LpFors.
     */
    distinct?: LpForScalarFieldEnum | LpForScalarFieldEnum[]
  }

  /**
   * LpFor findFirstOrThrow
   */
  export type LpForFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LpFor
     */
    select?: LpForSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LpFor
     */
    omit?: LpForOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LpForInclude<ExtArgs> | null
    /**
     * Filter, which LpFor to fetch.
     */
    where?: LpForWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LpFors to fetch.
     */
    orderBy?: LpForOrderByWithRelationInput | LpForOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LpFors.
     */
    cursor?: LpForWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LpFors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LpFors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LpFors.
     */
    distinct?: LpForScalarFieldEnum | LpForScalarFieldEnum[]
  }

  /**
   * LpFor findMany
   */
  export type LpForFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LpFor
     */
    select?: LpForSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LpFor
     */
    omit?: LpForOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LpForInclude<ExtArgs> | null
    /**
     * Filter, which LpFors to fetch.
     */
    where?: LpForWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LpFors to fetch.
     */
    orderBy?: LpForOrderByWithRelationInput | LpForOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LpFors.
     */
    cursor?: LpForWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LpFors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LpFors.
     */
    skip?: number
    distinct?: LpForScalarFieldEnum | LpForScalarFieldEnum[]
  }

  /**
   * LpFor create
   */
  export type LpForCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LpFor
     */
    select?: LpForSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LpFor
     */
    omit?: LpForOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LpForInclude<ExtArgs> | null
    /**
     * The data needed to create a LpFor.
     */
    data?: XOR<LpForCreateInput, LpForUncheckedCreateInput>
  }

  /**
   * LpFor createMany
   */
  export type LpForCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LpFors.
     */
    data: LpForCreateManyInput | LpForCreateManyInput[]
  }

  /**
   * LpFor createManyAndReturn
   */
  export type LpForCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LpFor
     */
    select?: LpForSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LpFor
     */
    omit?: LpForOmit<ExtArgs> | null
    /**
     * The data used to create many LpFors.
     */
    data: LpForCreateManyInput | LpForCreateManyInput[]
  }

  /**
   * LpFor update
   */
  export type LpForUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LpFor
     */
    select?: LpForSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LpFor
     */
    omit?: LpForOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LpForInclude<ExtArgs> | null
    /**
     * The data needed to update a LpFor.
     */
    data: XOR<LpForUpdateInput, LpForUncheckedUpdateInput>
    /**
     * Choose, which LpFor to update.
     */
    where: LpForWhereUniqueInput
  }

  /**
   * LpFor updateMany
   */
  export type LpForUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LpFors.
     */
    data: XOR<LpForUpdateManyMutationInput, LpForUncheckedUpdateManyInput>
    /**
     * Filter which LpFors to update
     */
    where?: LpForWhereInput
    /**
     * Limit how many LpFors to update.
     */
    limit?: number
  }

  /**
   * LpFor updateManyAndReturn
   */
  export type LpForUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LpFor
     */
    select?: LpForSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LpFor
     */
    omit?: LpForOmit<ExtArgs> | null
    /**
     * The data used to update LpFors.
     */
    data: XOR<LpForUpdateManyMutationInput, LpForUncheckedUpdateManyInput>
    /**
     * Filter which LpFors to update
     */
    where?: LpForWhereInput
    /**
     * Limit how many LpFors to update.
     */
    limit?: number
  }

  /**
   * LpFor upsert
   */
  export type LpForUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LpFor
     */
    select?: LpForSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LpFor
     */
    omit?: LpForOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LpForInclude<ExtArgs> | null
    /**
     * The filter to search for the LpFor to update in case it exists.
     */
    where: LpForWhereUniqueInput
    /**
     * In case the LpFor found by the `where` argument doesn't exist, create a new LpFor with this data.
     */
    create: XOR<LpForCreateInput, LpForUncheckedCreateInput>
    /**
     * In case the LpFor was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LpForUpdateInput, LpForUncheckedUpdateInput>
  }

  /**
   * LpFor delete
   */
  export type LpForDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LpFor
     */
    select?: LpForSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LpFor
     */
    omit?: LpForOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LpForInclude<ExtArgs> | null
    /**
     * Filter which LpFor to delete.
     */
    where: LpForWhereUniqueInput
  }

  /**
   * LpFor deleteMany
   */
  export type LpForDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LpFors to delete
     */
    where?: LpForWhereInput
    /**
     * Limit how many LpFors to delete.
     */
    limit?: number
  }

  /**
   * LpFor.landingPages
   */
  export type LpFor$landingPagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LandingPage
     */
    select?: LandingPageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LandingPage
     */
    omit?: LandingPageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LandingPageInclude<ExtArgs> | null
    where?: LandingPageWhereInput
    orderBy?: LandingPageOrderByWithRelationInput | LandingPageOrderByWithRelationInput[]
    cursor?: LandingPageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LandingPageScalarFieldEnum | LandingPageScalarFieldEnum[]
  }

  /**
   * LpFor without action
   */
  export type LpForDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LpFor
     */
    select?: LpForSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LpFor
     */
    omit?: LpForOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LpForInclude<ExtArgs> | null
  }


  /**
   * Model LpContentType
   */

  export type AggregateLpContentType = {
    _count: LpContentTypeCountAggregateOutputType | null
    _min: LpContentTypeMinAggregateOutputType | null
    _max: LpContentTypeMaxAggregateOutputType | null
  }

  export type LpContentTypeMinAggregateOutputType = {
    id: string | null
    type: string | null
  }

  export type LpContentTypeMaxAggregateOutputType = {
    id: string | null
    type: string | null
  }

  export type LpContentTypeCountAggregateOutputType = {
    id: number
    type: number
    _all: number
  }


  export type LpContentTypeMinAggregateInputType = {
    id?: true
    type?: true
  }

  export type LpContentTypeMaxAggregateInputType = {
    id?: true
    type?: true
  }

  export type LpContentTypeCountAggregateInputType = {
    id?: true
    type?: true
    _all?: true
  }

  export type LpContentTypeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LpContentType to aggregate.
     */
    where?: LpContentTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LpContentTypes to fetch.
     */
    orderBy?: LpContentTypeOrderByWithRelationInput | LpContentTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LpContentTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LpContentTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LpContentTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LpContentTypes
    **/
    _count?: true | LpContentTypeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LpContentTypeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LpContentTypeMaxAggregateInputType
  }

  export type GetLpContentTypeAggregateType<T extends LpContentTypeAggregateArgs> = {
        [P in keyof T & keyof AggregateLpContentType]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLpContentType[P]>
      : GetScalarType<T[P], AggregateLpContentType[P]>
  }




  export type LpContentTypeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LpContentTypeWhereInput
    orderBy?: LpContentTypeOrderByWithAggregationInput | LpContentTypeOrderByWithAggregationInput[]
    by: LpContentTypeScalarFieldEnum[] | LpContentTypeScalarFieldEnum
    having?: LpContentTypeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LpContentTypeCountAggregateInputType | true
    _min?: LpContentTypeMinAggregateInputType
    _max?: LpContentTypeMaxAggregateInputType
  }

  export type LpContentTypeGroupByOutputType = {
    id: string
    type: string
    _count: LpContentTypeCountAggregateOutputType | null
    _min: LpContentTypeMinAggregateOutputType | null
    _max: LpContentTypeMaxAggregateOutputType | null
  }

  type GetLpContentTypeGroupByPayload<T extends LpContentTypeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LpContentTypeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LpContentTypeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LpContentTypeGroupByOutputType[P]>
            : GetScalarType<T[P], LpContentTypeGroupByOutputType[P]>
        }
      >
    >


  export type LpContentTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    landingPages?: boolean | LpContentType$landingPagesArgs<ExtArgs>
    _count?: boolean | LpContentTypeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["lpContentType"]>

  export type LpContentTypeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
  }, ExtArgs["result"]["lpContentType"]>

  export type LpContentTypeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
  }, ExtArgs["result"]["lpContentType"]>

  export type LpContentTypeSelectScalar = {
    id?: boolean
    type?: boolean
  }

  export type LpContentTypeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "type", ExtArgs["result"]["lpContentType"]>
  export type LpContentTypeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    landingPages?: boolean | LpContentType$landingPagesArgs<ExtArgs>
    _count?: boolean | LpContentTypeCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type LpContentTypeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type LpContentTypeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $LpContentTypePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LpContentType"
    objects: {
      landingPages: Prisma.$LandingPagePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      type: string
    }, ExtArgs["result"]["lpContentType"]>
    composites: {}
  }

  type LpContentTypeGetPayload<S extends boolean | null | undefined | LpContentTypeDefaultArgs> = $Result.GetResult<Prisma.$LpContentTypePayload, S>

  type LpContentTypeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LpContentTypeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LpContentTypeCountAggregateInputType | true
    }

  export interface LpContentTypeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LpContentType'], meta: { name: 'LpContentType' } }
    /**
     * Find zero or one LpContentType that matches the filter.
     * @param {LpContentTypeFindUniqueArgs} args - Arguments to find a LpContentType
     * @example
     * // Get one LpContentType
     * const lpContentType = await prisma.lpContentType.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LpContentTypeFindUniqueArgs>(args: SelectSubset<T, LpContentTypeFindUniqueArgs<ExtArgs>>): Prisma__LpContentTypeClient<$Result.GetResult<Prisma.$LpContentTypePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one LpContentType that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LpContentTypeFindUniqueOrThrowArgs} args - Arguments to find a LpContentType
     * @example
     * // Get one LpContentType
     * const lpContentType = await prisma.lpContentType.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LpContentTypeFindUniqueOrThrowArgs>(args: SelectSubset<T, LpContentTypeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LpContentTypeClient<$Result.GetResult<Prisma.$LpContentTypePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LpContentType that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LpContentTypeFindFirstArgs} args - Arguments to find a LpContentType
     * @example
     * // Get one LpContentType
     * const lpContentType = await prisma.lpContentType.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LpContentTypeFindFirstArgs>(args?: SelectSubset<T, LpContentTypeFindFirstArgs<ExtArgs>>): Prisma__LpContentTypeClient<$Result.GetResult<Prisma.$LpContentTypePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LpContentType that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LpContentTypeFindFirstOrThrowArgs} args - Arguments to find a LpContentType
     * @example
     * // Get one LpContentType
     * const lpContentType = await prisma.lpContentType.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LpContentTypeFindFirstOrThrowArgs>(args?: SelectSubset<T, LpContentTypeFindFirstOrThrowArgs<ExtArgs>>): Prisma__LpContentTypeClient<$Result.GetResult<Prisma.$LpContentTypePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more LpContentTypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LpContentTypeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LpContentTypes
     * const lpContentTypes = await prisma.lpContentType.findMany()
     * 
     * // Get first 10 LpContentTypes
     * const lpContentTypes = await prisma.lpContentType.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const lpContentTypeWithIdOnly = await prisma.lpContentType.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LpContentTypeFindManyArgs>(args?: SelectSubset<T, LpContentTypeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LpContentTypePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a LpContentType.
     * @param {LpContentTypeCreateArgs} args - Arguments to create a LpContentType.
     * @example
     * // Create one LpContentType
     * const LpContentType = await prisma.lpContentType.create({
     *   data: {
     *     // ... data to create a LpContentType
     *   }
     * })
     * 
     */
    create<T extends LpContentTypeCreateArgs>(args: SelectSubset<T, LpContentTypeCreateArgs<ExtArgs>>): Prisma__LpContentTypeClient<$Result.GetResult<Prisma.$LpContentTypePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many LpContentTypes.
     * @param {LpContentTypeCreateManyArgs} args - Arguments to create many LpContentTypes.
     * @example
     * // Create many LpContentTypes
     * const lpContentType = await prisma.lpContentType.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LpContentTypeCreateManyArgs>(args?: SelectSubset<T, LpContentTypeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many LpContentTypes and returns the data saved in the database.
     * @param {LpContentTypeCreateManyAndReturnArgs} args - Arguments to create many LpContentTypes.
     * @example
     * // Create many LpContentTypes
     * const lpContentType = await prisma.lpContentType.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many LpContentTypes and only return the `id`
     * const lpContentTypeWithIdOnly = await prisma.lpContentType.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LpContentTypeCreateManyAndReturnArgs>(args?: SelectSubset<T, LpContentTypeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LpContentTypePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a LpContentType.
     * @param {LpContentTypeDeleteArgs} args - Arguments to delete one LpContentType.
     * @example
     * // Delete one LpContentType
     * const LpContentType = await prisma.lpContentType.delete({
     *   where: {
     *     // ... filter to delete one LpContentType
     *   }
     * })
     * 
     */
    delete<T extends LpContentTypeDeleteArgs>(args: SelectSubset<T, LpContentTypeDeleteArgs<ExtArgs>>): Prisma__LpContentTypeClient<$Result.GetResult<Prisma.$LpContentTypePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one LpContentType.
     * @param {LpContentTypeUpdateArgs} args - Arguments to update one LpContentType.
     * @example
     * // Update one LpContentType
     * const lpContentType = await prisma.lpContentType.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LpContentTypeUpdateArgs>(args: SelectSubset<T, LpContentTypeUpdateArgs<ExtArgs>>): Prisma__LpContentTypeClient<$Result.GetResult<Prisma.$LpContentTypePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more LpContentTypes.
     * @param {LpContentTypeDeleteManyArgs} args - Arguments to filter LpContentTypes to delete.
     * @example
     * // Delete a few LpContentTypes
     * const { count } = await prisma.lpContentType.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LpContentTypeDeleteManyArgs>(args?: SelectSubset<T, LpContentTypeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LpContentTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LpContentTypeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LpContentTypes
     * const lpContentType = await prisma.lpContentType.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LpContentTypeUpdateManyArgs>(args: SelectSubset<T, LpContentTypeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LpContentTypes and returns the data updated in the database.
     * @param {LpContentTypeUpdateManyAndReturnArgs} args - Arguments to update many LpContentTypes.
     * @example
     * // Update many LpContentTypes
     * const lpContentType = await prisma.lpContentType.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more LpContentTypes and only return the `id`
     * const lpContentTypeWithIdOnly = await prisma.lpContentType.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LpContentTypeUpdateManyAndReturnArgs>(args: SelectSubset<T, LpContentTypeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LpContentTypePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one LpContentType.
     * @param {LpContentTypeUpsertArgs} args - Arguments to update or create a LpContentType.
     * @example
     * // Update or create a LpContentType
     * const lpContentType = await prisma.lpContentType.upsert({
     *   create: {
     *     // ... data to create a LpContentType
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LpContentType we want to update
     *   }
     * })
     */
    upsert<T extends LpContentTypeUpsertArgs>(args: SelectSubset<T, LpContentTypeUpsertArgs<ExtArgs>>): Prisma__LpContentTypeClient<$Result.GetResult<Prisma.$LpContentTypePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of LpContentTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LpContentTypeCountArgs} args - Arguments to filter LpContentTypes to count.
     * @example
     * // Count the number of LpContentTypes
     * const count = await prisma.lpContentType.count({
     *   where: {
     *     // ... the filter for the LpContentTypes we want to count
     *   }
     * })
    **/
    count<T extends LpContentTypeCountArgs>(
      args?: Subset<T, LpContentTypeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LpContentTypeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LpContentType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LpContentTypeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LpContentTypeAggregateArgs>(args: Subset<T, LpContentTypeAggregateArgs>): Prisma.PrismaPromise<GetLpContentTypeAggregateType<T>>

    /**
     * Group by LpContentType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LpContentTypeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LpContentTypeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LpContentTypeGroupByArgs['orderBy'] }
        : { orderBy?: LpContentTypeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LpContentTypeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLpContentTypeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LpContentType model
   */
  readonly fields: LpContentTypeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LpContentType.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LpContentTypeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    landingPages<T extends LpContentType$landingPagesArgs<ExtArgs> = {}>(args?: Subset<T, LpContentType$landingPagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LandingPagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LpContentType model
   */
  interface LpContentTypeFieldRefs {
    readonly id: FieldRef<"LpContentType", 'String'>
    readonly type: FieldRef<"LpContentType", 'String'>
  }
    

  // Custom InputTypes
  /**
   * LpContentType findUnique
   */
  export type LpContentTypeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LpContentType
     */
    select?: LpContentTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LpContentType
     */
    omit?: LpContentTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LpContentTypeInclude<ExtArgs> | null
    /**
     * Filter, which LpContentType to fetch.
     */
    where: LpContentTypeWhereUniqueInput
  }

  /**
   * LpContentType findUniqueOrThrow
   */
  export type LpContentTypeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LpContentType
     */
    select?: LpContentTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LpContentType
     */
    omit?: LpContentTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LpContentTypeInclude<ExtArgs> | null
    /**
     * Filter, which LpContentType to fetch.
     */
    where: LpContentTypeWhereUniqueInput
  }

  /**
   * LpContentType findFirst
   */
  export type LpContentTypeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LpContentType
     */
    select?: LpContentTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LpContentType
     */
    omit?: LpContentTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LpContentTypeInclude<ExtArgs> | null
    /**
     * Filter, which LpContentType to fetch.
     */
    where?: LpContentTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LpContentTypes to fetch.
     */
    orderBy?: LpContentTypeOrderByWithRelationInput | LpContentTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LpContentTypes.
     */
    cursor?: LpContentTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LpContentTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LpContentTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LpContentTypes.
     */
    distinct?: LpContentTypeScalarFieldEnum | LpContentTypeScalarFieldEnum[]
  }

  /**
   * LpContentType findFirstOrThrow
   */
  export type LpContentTypeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LpContentType
     */
    select?: LpContentTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LpContentType
     */
    omit?: LpContentTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LpContentTypeInclude<ExtArgs> | null
    /**
     * Filter, which LpContentType to fetch.
     */
    where?: LpContentTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LpContentTypes to fetch.
     */
    orderBy?: LpContentTypeOrderByWithRelationInput | LpContentTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LpContentTypes.
     */
    cursor?: LpContentTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LpContentTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LpContentTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LpContentTypes.
     */
    distinct?: LpContentTypeScalarFieldEnum | LpContentTypeScalarFieldEnum[]
  }

  /**
   * LpContentType findMany
   */
  export type LpContentTypeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LpContentType
     */
    select?: LpContentTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LpContentType
     */
    omit?: LpContentTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LpContentTypeInclude<ExtArgs> | null
    /**
     * Filter, which LpContentTypes to fetch.
     */
    where?: LpContentTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LpContentTypes to fetch.
     */
    orderBy?: LpContentTypeOrderByWithRelationInput | LpContentTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LpContentTypes.
     */
    cursor?: LpContentTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LpContentTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LpContentTypes.
     */
    skip?: number
    distinct?: LpContentTypeScalarFieldEnum | LpContentTypeScalarFieldEnum[]
  }

  /**
   * LpContentType create
   */
  export type LpContentTypeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LpContentType
     */
    select?: LpContentTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LpContentType
     */
    omit?: LpContentTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LpContentTypeInclude<ExtArgs> | null
    /**
     * The data needed to create a LpContentType.
     */
    data: XOR<LpContentTypeCreateInput, LpContentTypeUncheckedCreateInput>
  }

  /**
   * LpContentType createMany
   */
  export type LpContentTypeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LpContentTypes.
     */
    data: LpContentTypeCreateManyInput | LpContentTypeCreateManyInput[]
  }

  /**
   * LpContentType createManyAndReturn
   */
  export type LpContentTypeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LpContentType
     */
    select?: LpContentTypeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LpContentType
     */
    omit?: LpContentTypeOmit<ExtArgs> | null
    /**
     * The data used to create many LpContentTypes.
     */
    data: LpContentTypeCreateManyInput | LpContentTypeCreateManyInput[]
  }

  /**
   * LpContentType update
   */
  export type LpContentTypeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LpContentType
     */
    select?: LpContentTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LpContentType
     */
    omit?: LpContentTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LpContentTypeInclude<ExtArgs> | null
    /**
     * The data needed to update a LpContentType.
     */
    data: XOR<LpContentTypeUpdateInput, LpContentTypeUncheckedUpdateInput>
    /**
     * Choose, which LpContentType to update.
     */
    where: LpContentTypeWhereUniqueInput
  }

  /**
   * LpContentType updateMany
   */
  export type LpContentTypeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LpContentTypes.
     */
    data: XOR<LpContentTypeUpdateManyMutationInput, LpContentTypeUncheckedUpdateManyInput>
    /**
     * Filter which LpContentTypes to update
     */
    where?: LpContentTypeWhereInput
    /**
     * Limit how many LpContentTypes to update.
     */
    limit?: number
  }

  /**
   * LpContentType updateManyAndReturn
   */
  export type LpContentTypeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LpContentType
     */
    select?: LpContentTypeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LpContentType
     */
    omit?: LpContentTypeOmit<ExtArgs> | null
    /**
     * The data used to update LpContentTypes.
     */
    data: XOR<LpContentTypeUpdateManyMutationInput, LpContentTypeUncheckedUpdateManyInput>
    /**
     * Filter which LpContentTypes to update
     */
    where?: LpContentTypeWhereInput
    /**
     * Limit how many LpContentTypes to update.
     */
    limit?: number
  }

  /**
   * LpContentType upsert
   */
  export type LpContentTypeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LpContentType
     */
    select?: LpContentTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LpContentType
     */
    omit?: LpContentTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LpContentTypeInclude<ExtArgs> | null
    /**
     * The filter to search for the LpContentType to update in case it exists.
     */
    where: LpContentTypeWhereUniqueInput
    /**
     * In case the LpContentType found by the `where` argument doesn't exist, create a new LpContentType with this data.
     */
    create: XOR<LpContentTypeCreateInput, LpContentTypeUncheckedCreateInput>
    /**
     * In case the LpContentType was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LpContentTypeUpdateInput, LpContentTypeUncheckedUpdateInput>
  }

  /**
   * LpContentType delete
   */
  export type LpContentTypeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LpContentType
     */
    select?: LpContentTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LpContentType
     */
    omit?: LpContentTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LpContentTypeInclude<ExtArgs> | null
    /**
     * Filter which LpContentType to delete.
     */
    where: LpContentTypeWhereUniqueInput
  }

  /**
   * LpContentType deleteMany
   */
  export type LpContentTypeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LpContentTypes to delete
     */
    where?: LpContentTypeWhereInput
    /**
     * Limit how many LpContentTypes to delete.
     */
    limit?: number
  }

  /**
   * LpContentType.landingPages
   */
  export type LpContentType$landingPagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LandingPage
     */
    select?: LandingPageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LandingPage
     */
    omit?: LandingPageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LandingPageInclude<ExtArgs> | null
    where?: LandingPageWhereInput
    orderBy?: LandingPageOrderByWithRelationInput | LandingPageOrderByWithRelationInput[]
    cursor?: LandingPageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LandingPageScalarFieldEnum | LandingPageScalarFieldEnum[]
  }

  /**
   * LpContentType without action
   */
  export type LpContentTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LpContentType
     */
    select?: LpContentTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LpContentType
     */
    omit?: LpContentTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LpContentTypeInclude<ExtArgs> | null
  }


  /**
   * Model LpDesignStyle
   */

  export type AggregateLpDesignStyle = {
    _count: LpDesignStyleCountAggregateOutputType | null
    _min: LpDesignStyleMinAggregateOutputType | null
    _max: LpDesignStyleMaxAggregateOutputType | null
  }

  export type LpDesignStyleMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
  }

  export type LpDesignStyleMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
  }

  export type LpDesignStyleCountAggregateOutputType = {
    id: number
    name: number
    description: number
    _all: number
  }


  export type LpDesignStyleMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
  }

  export type LpDesignStyleMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
  }

  export type LpDesignStyleCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    _all?: true
  }

  export type LpDesignStyleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LpDesignStyle to aggregate.
     */
    where?: LpDesignStyleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LpDesignStyles to fetch.
     */
    orderBy?: LpDesignStyleOrderByWithRelationInput | LpDesignStyleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LpDesignStyleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LpDesignStyles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LpDesignStyles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LpDesignStyles
    **/
    _count?: true | LpDesignStyleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LpDesignStyleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LpDesignStyleMaxAggregateInputType
  }

  export type GetLpDesignStyleAggregateType<T extends LpDesignStyleAggregateArgs> = {
        [P in keyof T & keyof AggregateLpDesignStyle]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLpDesignStyle[P]>
      : GetScalarType<T[P], AggregateLpDesignStyle[P]>
  }




  export type LpDesignStyleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LpDesignStyleWhereInput
    orderBy?: LpDesignStyleOrderByWithAggregationInput | LpDesignStyleOrderByWithAggregationInput[]
    by: LpDesignStyleScalarFieldEnum[] | LpDesignStyleScalarFieldEnum
    having?: LpDesignStyleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LpDesignStyleCountAggregateInputType | true
    _min?: LpDesignStyleMinAggregateInputType
    _max?: LpDesignStyleMaxAggregateInputType
  }

  export type LpDesignStyleGroupByOutputType = {
    id: string
    name: string
    description: string
    _count: LpDesignStyleCountAggregateOutputType | null
    _min: LpDesignStyleMinAggregateOutputType | null
    _max: LpDesignStyleMaxAggregateOutputType | null
  }

  type GetLpDesignStyleGroupByPayload<T extends LpDesignStyleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LpDesignStyleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LpDesignStyleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LpDesignStyleGroupByOutputType[P]>
            : GetScalarType<T[P], LpDesignStyleGroupByOutputType[P]>
        }
      >
    >


  export type LpDesignStyleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    templates?: boolean | LpDesignStyle$templatesArgs<ExtArgs>
    _count?: boolean | LpDesignStyleCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["lpDesignStyle"]>

  export type LpDesignStyleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
  }, ExtArgs["result"]["lpDesignStyle"]>

  export type LpDesignStyleSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
  }, ExtArgs["result"]["lpDesignStyle"]>

  export type LpDesignStyleSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
  }

  export type LpDesignStyleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description", ExtArgs["result"]["lpDesignStyle"]>
  export type LpDesignStyleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    templates?: boolean | LpDesignStyle$templatesArgs<ExtArgs>
    _count?: boolean | LpDesignStyleCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type LpDesignStyleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type LpDesignStyleIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $LpDesignStylePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LpDesignStyle"
    objects: {
      templates: Prisma.$LandingPagePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string
    }, ExtArgs["result"]["lpDesignStyle"]>
    composites: {}
  }

  type LpDesignStyleGetPayload<S extends boolean | null | undefined | LpDesignStyleDefaultArgs> = $Result.GetResult<Prisma.$LpDesignStylePayload, S>

  type LpDesignStyleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LpDesignStyleFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LpDesignStyleCountAggregateInputType | true
    }

  export interface LpDesignStyleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LpDesignStyle'], meta: { name: 'LpDesignStyle' } }
    /**
     * Find zero or one LpDesignStyle that matches the filter.
     * @param {LpDesignStyleFindUniqueArgs} args - Arguments to find a LpDesignStyle
     * @example
     * // Get one LpDesignStyle
     * const lpDesignStyle = await prisma.lpDesignStyle.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LpDesignStyleFindUniqueArgs>(args: SelectSubset<T, LpDesignStyleFindUniqueArgs<ExtArgs>>): Prisma__LpDesignStyleClient<$Result.GetResult<Prisma.$LpDesignStylePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one LpDesignStyle that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LpDesignStyleFindUniqueOrThrowArgs} args - Arguments to find a LpDesignStyle
     * @example
     * // Get one LpDesignStyle
     * const lpDesignStyle = await prisma.lpDesignStyle.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LpDesignStyleFindUniqueOrThrowArgs>(args: SelectSubset<T, LpDesignStyleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LpDesignStyleClient<$Result.GetResult<Prisma.$LpDesignStylePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LpDesignStyle that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LpDesignStyleFindFirstArgs} args - Arguments to find a LpDesignStyle
     * @example
     * // Get one LpDesignStyle
     * const lpDesignStyle = await prisma.lpDesignStyle.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LpDesignStyleFindFirstArgs>(args?: SelectSubset<T, LpDesignStyleFindFirstArgs<ExtArgs>>): Prisma__LpDesignStyleClient<$Result.GetResult<Prisma.$LpDesignStylePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LpDesignStyle that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LpDesignStyleFindFirstOrThrowArgs} args - Arguments to find a LpDesignStyle
     * @example
     * // Get one LpDesignStyle
     * const lpDesignStyle = await prisma.lpDesignStyle.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LpDesignStyleFindFirstOrThrowArgs>(args?: SelectSubset<T, LpDesignStyleFindFirstOrThrowArgs<ExtArgs>>): Prisma__LpDesignStyleClient<$Result.GetResult<Prisma.$LpDesignStylePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more LpDesignStyles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LpDesignStyleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LpDesignStyles
     * const lpDesignStyles = await prisma.lpDesignStyle.findMany()
     * 
     * // Get first 10 LpDesignStyles
     * const lpDesignStyles = await prisma.lpDesignStyle.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const lpDesignStyleWithIdOnly = await prisma.lpDesignStyle.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LpDesignStyleFindManyArgs>(args?: SelectSubset<T, LpDesignStyleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LpDesignStylePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a LpDesignStyle.
     * @param {LpDesignStyleCreateArgs} args - Arguments to create a LpDesignStyle.
     * @example
     * // Create one LpDesignStyle
     * const LpDesignStyle = await prisma.lpDesignStyle.create({
     *   data: {
     *     // ... data to create a LpDesignStyle
     *   }
     * })
     * 
     */
    create<T extends LpDesignStyleCreateArgs>(args: SelectSubset<T, LpDesignStyleCreateArgs<ExtArgs>>): Prisma__LpDesignStyleClient<$Result.GetResult<Prisma.$LpDesignStylePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many LpDesignStyles.
     * @param {LpDesignStyleCreateManyArgs} args - Arguments to create many LpDesignStyles.
     * @example
     * // Create many LpDesignStyles
     * const lpDesignStyle = await prisma.lpDesignStyle.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LpDesignStyleCreateManyArgs>(args?: SelectSubset<T, LpDesignStyleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many LpDesignStyles and returns the data saved in the database.
     * @param {LpDesignStyleCreateManyAndReturnArgs} args - Arguments to create many LpDesignStyles.
     * @example
     * // Create many LpDesignStyles
     * const lpDesignStyle = await prisma.lpDesignStyle.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many LpDesignStyles and only return the `id`
     * const lpDesignStyleWithIdOnly = await prisma.lpDesignStyle.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LpDesignStyleCreateManyAndReturnArgs>(args?: SelectSubset<T, LpDesignStyleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LpDesignStylePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a LpDesignStyle.
     * @param {LpDesignStyleDeleteArgs} args - Arguments to delete one LpDesignStyle.
     * @example
     * // Delete one LpDesignStyle
     * const LpDesignStyle = await prisma.lpDesignStyle.delete({
     *   where: {
     *     // ... filter to delete one LpDesignStyle
     *   }
     * })
     * 
     */
    delete<T extends LpDesignStyleDeleteArgs>(args: SelectSubset<T, LpDesignStyleDeleteArgs<ExtArgs>>): Prisma__LpDesignStyleClient<$Result.GetResult<Prisma.$LpDesignStylePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one LpDesignStyle.
     * @param {LpDesignStyleUpdateArgs} args - Arguments to update one LpDesignStyle.
     * @example
     * // Update one LpDesignStyle
     * const lpDesignStyle = await prisma.lpDesignStyle.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LpDesignStyleUpdateArgs>(args: SelectSubset<T, LpDesignStyleUpdateArgs<ExtArgs>>): Prisma__LpDesignStyleClient<$Result.GetResult<Prisma.$LpDesignStylePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more LpDesignStyles.
     * @param {LpDesignStyleDeleteManyArgs} args - Arguments to filter LpDesignStyles to delete.
     * @example
     * // Delete a few LpDesignStyles
     * const { count } = await prisma.lpDesignStyle.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LpDesignStyleDeleteManyArgs>(args?: SelectSubset<T, LpDesignStyleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LpDesignStyles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LpDesignStyleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LpDesignStyles
     * const lpDesignStyle = await prisma.lpDesignStyle.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LpDesignStyleUpdateManyArgs>(args: SelectSubset<T, LpDesignStyleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LpDesignStyles and returns the data updated in the database.
     * @param {LpDesignStyleUpdateManyAndReturnArgs} args - Arguments to update many LpDesignStyles.
     * @example
     * // Update many LpDesignStyles
     * const lpDesignStyle = await prisma.lpDesignStyle.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more LpDesignStyles and only return the `id`
     * const lpDesignStyleWithIdOnly = await prisma.lpDesignStyle.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LpDesignStyleUpdateManyAndReturnArgs>(args: SelectSubset<T, LpDesignStyleUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LpDesignStylePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one LpDesignStyle.
     * @param {LpDesignStyleUpsertArgs} args - Arguments to update or create a LpDesignStyle.
     * @example
     * // Update or create a LpDesignStyle
     * const lpDesignStyle = await prisma.lpDesignStyle.upsert({
     *   create: {
     *     // ... data to create a LpDesignStyle
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LpDesignStyle we want to update
     *   }
     * })
     */
    upsert<T extends LpDesignStyleUpsertArgs>(args: SelectSubset<T, LpDesignStyleUpsertArgs<ExtArgs>>): Prisma__LpDesignStyleClient<$Result.GetResult<Prisma.$LpDesignStylePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of LpDesignStyles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LpDesignStyleCountArgs} args - Arguments to filter LpDesignStyles to count.
     * @example
     * // Count the number of LpDesignStyles
     * const count = await prisma.lpDesignStyle.count({
     *   where: {
     *     // ... the filter for the LpDesignStyles we want to count
     *   }
     * })
    **/
    count<T extends LpDesignStyleCountArgs>(
      args?: Subset<T, LpDesignStyleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LpDesignStyleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LpDesignStyle.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LpDesignStyleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LpDesignStyleAggregateArgs>(args: Subset<T, LpDesignStyleAggregateArgs>): Prisma.PrismaPromise<GetLpDesignStyleAggregateType<T>>

    /**
     * Group by LpDesignStyle.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LpDesignStyleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LpDesignStyleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LpDesignStyleGroupByArgs['orderBy'] }
        : { orderBy?: LpDesignStyleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LpDesignStyleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLpDesignStyleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LpDesignStyle model
   */
  readonly fields: LpDesignStyleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LpDesignStyle.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LpDesignStyleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    templates<T extends LpDesignStyle$templatesArgs<ExtArgs> = {}>(args?: Subset<T, LpDesignStyle$templatesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LandingPagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LpDesignStyle model
   */
  interface LpDesignStyleFieldRefs {
    readonly id: FieldRef<"LpDesignStyle", 'String'>
    readonly name: FieldRef<"LpDesignStyle", 'String'>
    readonly description: FieldRef<"LpDesignStyle", 'String'>
  }
    

  // Custom InputTypes
  /**
   * LpDesignStyle findUnique
   */
  export type LpDesignStyleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LpDesignStyle
     */
    select?: LpDesignStyleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LpDesignStyle
     */
    omit?: LpDesignStyleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LpDesignStyleInclude<ExtArgs> | null
    /**
     * Filter, which LpDesignStyle to fetch.
     */
    where: LpDesignStyleWhereUniqueInput
  }

  /**
   * LpDesignStyle findUniqueOrThrow
   */
  export type LpDesignStyleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LpDesignStyle
     */
    select?: LpDesignStyleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LpDesignStyle
     */
    omit?: LpDesignStyleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LpDesignStyleInclude<ExtArgs> | null
    /**
     * Filter, which LpDesignStyle to fetch.
     */
    where: LpDesignStyleWhereUniqueInput
  }

  /**
   * LpDesignStyle findFirst
   */
  export type LpDesignStyleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LpDesignStyle
     */
    select?: LpDesignStyleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LpDesignStyle
     */
    omit?: LpDesignStyleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LpDesignStyleInclude<ExtArgs> | null
    /**
     * Filter, which LpDesignStyle to fetch.
     */
    where?: LpDesignStyleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LpDesignStyles to fetch.
     */
    orderBy?: LpDesignStyleOrderByWithRelationInput | LpDesignStyleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LpDesignStyles.
     */
    cursor?: LpDesignStyleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LpDesignStyles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LpDesignStyles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LpDesignStyles.
     */
    distinct?: LpDesignStyleScalarFieldEnum | LpDesignStyleScalarFieldEnum[]
  }

  /**
   * LpDesignStyle findFirstOrThrow
   */
  export type LpDesignStyleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LpDesignStyle
     */
    select?: LpDesignStyleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LpDesignStyle
     */
    omit?: LpDesignStyleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LpDesignStyleInclude<ExtArgs> | null
    /**
     * Filter, which LpDesignStyle to fetch.
     */
    where?: LpDesignStyleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LpDesignStyles to fetch.
     */
    orderBy?: LpDesignStyleOrderByWithRelationInput | LpDesignStyleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LpDesignStyles.
     */
    cursor?: LpDesignStyleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LpDesignStyles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LpDesignStyles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LpDesignStyles.
     */
    distinct?: LpDesignStyleScalarFieldEnum | LpDesignStyleScalarFieldEnum[]
  }

  /**
   * LpDesignStyle findMany
   */
  export type LpDesignStyleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LpDesignStyle
     */
    select?: LpDesignStyleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LpDesignStyle
     */
    omit?: LpDesignStyleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LpDesignStyleInclude<ExtArgs> | null
    /**
     * Filter, which LpDesignStyles to fetch.
     */
    where?: LpDesignStyleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LpDesignStyles to fetch.
     */
    orderBy?: LpDesignStyleOrderByWithRelationInput | LpDesignStyleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LpDesignStyles.
     */
    cursor?: LpDesignStyleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LpDesignStyles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LpDesignStyles.
     */
    skip?: number
    distinct?: LpDesignStyleScalarFieldEnum | LpDesignStyleScalarFieldEnum[]
  }

  /**
   * LpDesignStyle create
   */
  export type LpDesignStyleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LpDesignStyle
     */
    select?: LpDesignStyleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LpDesignStyle
     */
    omit?: LpDesignStyleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LpDesignStyleInclude<ExtArgs> | null
    /**
     * The data needed to create a LpDesignStyle.
     */
    data: XOR<LpDesignStyleCreateInput, LpDesignStyleUncheckedCreateInput>
  }

  /**
   * LpDesignStyle createMany
   */
  export type LpDesignStyleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LpDesignStyles.
     */
    data: LpDesignStyleCreateManyInput | LpDesignStyleCreateManyInput[]
  }

  /**
   * LpDesignStyle createManyAndReturn
   */
  export type LpDesignStyleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LpDesignStyle
     */
    select?: LpDesignStyleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LpDesignStyle
     */
    omit?: LpDesignStyleOmit<ExtArgs> | null
    /**
     * The data used to create many LpDesignStyles.
     */
    data: LpDesignStyleCreateManyInput | LpDesignStyleCreateManyInput[]
  }

  /**
   * LpDesignStyle update
   */
  export type LpDesignStyleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LpDesignStyle
     */
    select?: LpDesignStyleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LpDesignStyle
     */
    omit?: LpDesignStyleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LpDesignStyleInclude<ExtArgs> | null
    /**
     * The data needed to update a LpDesignStyle.
     */
    data: XOR<LpDesignStyleUpdateInput, LpDesignStyleUncheckedUpdateInput>
    /**
     * Choose, which LpDesignStyle to update.
     */
    where: LpDesignStyleWhereUniqueInput
  }

  /**
   * LpDesignStyle updateMany
   */
  export type LpDesignStyleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LpDesignStyles.
     */
    data: XOR<LpDesignStyleUpdateManyMutationInput, LpDesignStyleUncheckedUpdateManyInput>
    /**
     * Filter which LpDesignStyles to update
     */
    where?: LpDesignStyleWhereInput
    /**
     * Limit how many LpDesignStyles to update.
     */
    limit?: number
  }

  /**
   * LpDesignStyle updateManyAndReturn
   */
  export type LpDesignStyleUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LpDesignStyle
     */
    select?: LpDesignStyleSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LpDesignStyle
     */
    omit?: LpDesignStyleOmit<ExtArgs> | null
    /**
     * The data used to update LpDesignStyles.
     */
    data: XOR<LpDesignStyleUpdateManyMutationInput, LpDesignStyleUncheckedUpdateManyInput>
    /**
     * Filter which LpDesignStyles to update
     */
    where?: LpDesignStyleWhereInput
    /**
     * Limit how many LpDesignStyles to update.
     */
    limit?: number
  }

  /**
   * LpDesignStyle upsert
   */
  export type LpDesignStyleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LpDesignStyle
     */
    select?: LpDesignStyleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LpDesignStyle
     */
    omit?: LpDesignStyleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LpDesignStyleInclude<ExtArgs> | null
    /**
     * The filter to search for the LpDesignStyle to update in case it exists.
     */
    where: LpDesignStyleWhereUniqueInput
    /**
     * In case the LpDesignStyle found by the `where` argument doesn't exist, create a new LpDesignStyle with this data.
     */
    create: XOR<LpDesignStyleCreateInput, LpDesignStyleUncheckedCreateInput>
    /**
     * In case the LpDesignStyle was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LpDesignStyleUpdateInput, LpDesignStyleUncheckedUpdateInput>
  }

  /**
   * LpDesignStyle delete
   */
  export type LpDesignStyleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LpDesignStyle
     */
    select?: LpDesignStyleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LpDesignStyle
     */
    omit?: LpDesignStyleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LpDesignStyleInclude<ExtArgs> | null
    /**
     * Filter which LpDesignStyle to delete.
     */
    where: LpDesignStyleWhereUniqueInput
  }

  /**
   * LpDesignStyle deleteMany
   */
  export type LpDesignStyleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LpDesignStyles to delete
     */
    where?: LpDesignStyleWhereInput
    /**
     * Limit how many LpDesignStyles to delete.
     */
    limit?: number
  }

  /**
   * LpDesignStyle.templates
   */
  export type LpDesignStyle$templatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LandingPage
     */
    select?: LandingPageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LandingPage
     */
    omit?: LandingPageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LandingPageInclude<ExtArgs> | null
    where?: LandingPageWhereInput
    orderBy?: LandingPageOrderByWithRelationInput | LandingPageOrderByWithRelationInput[]
    cursor?: LandingPageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LandingPageScalarFieldEnum | LandingPageScalarFieldEnum[]
  }

  /**
   * LpDesignStyle without action
   */
  export type LpDesignStyleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LpDesignStyle
     */
    select?: LpDesignStyleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LpDesignStyle
     */
    omit?: LpDesignStyleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LpDesignStyleInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const RegisterFormScalarFieldEnum: {
    id: 'id',
    name: 'name',
    type: 'type',
    placeholder: 'placeholder',
    position: 'position',
    row: 'row',
    options: 'options',
    required: 'required',
    hint: 'hint',
    hintTrue: 'hintTrue',
    hintFalse: 'hintFalse',
    isActive: 'isActive',
    createDate: 'createDate',
    updateDate: 'updateDate'
  };

  export type RegisterFormScalarFieldEnum = (typeof RegisterFormScalarFieldEnum)[keyof typeof RegisterFormScalarFieldEnum]


  export const ApiListScalarFieldEnum: {
    id: 'id',
    name: 'name',
    createDate: 'createDate',
    updateDate: 'updateDate'
  };

  export type ApiListScalarFieldEnum = (typeof ApiListScalarFieldEnum)[keyof typeof ApiListScalarFieldEnum]


  export const FacebookPixelScalarFieldEnum: {
    id: 'id',
    pixelId: 'pixelId',
    campaignName: 'campaignName',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type FacebookPixelScalarFieldEnum = (typeof FacebookPixelScalarFieldEnum)[keyof typeof FacebookPixelScalarFieldEnum]


  export const SiteIdentityScalarFieldEnum: {
    id: 'id',
    siteName: 'siteName',
    tagline: 'tagline',
    description: 'description',
    keywords: 'keywords',
    logoUrl: 'logoUrl',
    ogImage: 'ogImage',
    faviconUrl: 'faviconUrl',
    email: 'email',
    phone: 'phone',
    address: 'address',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SiteIdentityScalarFieldEnum = (typeof SiteIdentityScalarFieldEnum)[keyof typeof SiteIdentityScalarFieldEnum]


  export const SocialLinksScalarFieldEnum: {
    id: 'id',
    platform: 'platform',
    url: 'url',
    platformUsername: 'platformUsername',
    identityId: 'identityId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SocialLinksScalarFieldEnum = (typeof SocialLinksScalarFieldEnum)[keyof typeof SocialLinksScalarFieldEnum]


  export const PageScalarFieldEnum: {
    id: 'id',
    slug: 'slug',
    name: 'name',
    title: 'title',
    description: 'description',
    keywords: 'keywords',
    ogTitle: 'ogTitle',
    ogDescription: 'ogDescription',
    ogImage: 'ogImage',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PageScalarFieldEnum = (typeof PageScalarFieldEnum)[keyof typeof PageScalarFieldEnum]


  export const SectionScalarFieldEnum: {
    id: 'id',
    name: 'name',
    pageId: 'pageId',
    type: 'type',
    title: 'title',
    subTitle: 'subTitle',
    description: 'description',
    additionalText: 'additionalText',
    image: 'image',
    video: 'video',
    icon: 'icon',
    order: 'order'
  };

  export type SectionScalarFieldEnum = (typeof SectionScalarFieldEnum)[keyof typeof SectionScalarFieldEnum]


  export const ListItemScalarFieldEnum: {
    id: 'id',
    sectionId: 'sectionId',
    type: 'type',
    title: 'title',
    description: 'description'
  };

  export type ListItemScalarFieldEnum = (typeof ListItemScalarFieldEnum)[keyof typeof ListItemScalarFieldEnum]


  export const ListEntryScalarFieldEnum: {
    id: 'id',
    listItemId: 'listItemId',
    title: 'title',
    price: 'price',
    description: 'description',
    icon: 'icon',
    image: 'image'
  };

  export type ListEntryScalarFieldEnum = (typeof ListEntryScalarFieldEnum)[keyof typeof ListEntryScalarFieldEnum]


  export const ProductScalarFieldEnum: {
    id: 'id',
    sku: 'sku',
    name: 'name',
    slug: 'slug',
    description: 'description',
    bestFor: 'bestFor',
    image: 'image',
    price: 'price',
    proccessTime: 'proccessTime',
    inStock: 'inStock',
    status: 'status',
    categoryId: 'categoryId',
    keywords: 'keywords',
    quality: 'quality',
    isBest: 'isBest',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ProductScalarFieldEnum = (typeof ProductScalarFieldEnum)[keyof typeof ProductScalarFieldEnum]


  export const CategoryScalarFieldEnum: {
    id: 'id',
    name: 'name',
    slug: 'slug',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CategoryScalarFieldEnum = (typeof CategoryScalarFieldEnum)[keyof typeof CategoryScalarFieldEnum]


  export const TagScalarFieldEnum: {
    id: 'id',
    name: 'name',
    slug: 'slug'
  };

  export type TagScalarFieldEnum = (typeof TagScalarFieldEnum)[keyof typeof TagScalarFieldEnum]


  export const ProductGalleryScalarFieldEnum: {
    id: 'id',
    productId: 'productId',
    imageUrl: 'imageUrl',
    order: 'order',
    createdAt: 'createdAt'
  };

  export type ProductGalleryScalarFieldEnum = (typeof ProductGalleryScalarFieldEnum)[keyof typeof ProductGalleryScalarFieldEnum]


  export const BenefitScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    icon: 'icon'
  };

  export type BenefitScalarFieldEnum = (typeof BenefitScalarFieldEnum)[keyof typeof BenefitScalarFieldEnum]


  export const ProductBenefitScalarFieldEnum: {
    id: 'id',
    productId: 'productId',
    benefitId: 'benefitId',
    isActive: 'isActive',
    order: 'order'
  };

  export type ProductBenefitScalarFieldEnum = (typeof ProductBenefitScalarFieldEnum)[keyof typeof ProductBenefitScalarFieldEnum]


  export const ProductBenefitPointScalarFieldEnum: {
    id: 'id',
    productId: 'productId',
    text: 'text',
    order: 'order',
    icon: 'icon'
  };

  export type ProductBenefitPointScalarFieldEnum = (typeof ProductBenefitPointScalarFieldEnum)[keyof typeof ProductBenefitPointScalarFieldEnum]


  export const PromotionScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    type: 'type',
    value: 'value',
    isActive: 'isActive',
    startDate: 'startDate',
    endDate: 'endDate',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PromotionScalarFieldEnum = (typeof PromotionScalarFieldEnum)[keyof typeof PromotionScalarFieldEnum]


  export const VoucherScalarFieldEnum: {
    id: 'id',
    code: 'code',
    description: 'description',
    type: 'type',
    value: 'value',
    usageLimit: 'usageLimit',
    usedCount: 'usedCount',
    isActive: 'isActive',
    startDate: 'startDate',
    endDate: 'endDate',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type VoucherScalarFieldEnum = (typeof VoucherScalarFieldEnum)[keyof typeof VoucherScalarFieldEnum]


  export const VoucherUsageScalarFieldEnum: {
    id: 'id',
    voucherId: 'voucherId',
    userId: 'userId',
    usedAt: 'usedAt'
  };

  export type VoucherUsageScalarFieldEnum = (typeof VoucherUsageScalarFieldEnum)[keyof typeof VoucherUsageScalarFieldEnum]


  export const UserScalarFieldEnum: {
    id: 'id',
    firstName: 'firstName',
    lastName: 'lastName',
    name: 'name',
    userName: 'userName',
    email: 'email',
    password: 'password',
    emailVerified: 'emailVerified',
    image: 'image',
    role: 'role',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const AuthenticatorScalarFieldEnum: {
    credentialID: 'credentialID',
    userId: 'userId',
    providerAccountId: 'providerAccountId',
    credentialPublicKey: 'credentialPublicKey',
    counter: 'counter',
    credentialDeviceType: 'credentialDeviceType',
    credentialBackedUp: 'credentialBackedUp',
    transports: 'transports'
  };

  export type AuthenticatorScalarFieldEnum = (typeof AuthenticatorScalarFieldEnum)[keyof typeof AuthenticatorScalarFieldEnum]


  export const OrderScalarFieldEnum: {
    id: 'id',
    email: 'email',
    name: 'name',
    userId: 'userId',
    voucherId: 'voucherId',
    totalPrice: 'totalPrice',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type OrderScalarFieldEnum = (typeof OrderScalarFieldEnum)[keyof typeof OrderScalarFieldEnum]


  export const MenuScalarFieldEnum: {
    id: 'id',
    title: 'title',
    slug: 'slug',
    type: 'type',
    order: 'order',
    icon: 'icon',
    parentId: 'parentId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MenuScalarFieldEnum = (typeof MenuScalarFieldEnum)[keyof typeof MenuScalarFieldEnum]


  export const FooterInfoScalarFieldEnum: {
    id: 'id',
    label: 'label',
    value: 'value',
    type: 'type',
    icon: 'icon',
    order: 'order'
  };

  export type FooterInfoScalarFieldEnum = (typeof FooterInfoScalarFieldEnum)[keyof typeof FooterInfoScalarFieldEnum]


  export const AccountScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    type: 'type',
    provider: 'provider',
    providerAccountId: 'providerAccountId',
    refresh_token: 'refresh_token',
    access_token: 'access_token',
    expires_at: 'expires_at',
    token_type: 'token_type',
    scope: 'scope',
    id_token: 'id_token',
    session_state: 'session_state'
  };

  export type AccountScalarFieldEnum = (typeof AccountScalarFieldEnum)[keyof typeof AccountScalarFieldEnum]


  export const SessionScalarFieldEnum: {
    id: 'id',
    sessionToken: 'sessionToken',
    userId: 'userId',
    expires: 'expires',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SessionScalarFieldEnum = (typeof SessionScalarFieldEnum)[keyof typeof SessionScalarFieldEnum]


  export const VerificationTokenScalarFieldEnum: {
    identifier: 'identifier',
    token: 'token',
    expires: 'expires'
  };

  export type VerificationTokenScalarFieldEnum = (typeof VerificationTokenScalarFieldEnum)[keyof typeof VerificationTokenScalarFieldEnum]


  export const LandingPageScalarFieldEnum: {
    id: 'id',
    name: 'name',
    slug: 'slug',
    description: 'description',
    image: 'image',
    lpDesignStyleId: 'lpDesignStyleId',
    marketingTools: 'marketingTools',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type LandingPageScalarFieldEnum = (typeof LandingPageScalarFieldEnum)[keyof typeof LandingPageScalarFieldEnum]


  export const LpForScalarFieldEnum: {
    id: 'id',
    description: 'description'
  };

  export type LpForScalarFieldEnum = (typeof LpForScalarFieldEnum)[keyof typeof LpForScalarFieldEnum]


  export const LpContentTypeScalarFieldEnum: {
    id: 'id',
    type: 'type'
  };

  export type LpContentTypeScalarFieldEnum = (typeof LpContentTypeScalarFieldEnum)[keyof typeof LpContentTypeScalarFieldEnum]


  export const LpDesignStyleScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description'
  };

  export type LpDesignStyleScalarFieldEnum = (typeof LpDesignStyleScalarFieldEnum)[keyof typeof LpDesignStyleScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


  /**
   * Reference to a field of type 'SectionType'
   */
  export type EnumSectionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SectionType'>
    


  /**
   * Reference to a field of type 'ListItemType'
   */
  export type EnumListItemTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ListItemType'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'ProductStatus'
   */
  export type EnumProductStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ProductStatus'>
    


  /**
   * Reference to a field of type 'PromoType'
   */
  export type EnumPromoTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PromoType'>
    


  /**
   * Reference to a field of type 'UserRole'
   */
  export type EnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole'>
    


  /**
   * Reference to a field of type 'OrderStatus'
   */
  export type EnumOrderStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OrderStatus'>
    


  /**
   * Reference to a field of type 'MenuType'
   */
  export type EnumMenuTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MenuType'>
    


  /**
   * Reference to a field of type 'FooterInfoType'
   */
  export type EnumFooterInfoTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FooterInfoType'>
    
  /**
   * Deep Input Types
   */


  export type RegisterFormWhereInput = {
    AND?: RegisterFormWhereInput | RegisterFormWhereInput[]
    OR?: RegisterFormWhereInput[]
    NOT?: RegisterFormWhereInput | RegisterFormWhereInput[]
    id?: IntFilter<"RegisterForm"> | number
    name?: StringFilter<"RegisterForm"> | string
    type?: StringFilter<"RegisterForm"> | string
    placeholder?: StringFilter<"RegisterForm"> | string
    position?: IntFilter<"RegisterForm"> | number
    row?: IntFilter<"RegisterForm"> | number
    options?: StringNullableFilter<"RegisterForm"> | string | null
    required?: BoolFilter<"RegisterForm"> | boolean
    hint?: StringNullableFilter<"RegisterForm"> | string | null
    hintTrue?: StringFilter<"RegisterForm"> | string
    hintFalse?: StringFilter<"RegisterForm"> | string
    isActive?: BoolFilter<"RegisterForm"> | boolean
    createDate?: DateTimeFilter<"RegisterForm"> | Date | string
    updateDate?: DateTimeFilter<"RegisterForm"> | Date | string
  }

  export type RegisterFormOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    placeholder?: SortOrder
    position?: SortOrder
    row?: SortOrder
    options?: SortOrderInput | SortOrder
    required?: SortOrder
    hint?: SortOrderInput | SortOrder
    hintTrue?: SortOrder
    hintFalse?: SortOrder
    isActive?: SortOrder
    createDate?: SortOrder
    updateDate?: SortOrder
  }

  export type RegisterFormWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: RegisterFormWhereInput | RegisterFormWhereInput[]
    OR?: RegisterFormWhereInput[]
    NOT?: RegisterFormWhereInput | RegisterFormWhereInput[]
    name?: StringFilter<"RegisterForm"> | string
    type?: StringFilter<"RegisterForm"> | string
    placeholder?: StringFilter<"RegisterForm"> | string
    position?: IntFilter<"RegisterForm"> | number
    row?: IntFilter<"RegisterForm"> | number
    options?: StringNullableFilter<"RegisterForm"> | string | null
    required?: BoolFilter<"RegisterForm"> | boolean
    hint?: StringNullableFilter<"RegisterForm"> | string | null
    hintTrue?: StringFilter<"RegisterForm"> | string
    hintFalse?: StringFilter<"RegisterForm"> | string
    isActive?: BoolFilter<"RegisterForm"> | boolean
    createDate?: DateTimeFilter<"RegisterForm"> | Date | string
    updateDate?: DateTimeFilter<"RegisterForm"> | Date | string
  }, "id">

  export type RegisterFormOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    placeholder?: SortOrder
    position?: SortOrder
    row?: SortOrder
    options?: SortOrderInput | SortOrder
    required?: SortOrder
    hint?: SortOrderInput | SortOrder
    hintTrue?: SortOrder
    hintFalse?: SortOrder
    isActive?: SortOrder
    createDate?: SortOrder
    updateDate?: SortOrder
    _count?: RegisterFormCountOrderByAggregateInput
    _avg?: RegisterFormAvgOrderByAggregateInput
    _max?: RegisterFormMaxOrderByAggregateInput
    _min?: RegisterFormMinOrderByAggregateInput
    _sum?: RegisterFormSumOrderByAggregateInput
  }

  export type RegisterFormScalarWhereWithAggregatesInput = {
    AND?: RegisterFormScalarWhereWithAggregatesInput | RegisterFormScalarWhereWithAggregatesInput[]
    OR?: RegisterFormScalarWhereWithAggregatesInput[]
    NOT?: RegisterFormScalarWhereWithAggregatesInput | RegisterFormScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"RegisterForm"> | number
    name?: StringWithAggregatesFilter<"RegisterForm"> | string
    type?: StringWithAggregatesFilter<"RegisterForm"> | string
    placeholder?: StringWithAggregatesFilter<"RegisterForm"> | string
    position?: IntWithAggregatesFilter<"RegisterForm"> | number
    row?: IntWithAggregatesFilter<"RegisterForm"> | number
    options?: StringNullableWithAggregatesFilter<"RegisterForm"> | string | null
    required?: BoolWithAggregatesFilter<"RegisterForm"> | boolean
    hint?: StringNullableWithAggregatesFilter<"RegisterForm"> | string | null
    hintTrue?: StringWithAggregatesFilter<"RegisterForm"> | string
    hintFalse?: StringWithAggregatesFilter<"RegisterForm"> | string
    isActive?: BoolWithAggregatesFilter<"RegisterForm"> | boolean
    createDate?: DateTimeWithAggregatesFilter<"RegisterForm"> | Date | string
    updateDate?: DateTimeWithAggregatesFilter<"RegisterForm"> | Date | string
  }

  export type ApiListWhereInput = {
    AND?: ApiListWhereInput | ApiListWhereInput[]
    OR?: ApiListWhereInput[]
    NOT?: ApiListWhereInput | ApiListWhereInput[]
    id?: IntFilter<"ApiList"> | number
    name?: StringFilter<"ApiList"> | string
    createDate?: DateTimeFilter<"ApiList"> | Date | string
    updateDate?: DateTimeFilter<"ApiList"> | Date | string
  }

  export type ApiListOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    createDate?: SortOrder
    updateDate?: SortOrder
  }

  export type ApiListWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ApiListWhereInput | ApiListWhereInput[]
    OR?: ApiListWhereInput[]
    NOT?: ApiListWhereInput | ApiListWhereInput[]
    name?: StringFilter<"ApiList"> | string
    createDate?: DateTimeFilter<"ApiList"> | Date | string
    updateDate?: DateTimeFilter<"ApiList"> | Date | string
  }, "id">

  export type ApiListOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    createDate?: SortOrder
    updateDate?: SortOrder
    _count?: ApiListCountOrderByAggregateInput
    _avg?: ApiListAvgOrderByAggregateInput
    _max?: ApiListMaxOrderByAggregateInput
    _min?: ApiListMinOrderByAggregateInput
    _sum?: ApiListSumOrderByAggregateInput
  }

  export type ApiListScalarWhereWithAggregatesInput = {
    AND?: ApiListScalarWhereWithAggregatesInput | ApiListScalarWhereWithAggregatesInput[]
    OR?: ApiListScalarWhereWithAggregatesInput[]
    NOT?: ApiListScalarWhereWithAggregatesInput | ApiListScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ApiList"> | number
    name?: StringWithAggregatesFilter<"ApiList"> | string
    createDate?: DateTimeWithAggregatesFilter<"ApiList"> | Date | string
    updateDate?: DateTimeWithAggregatesFilter<"ApiList"> | Date | string
  }

  export type FacebookPixelWhereInput = {
    AND?: FacebookPixelWhereInput | FacebookPixelWhereInput[]
    OR?: FacebookPixelWhereInput[]
    NOT?: FacebookPixelWhereInput | FacebookPixelWhereInput[]
    id?: IntFilter<"FacebookPixel"> | number
    pixelId?: StringFilter<"FacebookPixel"> | string
    campaignName?: StringFilter<"FacebookPixel"> | string
    createdAt?: DateTimeFilter<"FacebookPixel"> | Date | string
    updatedAt?: DateTimeFilter<"FacebookPixel"> | Date | string
  }

  export type FacebookPixelOrderByWithRelationInput = {
    id?: SortOrder
    pixelId?: SortOrder
    campaignName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FacebookPixelWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: FacebookPixelWhereInput | FacebookPixelWhereInput[]
    OR?: FacebookPixelWhereInput[]
    NOT?: FacebookPixelWhereInput | FacebookPixelWhereInput[]
    pixelId?: StringFilter<"FacebookPixel"> | string
    campaignName?: StringFilter<"FacebookPixel"> | string
    createdAt?: DateTimeFilter<"FacebookPixel"> | Date | string
    updatedAt?: DateTimeFilter<"FacebookPixel"> | Date | string
  }, "id">

  export type FacebookPixelOrderByWithAggregationInput = {
    id?: SortOrder
    pixelId?: SortOrder
    campaignName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: FacebookPixelCountOrderByAggregateInput
    _avg?: FacebookPixelAvgOrderByAggregateInput
    _max?: FacebookPixelMaxOrderByAggregateInput
    _min?: FacebookPixelMinOrderByAggregateInput
    _sum?: FacebookPixelSumOrderByAggregateInput
  }

  export type FacebookPixelScalarWhereWithAggregatesInput = {
    AND?: FacebookPixelScalarWhereWithAggregatesInput | FacebookPixelScalarWhereWithAggregatesInput[]
    OR?: FacebookPixelScalarWhereWithAggregatesInput[]
    NOT?: FacebookPixelScalarWhereWithAggregatesInput | FacebookPixelScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"FacebookPixel"> | number
    pixelId?: StringWithAggregatesFilter<"FacebookPixel"> | string
    campaignName?: StringWithAggregatesFilter<"FacebookPixel"> | string
    createdAt?: DateTimeWithAggregatesFilter<"FacebookPixel"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"FacebookPixel"> | Date | string
  }

  export type SiteIdentityWhereInput = {
    AND?: SiteIdentityWhereInput | SiteIdentityWhereInput[]
    OR?: SiteIdentityWhereInput[]
    NOT?: SiteIdentityWhereInput | SiteIdentityWhereInput[]
    id?: StringFilter<"SiteIdentity"> | string
    siteName?: StringFilter<"SiteIdentity"> | string
    tagline?: StringNullableFilter<"SiteIdentity"> | string | null
    description?: StringNullableFilter<"SiteIdentity"> | string | null
    keywords?: JsonNullableFilter<"SiteIdentity">
    logoUrl?: StringFilter<"SiteIdentity"> | string
    ogImage?: StringNullableFilter<"SiteIdentity"> | string | null
    faviconUrl?: StringFilter<"SiteIdentity"> | string
    email?: StringNullableFilter<"SiteIdentity"> | string | null
    phone?: StringNullableFilter<"SiteIdentity"> | string | null
    address?: StringNullableFilter<"SiteIdentity"> | string | null
    createdAt?: DateTimeFilter<"SiteIdentity"> | Date | string
    updatedAt?: DateTimeFilter<"SiteIdentity"> | Date | string
    socialLinks?: SocialLinksListRelationFilter
  }

  export type SiteIdentityOrderByWithRelationInput = {
    id?: SortOrder
    siteName?: SortOrder
    tagline?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    keywords?: SortOrderInput | SortOrder
    logoUrl?: SortOrder
    ogImage?: SortOrderInput | SortOrder
    faviconUrl?: SortOrder
    email?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    socialLinks?: SocialLinksOrderByRelationAggregateInput
  }

  export type SiteIdentityWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SiteIdentityWhereInput | SiteIdentityWhereInput[]
    OR?: SiteIdentityWhereInput[]
    NOT?: SiteIdentityWhereInput | SiteIdentityWhereInput[]
    siteName?: StringFilter<"SiteIdentity"> | string
    tagline?: StringNullableFilter<"SiteIdentity"> | string | null
    description?: StringNullableFilter<"SiteIdentity"> | string | null
    keywords?: JsonNullableFilter<"SiteIdentity">
    logoUrl?: StringFilter<"SiteIdentity"> | string
    ogImage?: StringNullableFilter<"SiteIdentity"> | string | null
    faviconUrl?: StringFilter<"SiteIdentity"> | string
    email?: StringNullableFilter<"SiteIdentity"> | string | null
    phone?: StringNullableFilter<"SiteIdentity"> | string | null
    address?: StringNullableFilter<"SiteIdentity"> | string | null
    createdAt?: DateTimeFilter<"SiteIdentity"> | Date | string
    updatedAt?: DateTimeFilter<"SiteIdentity"> | Date | string
    socialLinks?: SocialLinksListRelationFilter
  }, "id">

  export type SiteIdentityOrderByWithAggregationInput = {
    id?: SortOrder
    siteName?: SortOrder
    tagline?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    keywords?: SortOrderInput | SortOrder
    logoUrl?: SortOrder
    ogImage?: SortOrderInput | SortOrder
    faviconUrl?: SortOrder
    email?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SiteIdentityCountOrderByAggregateInput
    _max?: SiteIdentityMaxOrderByAggregateInput
    _min?: SiteIdentityMinOrderByAggregateInput
  }

  export type SiteIdentityScalarWhereWithAggregatesInput = {
    AND?: SiteIdentityScalarWhereWithAggregatesInput | SiteIdentityScalarWhereWithAggregatesInput[]
    OR?: SiteIdentityScalarWhereWithAggregatesInput[]
    NOT?: SiteIdentityScalarWhereWithAggregatesInput | SiteIdentityScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SiteIdentity"> | string
    siteName?: StringWithAggregatesFilter<"SiteIdentity"> | string
    tagline?: StringNullableWithAggregatesFilter<"SiteIdentity"> | string | null
    description?: StringNullableWithAggregatesFilter<"SiteIdentity"> | string | null
    keywords?: JsonNullableWithAggregatesFilter<"SiteIdentity">
    logoUrl?: StringWithAggregatesFilter<"SiteIdentity"> | string
    ogImage?: StringNullableWithAggregatesFilter<"SiteIdentity"> | string | null
    faviconUrl?: StringWithAggregatesFilter<"SiteIdentity"> | string
    email?: StringNullableWithAggregatesFilter<"SiteIdentity"> | string | null
    phone?: StringNullableWithAggregatesFilter<"SiteIdentity"> | string | null
    address?: StringNullableWithAggregatesFilter<"SiteIdentity"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"SiteIdentity"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SiteIdentity"> | Date | string
  }

  export type SocialLinksWhereInput = {
    AND?: SocialLinksWhereInput | SocialLinksWhereInput[]
    OR?: SocialLinksWhereInput[]
    NOT?: SocialLinksWhereInput | SocialLinksWhereInput[]
    id?: StringFilter<"SocialLinks"> | string
    platform?: StringNullableFilter<"SocialLinks"> | string | null
    url?: StringNullableFilter<"SocialLinks"> | string | null
    platformUsername?: StringNullableFilter<"SocialLinks"> | string | null
    identityId?: StringNullableFilter<"SocialLinks"> | string | null
    createdAt?: DateTimeFilter<"SocialLinks"> | Date | string
    updatedAt?: DateTimeFilter<"SocialLinks"> | Date | string
    identity?: XOR<SiteIdentityNullableScalarRelationFilter, SiteIdentityWhereInput> | null
  }

  export type SocialLinksOrderByWithRelationInput = {
    id?: SortOrder
    platform?: SortOrderInput | SortOrder
    url?: SortOrderInput | SortOrder
    platformUsername?: SortOrderInput | SortOrder
    identityId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    identity?: SiteIdentityOrderByWithRelationInput
  }

  export type SocialLinksWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SocialLinksWhereInput | SocialLinksWhereInput[]
    OR?: SocialLinksWhereInput[]
    NOT?: SocialLinksWhereInput | SocialLinksWhereInput[]
    platform?: StringNullableFilter<"SocialLinks"> | string | null
    url?: StringNullableFilter<"SocialLinks"> | string | null
    platformUsername?: StringNullableFilter<"SocialLinks"> | string | null
    identityId?: StringNullableFilter<"SocialLinks"> | string | null
    createdAt?: DateTimeFilter<"SocialLinks"> | Date | string
    updatedAt?: DateTimeFilter<"SocialLinks"> | Date | string
    identity?: XOR<SiteIdentityNullableScalarRelationFilter, SiteIdentityWhereInput> | null
  }, "id">

  export type SocialLinksOrderByWithAggregationInput = {
    id?: SortOrder
    platform?: SortOrderInput | SortOrder
    url?: SortOrderInput | SortOrder
    platformUsername?: SortOrderInput | SortOrder
    identityId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SocialLinksCountOrderByAggregateInput
    _max?: SocialLinksMaxOrderByAggregateInput
    _min?: SocialLinksMinOrderByAggregateInput
  }

  export type SocialLinksScalarWhereWithAggregatesInput = {
    AND?: SocialLinksScalarWhereWithAggregatesInput | SocialLinksScalarWhereWithAggregatesInput[]
    OR?: SocialLinksScalarWhereWithAggregatesInput[]
    NOT?: SocialLinksScalarWhereWithAggregatesInput | SocialLinksScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SocialLinks"> | string
    platform?: StringNullableWithAggregatesFilter<"SocialLinks"> | string | null
    url?: StringNullableWithAggregatesFilter<"SocialLinks"> | string | null
    platformUsername?: StringNullableWithAggregatesFilter<"SocialLinks"> | string | null
    identityId?: StringNullableWithAggregatesFilter<"SocialLinks"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"SocialLinks"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SocialLinks"> | Date | string
  }

  export type PageWhereInput = {
    AND?: PageWhereInput | PageWhereInput[]
    OR?: PageWhereInput[]
    NOT?: PageWhereInput | PageWhereInput[]
    id?: StringFilter<"Page"> | string
    slug?: StringFilter<"Page"> | string
    name?: StringFilter<"Page"> | string
    title?: StringFilter<"Page"> | string
    description?: StringNullableFilter<"Page"> | string | null
    keywords?: JsonNullableFilter<"Page">
    ogTitle?: StringNullableFilter<"Page"> | string | null
    ogDescription?: StringNullableFilter<"Page"> | string | null
    ogImage?: StringNullableFilter<"Page"> | string | null
    createdAt?: DateTimeFilter<"Page"> | Date | string
    updatedAt?: DateTimeFilter<"Page"> | Date | string
    sections?: SectionListRelationFilter
  }

  export type PageOrderByWithRelationInput = {
    id?: SortOrder
    slug?: SortOrder
    name?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    keywords?: SortOrderInput | SortOrder
    ogTitle?: SortOrderInput | SortOrder
    ogDescription?: SortOrderInput | SortOrder
    ogImage?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    sections?: SectionOrderByRelationAggregateInput
  }

  export type PageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    slug?: string
    AND?: PageWhereInput | PageWhereInput[]
    OR?: PageWhereInput[]
    NOT?: PageWhereInput | PageWhereInput[]
    name?: StringFilter<"Page"> | string
    title?: StringFilter<"Page"> | string
    description?: StringNullableFilter<"Page"> | string | null
    keywords?: JsonNullableFilter<"Page">
    ogTitle?: StringNullableFilter<"Page"> | string | null
    ogDescription?: StringNullableFilter<"Page"> | string | null
    ogImage?: StringNullableFilter<"Page"> | string | null
    createdAt?: DateTimeFilter<"Page"> | Date | string
    updatedAt?: DateTimeFilter<"Page"> | Date | string
    sections?: SectionListRelationFilter
  }, "id" | "slug">

  export type PageOrderByWithAggregationInput = {
    id?: SortOrder
    slug?: SortOrder
    name?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    keywords?: SortOrderInput | SortOrder
    ogTitle?: SortOrderInput | SortOrder
    ogDescription?: SortOrderInput | SortOrder
    ogImage?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PageCountOrderByAggregateInput
    _max?: PageMaxOrderByAggregateInput
    _min?: PageMinOrderByAggregateInput
  }

  export type PageScalarWhereWithAggregatesInput = {
    AND?: PageScalarWhereWithAggregatesInput | PageScalarWhereWithAggregatesInput[]
    OR?: PageScalarWhereWithAggregatesInput[]
    NOT?: PageScalarWhereWithAggregatesInput | PageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Page"> | string
    slug?: StringWithAggregatesFilter<"Page"> | string
    name?: StringWithAggregatesFilter<"Page"> | string
    title?: StringWithAggregatesFilter<"Page"> | string
    description?: StringNullableWithAggregatesFilter<"Page"> | string | null
    keywords?: JsonNullableWithAggregatesFilter<"Page">
    ogTitle?: StringNullableWithAggregatesFilter<"Page"> | string | null
    ogDescription?: StringNullableWithAggregatesFilter<"Page"> | string | null
    ogImage?: StringNullableWithAggregatesFilter<"Page"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Page"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Page"> | Date | string
  }

  export type SectionWhereInput = {
    AND?: SectionWhereInput | SectionWhereInput[]
    OR?: SectionWhereInput[]
    NOT?: SectionWhereInput | SectionWhereInput[]
    id?: StringFilter<"Section"> | string
    name?: StringNullableFilter<"Section"> | string | null
    pageId?: StringFilter<"Section"> | string
    type?: EnumSectionTypeFilter<"Section"> | $Enums.SectionType
    title?: StringFilter<"Section"> | string
    subTitle?: StringNullableFilter<"Section"> | string | null
    description?: StringNullableFilter<"Section"> | string | null
    additionalText?: StringNullableFilter<"Section"> | string | null
    image?: StringNullableFilter<"Section"> | string | null
    video?: StringNullableFilter<"Section"> | string | null
    icon?: StringNullableFilter<"Section"> | string | null
    order?: IntFilter<"Section"> | number
    page?: XOR<PageScalarRelationFilter, PageWhereInput>
    listItems?: ListItemListRelationFilter
  }

  export type SectionOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrderInput | SortOrder
    pageId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    subTitle?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    additionalText?: SortOrderInput | SortOrder
    image?: SortOrderInput | SortOrder
    video?: SortOrderInput | SortOrder
    icon?: SortOrderInput | SortOrder
    order?: SortOrder
    page?: PageOrderByWithRelationInput
    listItems?: ListItemOrderByRelationAggregateInput
  }

  export type SectionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SectionWhereInput | SectionWhereInput[]
    OR?: SectionWhereInput[]
    NOT?: SectionWhereInput | SectionWhereInput[]
    name?: StringNullableFilter<"Section"> | string | null
    pageId?: StringFilter<"Section"> | string
    type?: EnumSectionTypeFilter<"Section"> | $Enums.SectionType
    title?: StringFilter<"Section"> | string
    subTitle?: StringNullableFilter<"Section"> | string | null
    description?: StringNullableFilter<"Section"> | string | null
    additionalText?: StringNullableFilter<"Section"> | string | null
    image?: StringNullableFilter<"Section"> | string | null
    video?: StringNullableFilter<"Section"> | string | null
    icon?: StringNullableFilter<"Section"> | string | null
    order?: IntFilter<"Section"> | number
    page?: XOR<PageScalarRelationFilter, PageWhereInput>
    listItems?: ListItemListRelationFilter
  }, "id">

  export type SectionOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrderInput | SortOrder
    pageId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    subTitle?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    additionalText?: SortOrderInput | SortOrder
    image?: SortOrderInput | SortOrder
    video?: SortOrderInput | SortOrder
    icon?: SortOrderInput | SortOrder
    order?: SortOrder
    _count?: SectionCountOrderByAggregateInput
    _avg?: SectionAvgOrderByAggregateInput
    _max?: SectionMaxOrderByAggregateInput
    _min?: SectionMinOrderByAggregateInput
    _sum?: SectionSumOrderByAggregateInput
  }

  export type SectionScalarWhereWithAggregatesInput = {
    AND?: SectionScalarWhereWithAggregatesInput | SectionScalarWhereWithAggregatesInput[]
    OR?: SectionScalarWhereWithAggregatesInput[]
    NOT?: SectionScalarWhereWithAggregatesInput | SectionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Section"> | string
    name?: StringNullableWithAggregatesFilter<"Section"> | string | null
    pageId?: StringWithAggregatesFilter<"Section"> | string
    type?: EnumSectionTypeWithAggregatesFilter<"Section"> | $Enums.SectionType
    title?: StringWithAggregatesFilter<"Section"> | string
    subTitle?: StringNullableWithAggregatesFilter<"Section"> | string | null
    description?: StringNullableWithAggregatesFilter<"Section"> | string | null
    additionalText?: StringNullableWithAggregatesFilter<"Section"> | string | null
    image?: StringNullableWithAggregatesFilter<"Section"> | string | null
    video?: StringNullableWithAggregatesFilter<"Section"> | string | null
    icon?: StringNullableWithAggregatesFilter<"Section"> | string | null
    order?: IntWithAggregatesFilter<"Section"> | number
  }

  export type ListItemWhereInput = {
    AND?: ListItemWhereInput | ListItemWhereInput[]
    OR?: ListItemWhereInput[]
    NOT?: ListItemWhereInput | ListItemWhereInput[]
    id?: StringFilter<"ListItem"> | string
    sectionId?: StringFilter<"ListItem"> | string
    type?: EnumListItemTypeFilter<"ListItem"> | $Enums.ListItemType
    title?: StringFilter<"ListItem"> | string
    description?: StringNullableFilter<"ListItem"> | string | null
    section?: XOR<SectionScalarRelationFilter, SectionWhereInput>
    entries?: ListEntryListRelationFilter
  }

  export type ListItemOrderByWithRelationInput = {
    id?: SortOrder
    sectionId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    section?: SectionOrderByWithRelationInput
    entries?: ListEntryOrderByRelationAggregateInput
  }

  export type ListItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ListItemWhereInput | ListItemWhereInput[]
    OR?: ListItemWhereInput[]
    NOT?: ListItemWhereInput | ListItemWhereInput[]
    sectionId?: StringFilter<"ListItem"> | string
    type?: EnumListItemTypeFilter<"ListItem"> | $Enums.ListItemType
    title?: StringFilter<"ListItem"> | string
    description?: StringNullableFilter<"ListItem"> | string | null
    section?: XOR<SectionScalarRelationFilter, SectionWhereInput>
    entries?: ListEntryListRelationFilter
  }, "id">

  export type ListItemOrderByWithAggregationInput = {
    id?: SortOrder
    sectionId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    _count?: ListItemCountOrderByAggregateInput
    _max?: ListItemMaxOrderByAggregateInput
    _min?: ListItemMinOrderByAggregateInput
  }

  export type ListItemScalarWhereWithAggregatesInput = {
    AND?: ListItemScalarWhereWithAggregatesInput | ListItemScalarWhereWithAggregatesInput[]
    OR?: ListItemScalarWhereWithAggregatesInput[]
    NOT?: ListItemScalarWhereWithAggregatesInput | ListItemScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ListItem"> | string
    sectionId?: StringWithAggregatesFilter<"ListItem"> | string
    type?: EnumListItemTypeWithAggregatesFilter<"ListItem"> | $Enums.ListItemType
    title?: StringWithAggregatesFilter<"ListItem"> | string
    description?: StringNullableWithAggregatesFilter<"ListItem"> | string | null
  }

  export type ListEntryWhereInput = {
    AND?: ListEntryWhereInput | ListEntryWhereInput[]
    OR?: ListEntryWhereInput[]
    NOT?: ListEntryWhereInput | ListEntryWhereInput[]
    id?: StringFilter<"ListEntry"> | string
    listItemId?: StringFilter<"ListEntry"> | string
    title?: StringFilter<"ListEntry"> | string
    price?: IntNullableFilter<"ListEntry"> | number | null
    description?: StringNullableFilter<"ListEntry"> | string | null
    icon?: StringNullableFilter<"ListEntry"> | string | null
    image?: StringNullableFilter<"ListEntry"> | string | null
    listItem?: XOR<ListItemScalarRelationFilter, ListItemWhereInput>
  }

  export type ListEntryOrderByWithRelationInput = {
    id?: SortOrder
    listItemId?: SortOrder
    title?: SortOrder
    price?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    icon?: SortOrderInput | SortOrder
    image?: SortOrderInput | SortOrder
    listItem?: ListItemOrderByWithRelationInput
  }

  export type ListEntryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ListEntryWhereInput | ListEntryWhereInput[]
    OR?: ListEntryWhereInput[]
    NOT?: ListEntryWhereInput | ListEntryWhereInput[]
    listItemId?: StringFilter<"ListEntry"> | string
    title?: StringFilter<"ListEntry"> | string
    price?: IntNullableFilter<"ListEntry"> | number | null
    description?: StringNullableFilter<"ListEntry"> | string | null
    icon?: StringNullableFilter<"ListEntry"> | string | null
    image?: StringNullableFilter<"ListEntry"> | string | null
    listItem?: XOR<ListItemScalarRelationFilter, ListItemWhereInput>
  }, "id">

  export type ListEntryOrderByWithAggregationInput = {
    id?: SortOrder
    listItemId?: SortOrder
    title?: SortOrder
    price?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    icon?: SortOrderInput | SortOrder
    image?: SortOrderInput | SortOrder
    _count?: ListEntryCountOrderByAggregateInput
    _avg?: ListEntryAvgOrderByAggregateInput
    _max?: ListEntryMaxOrderByAggregateInput
    _min?: ListEntryMinOrderByAggregateInput
    _sum?: ListEntrySumOrderByAggregateInput
  }

  export type ListEntryScalarWhereWithAggregatesInput = {
    AND?: ListEntryScalarWhereWithAggregatesInput | ListEntryScalarWhereWithAggregatesInput[]
    OR?: ListEntryScalarWhereWithAggregatesInput[]
    NOT?: ListEntryScalarWhereWithAggregatesInput | ListEntryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ListEntry"> | string
    listItemId?: StringWithAggregatesFilter<"ListEntry"> | string
    title?: StringWithAggregatesFilter<"ListEntry"> | string
    price?: IntNullableWithAggregatesFilter<"ListEntry"> | number | null
    description?: StringNullableWithAggregatesFilter<"ListEntry"> | string | null
    icon?: StringNullableWithAggregatesFilter<"ListEntry"> | string | null
    image?: StringNullableWithAggregatesFilter<"ListEntry"> | string | null
  }

  export type ProductWhereInput = {
    AND?: ProductWhereInput | ProductWhereInput[]
    OR?: ProductWhereInput[]
    NOT?: ProductWhereInput | ProductWhereInput[]
    id?: StringFilter<"Product"> | string
    sku?: StringFilter<"Product"> | string
    name?: StringFilter<"Product"> | string
    slug?: StringFilter<"Product"> | string
    description?: StringNullableFilter<"Product"> | string | null
    bestFor?: StringNullableFilter<"Product"> | string | null
    image?: StringNullableFilter<"Product"> | string | null
    price?: FloatFilter<"Product"> | number
    proccessTime?: IntNullableFilter<"Product"> | number | null
    inStock?: BoolFilter<"Product"> | boolean
    status?: EnumProductStatusFilter<"Product"> | $Enums.ProductStatus
    categoryId?: StringFilter<"Product"> | string
    keywords?: JsonNullableFilter<"Product">
    quality?: IntFilter<"Product"> | number
    isBest?: BoolFilter<"Product"> | boolean
    createdAt?: DateTimeFilter<"Product"> | Date | string
    updatedAt?: DateTimeFilter<"Product"> | Date | string
    category?: XOR<CategoryScalarRelationFilter, CategoryWhereInput>
    tags?: TagListRelationFilter
    gallery?: ProductGalleryListRelationFilter
    benefits?: ProductBenefitListRelationFilter
    benefitPoints?: ProductBenefitPointListRelationFilter
    promotions?: PromotionListRelationFilter
    vouchers?: VoucherListRelationFilter
    orders?: OrderListRelationFilter
  }

  export type ProductOrderByWithRelationInput = {
    id?: SortOrder
    sku?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrderInput | SortOrder
    bestFor?: SortOrderInput | SortOrder
    image?: SortOrderInput | SortOrder
    price?: SortOrder
    proccessTime?: SortOrderInput | SortOrder
    inStock?: SortOrder
    status?: SortOrder
    categoryId?: SortOrder
    keywords?: SortOrderInput | SortOrder
    quality?: SortOrder
    isBest?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    category?: CategoryOrderByWithRelationInput
    tags?: TagOrderByRelationAggregateInput
    gallery?: ProductGalleryOrderByRelationAggregateInput
    benefits?: ProductBenefitOrderByRelationAggregateInput
    benefitPoints?: ProductBenefitPointOrderByRelationAggregateInput
    promotions?: PromotionOrderByRelationAggregateInput
    vouchers?: VoucherOrderByRelationAggregateInput
    orders?: OrderOrderByRelationAggregateInput
  }

  export type ProductWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    sku?: string
    slug?: string
    AND?: ProductWhereInput | ProductWhereInput[]
    OR?: ProductWhereInput[]
    NOT?: ProductWhereInput | ProductWhereInput[]
    name?: StringFilter<"Product"> | string
    description?: StringNullableFilter<"Product"> | string | null
    bestFor?: StringNullableFilter<"Product"> | string | null
    image?: StringNullableFilter<"Product"> | string | null
    price?: FloatFilter<"Product"> | number
    proccessTime?: IntNullableFilter<"Product"> | number | null
    inStock?: BoolFilter<"Product"> | boolean
    status?: EnumProductStatusFilter<"Product"> | $Enums.ProductStatus
    categoryId?: StringFilter<"Product"> | string
    keywords?: JsonNullableFilter<"Product">
    quality?: IntFilter<"Product"> | number
    isBest?: BoolFilter<"Product"> | boolean
    createdAt?: DateTimeFilter<"Product"> | Date | string
    updatedAt?: DateTimeFilter<"Product"> | Date | string
    category?: XOR<CategoryScalarRelationFilter, CategoryWhereInput>
    tags?: TagListRelationFilter
    gallery?: ProductGalleryListRelationFilter
    benefits?: ProductBenefitListRelationFilter
    benefitPoints?: ProductBenefitPointListRelationFilter
    promotions?: PromotionListRelationFilter
    vouchers?: VoucherListRelationFilter
    orders?: OrderListRelationFilter
  }, "id" | "sku" | "slug">

  export type ProductOrderByWithAggregationInput = {
    id?: SortOrder
    sku?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrderInput | SortOrder
    bestFor?: SortOrderInput | SortOrder
    image?: SortOrderInput | SortOrder
    price?: SortOrder
    proccessTime?: SortOrderInput | SortOrder
    inStock?: SortOrder
    status?: SortOrder
    categoryId?: SortOrder
    keywords?: SortOrderInput | SortOrder
    quality?: SortOrder
    isBest?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ProductCountOrderByAggregateInput
    _avg?: ProductAvgOrderByAggregateInput
    _max?: ProductMaxOrderByAggregateInput
    _min?: ProductMinOrderByAggregateInput
    _sum?: ProductSumOrderByAggregateInput
  }

  export type ProductScalarWhereWithAggregatesInput = {
    AND?: ProductScalarWhereWithAggregatesInput | ProductScalarWhereWithAggregatesInput[]
    OR?: ProductScalarWhereWithAggregatesInput[]
    NOT?: ProductScalarWhereWithAggregatesInput | ProductScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Product"> | string
    sku?: StringWithAggregatesFilter<"Product"> | string
    name?: StringWithAggregatesFilter<"Product"> | string
    slug?: StringWithAggregatesFilter<"Product"> | string
    description?: StringNullableWithAggregatesFilter<"Product"> | string | null
    bestFor?: StringNullableWithAggregatesFilter<"Product"> | string | null
    image?: StringNullableWithAggregatesFilter<"Product"> | string | null
    price?: FloatWithAggregatesFilter<"Product"> | number
    proccessTime?: IntNullableWithAggregatesFilter<"Product"> | number | null
    inStock?: BoolWithAggregatesFilter<"Product"> | boolean
    status?: EnumProductStatusWithAggregatesFilter<"Product"> | $Enums.ProductStatus
    categoryId?: StringWithAggregatesFilter<"Product"> | string
    keywords?: JsonNullableWithAggregatesFilter<"Product">
    quality?: IntWithAggregatesFilter<"Product"> | number
    isBest?: BoolWithAggregatesFilter<"Product"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Product"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Product"> | Date | string
  }

  export type CategoryWhereInput = {
    AND?: CategoryWhereInput | CategoryWhereInput[]
    OR?: CategoryWhereInput[]
    NOT?: CategoryWhereInput | CategoryWhereInput[]
    id?: StringFilter<"Category"> | string
    name?: StringFilter<"Category"> | string
    slug?: StringFilter<"Category"> | string
    createdAt?: DateTimeFilter<"Category"> | Date | string
    updatedAt?: DateTimeFilter<"Category"> | Date | string
    products?: ProductListRelationFilter
  }

  export type CategoryOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    products?: ProductOrderByRelationAggregateInput
  }

  export type CategoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    slug?: string
    AND?: CategoryWhereInput | CategoryWhereInput[]
    OR?: CategoryWhereInput[]
    NOT?: CategoryWhereInput | CategoryWhereInput[]
    name?: StringFilter<"Category"> | string
    createdAt?: DateTimeFilter<"Category"> | Date | string
    updatedAt?: DateTimeFilter<"Category"> | Date | string
    products?: ProductListRelationFilter
  }, "id" | "slug">

  export type CategoryOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CategoryCountOrderByAggregateInput
    _max?: CategoryMaxOrderByAggregateInput
    _min?: CategoryMinOrderByAggregateInput
  }

  export type CategoryScalarWhereWithAggregatesInput = {
    AND?: CategoryScalarWhereWithAggregatesInput | CategoryScalarWhereWithAggregatesInput[]
    OR?: CategoryScalarWhereWithAggregatesInput[]
    NOT?: CategoryScalarWhereWithAggregatesInput | CategoryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Category"> | string
    name?: StringWithAggregatesFilter<"Category"> | string
    slug?: StringWithAggregatesFilter<"Category"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Category"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Category"> | Date | string
  }

  export type TagWhereInput = {
    AND?: TagWhereInput | TagWhereInput[]
    OR?: TagWhereInput[]
    NOT?: TagWhereInput | TagWhereInput[]
    id?: StringFilter<"Tag"> | string
    name?: StringFilter<"Tag"> | string
    slug?: StringFilter<"Tag"> | string
    products?: ProductListRelationFilter
  }

  export type TagOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    products?: ProductOrderByRelationAggregateInput
  }

  export type TagWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    slug?: string
    AND?: TagWhereInput | TagWhereInput[]
    OR?: TagWhereInput[]
    NOT?: TagWhereInput | TagWhereInput[]
    name?: StringFilter<"Tag"> | string
    products?: ProductListRelationFilter
  }, "id" | "slug">

  export type TagOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    _count?: TagCountOrderByAggregateInput
    _max?: TagMaxOrderByAggregateInput
    _min?: TagMinOrderByAggregateInput
  }

  export type TagScalarWhereWithAggregatesInput = {
    AND?: TagScalarWhereWithAggregatesInput | TagScalarWhereWithAggregatesInput[]
    OR?: TagScalarWhereWithAggregatesInput[]
    NOT?: TagScalarWhereWithAggregatesInput | TagScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Tag"> | string
    name?: StringWithAggregatesFilter<"Tag"> | string
    slug?: StringWithAggregatesFilter<"Tag"> | string
  }

  export type ProductGalleryWhereInput = {
    AND?: ProductGalleryWhereInput | ProductGalleryWhereInput[]
    OR?: ProductGalleryWhereInput[]
    NOT?: ProductGalleryWhereInput | ProductGalleryWhereInput[]
    id?: StringFilter<"ProductGallery"> | string
    productId?: StringFilter<"ProductGallery"> | string
    imageUrl?: StringFilter<"ProductGallery"> | string
    order?: IntFilter<"ProductGallery"> | number
    createdAt?: DateTimeFilter<"ProductGallery"> | Date | string
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
  }

  export type ProductGalleryOrderByWithRelationInput = {
    id?: SortOrder
    productId?: SortOrder
    imageUrl?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
    product?: ProductOrderByWithRelationInput
  }

  export type ProductGalleryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ProductGalleryWhereInput | ProductGalleryWhereInput[]
    OR?: ProductGalleryWhereInput[]
    NOT?: ProductGalleryWhereInput | ProductGalleryWhereInput[]
    productId?: StringFilter<"ProductGallery"> | string
    imageUrl?: StringFilter<"ProductGallery"> | string
    order?: IntFilter<"ProductGallery"> | number
    createdAt?: DateTimeFilter<"ProductGallery"> | Date | string
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
  }, "id">

  export type ProductGalleryOrderByWithAggregationInput = {
    id?: SortOrder
    productId?: SortOrder
    imageUrl?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
    _count?: ProductGalleryCountOrderByAggregateInput
    _avg?: ProductGalleryAvgOrderByAggregateInput
    _max?: ProductGalleryMaxOrderByAggregateInput
    _min?: ProductGalleryMinOrderByAggregateInput
    _sum?: ProductGallerySumOrderByAggregateInput
  }

  export type ProductGalleryScalarWhereWithAggregatesInput = {
    AND?: ProductGalleryScalarWhereWithAggregatesInput | ProductGalleryScalarWhereWithAggregatesInput[]
    OR?: ProductGalleryScalarWhereWithAggregatesInput[]
    NOT?: ProductGalleryScalarWhereWithAggregatesInput | ProductGalleryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ProductGallery"> | string
    productId?: StringWithAggregatesFilter<"ProductGallery"> | string
    imageUrl?: StringWithAggregatesFilter<"ProductGallery"> | string
    order?: IntWithAggregatesFilter<"ProductGallery"> | number
    createdAt?: DateTimeWithAggregatesFilter<"ProductGallery"> | Date | string
  }

  export type BenefitWhereInput = {
    AND?: BenefitWhereInput | BenefitWhereInput[]
    OR?: BenefitWhereInput[]
    NOT?: BenefitWhereInput | BenefitWhereInput[]
    id?: StringFilter<"Benefit"> | string
    title?: StringFilter<"Benefit"> | string
    description?: StringNullableFilter<"Benefit"> | string | null
    icon?: StringNullableFilter<"Benefit"> | string | null
    products?: ProductBenefitListRelationFilter
  }

  export type BenefitOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    icon?: SortOrderInput | SortOrder
    products?: ProductBenefitOrderByRelationAggregateInput
  }

  export type BenefitWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: BenefitWhereInput | BenefitWhereInput[]
    OR?: BenefitWhereInput[]
    NOT?: BenefitWhereInput | BenefitWhereInput[]
    title?: StringFilter<"Benefit"> | string
    description?: StringNullableFilter<"Benefit"> | string | null
    icon?: StringNullableFilter<"Benefit"> | string | null
    products?: ProductBenefitListRelationFilter
  }, "id">

  export type BenefitOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    icon?: SortOrderInput | SortOrder
    _count?: BenefitCountOrderByAggregateInput
    _max?: BenefitMaxOrderByAggregateInput
    _min?: BenefitMinOrderByAggregateInput
  }

  export type BenefitScalarWhereWithAggregatesInput = {
    AND?: BenefitScalarWhereWithAggregatesInput | BenefitScalarWhereWithAggregatesInput[]
    OR?: BenefitScalarWhereWithAggregatesInput[]
    NOT?: BenefitScalarWhereWithAggregatesInput | BenefitScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Benefit"> | string
    title?: StringWithAggregatesFilter<"Benefit"> | string
    description?: StringNullableWithAggregatesFilter<"Benefit"> | string | null
    icon?: StringNullableWithAggregatesFilter<"Benefit"> | string | null
  }

  export type ProductBenefitWhereInput = {
    AND?: ProductBenefitWhereInput | ProductBenefitWhereInput[]
    OR?: ProductBenefitWhereInput[]
    NOT?: ProductBenefitWhereInput | ProductBenefitWhereInput[]
    id?: StringFilter<"ProductBenefit"> | string
    productId?: StringFilter<"ProductBenefit"> | string
    benefitId?: StringFilter<"ProductBenefit"> | string
    isActive?: BoolFilter<"ProductBenefit"> | boolean
    order?: IntFilter<"ProductBenefit"> | number
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
    benefit?: XOR<BenefitScalarRelationFilter, BenefitWhereInput>
  }

  export type ProductBenefitOrderByWithRelationInput = {
    id?: SortOrder
    productId?: SortOrder
    benefitId?: SortOrder
    isActive?: SortOrder
    order?: SortOrder
    product?: ProductOrderByWithRelationInput
    benefit?: BenefitOrderByWithRelationInput
  }

  export type ProductBenefitWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ProductBenefitWhereInput | ProductBenefitWhereInput[]
    OR?: ProductBenefitWhereInput[]
    NOT?: ProductBenefitWhereInput | ProductBenefitWhereInput[]
    productId?: StringFilter<"ProductBenefit"> | string
    benefitId?: StringFilter<"ProductBenefit"> | string
    isActive?: BoolFilter<"ProductBenefit"> | boolean
    order?: IntFilter<"ProductBenefit"> | number
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
    benefit?: XOR<BenefitScalarRelationFilter, BenefitWhereInput>
  }, "id">

  export type ProductBenefitOrderByWithAggregationInput = {
    id?: SortOrder
    productId?: SortOrder
    benefitId?: SortOrder
    isActive?: SortOrder
    order?: SortOrder
    _count?: ProductBenefitCountOrderByAggregateInput
    _avg?: ProductBenefitAvgOrderByAggregateInput
    _max?: ProductBenefitMaxOrderByAggregateInput
    _min?: ProductBenefitMinOrderByAggregateInput
    _sum?: ProductBenefitSumOrderByAggregateInput
  }

  export type ProductBenefitScalarWhereWithAggregatesInput = {
    AND?: ProductBenefitScalarWhereWithAggregatesInput | ProductBenefitScalarWhereWithAggregatesInput[]
    OR?: ProductBenefitScalarWhereWithAggregatesInput[]
    NOT?: ProductBenefitScalarWhereWithAggregatesInput | ProductBenefitScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ProductBenefit"> | string
    productId?: StringWithAggregatesFilter<"ProductBenefit"> | string
    benefitId?: StringWithAggregatesFilter<"ProductBenefit"> | string
    isActive?: BoolWithAggregatesFilter<"ProductBenefit"> | boolean
    order?: IntWithAggregatesFilter<"ProductBenefit"> | number
  }

  export type ProductBenefitPointWhereInput = {
    AND?: ProductBenefitPointWhereInput | ProductBenefitPointWhereInput[]
    OR?: ProductBenefitPointWhereInput[]
    NOT?: ProductBenefitPointWhereInput | ProductBenefitPointWhereInput[]
    id?: StringFilter<"ProductBenefitPoint"> | string
    productId?: StringFilter<"ProductBenefitPoint"> | string
    text?: StringFilter<"ProductBenefitPoint"> | string
    order?: IntFilter<"ProductBenefitPoint"> | number
    icon?: StringNullableFilter<"ProductBenefitPoint"> | string | null
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
  }

  export type ProductBenefitPointOrderByWithRelationInput = {
    id?: SortOrder
    productId?: SortOrder
    text?: SortOrder
    order?: SortOrder
    icon?: SortOrderInput | SortOrder
    product?: ProductOrderByWithRelationInput
  }

  export type ProductBenefitPointWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ProductBenefitPointWhereInput | ProductBenefitPointWhereInput[]
    OR?: ProductBenefitPointWhereInput[]
    NOT?: ProductBenefitPointWhereInput | ProductBenefitPointWhereInput[]
    productId?: StringFilter<"ProductBenefitPoint"> | string
    text?: StringFilter<"ProductBenefitPoint"> | string
    order?: IntFilter<"ProductBenefitPoint"> | number
    icon?: StringNullableFilter<"ProductBenefitPoint"> | string | null
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
  }, "id">

  export type ProductBenefitPointOrderByWithAggregationInput = {
    id?: SortOrder
    productId?: SortOrder
    text?: SortOrder
    order?: SortOrder
    icon?: SortOrderInput | SortOrder
    _count?: ProductBenefitPointCountOrderByAggregateInput
    _avg?: ProductBenefitPointAvgOrderByAggregateInput
    _max?: ProductBenefitPointMaxOrderByAggregateInput
    _min?: ProductBenefitPointMinOrderByAggregateInput
    _sum?: ProductBenefitPointSumOrderByAggregateInput
  }

  export type ProductBenefitPointScalarWhereWithAggregatesInput = {
    AND?: ProductBenefitPointScalarWhereWithAggregatesInput | ProductBenefitPointScalarWhereWithAggregatesInput[]
    OR?: ProductBenefitPointScalarWhereWithAggregatesInput[]
    NOT?: ProductBenefitPointScalarWhereWithAggregatesInput | ProductBenefitPointScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ProductBenefitPoint"> | string
    productId?: StringWithAggregatesFilter<"ProductBenefitPoint"> | string
    text?: StringWithAggregatesFilter<"ProductBenefitPoint"> | string
    order?: IntWithAggregatesFilter<"ProductBenefitPoint"> | number
    icon?: StringNullableWithAggregatesFilter<"ProductBenefitPoint"> | string | null
  }

  export type PromotionWhereInput = {
    AND?: PromotionWhereInput | PromotionWhereInput[]
    OR?: PromotionWhereInput[]
    NOT?: PromotionWhereInput | PromotionWhereInput[]
    id?: StringFilter<"Promotion"> | string
    name?: StringFilter<"Promotion"> | string
    description?: StringNullableFilter<"Promotion"> | string | null
    type?: EnumPromoTypeFilter<"Promotion"> | $Enums.PromoType
    value?: FloatNullableFilter<"Promotion"> | number | null
    isActive?: BoolFilter<"Promotion"> | boolean
    startDate?: DateTimeFilter<"Promotion"> | Date | string
    endDate?: DateTimeFilter<"Promotion"> | Date | string
    createdAt?: DateTimeFilter<"Promotion"> | Date | string
    updatedAt?: DateTimeFilter<"Promotion"> | Date | string
    products?: ProductListRelationFilter
  }

  export type PromotionOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    type?: SortOrder
    value?: SortOrderInput | SortOrder
    isActive?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    products?: ProductOrderByRelationAggregateInput
  }

  export type PromotionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PromotionWhereInput | PromotionWhereInput[]
    OR?: PromotionWhereInput[]
    NOT?: PromotionWhereInput | PromotionWhereInput[]
    name?: StringFilter<"Promotion"> | string
    description?: StringNullableFilter<"Promotion"> | string | null
    type?: EnumPromoTypeFilter<"Promotion"> | $Enums.PromoType
    value?: FloatNullableFilter<"Promotion"> | number | null
    isActive?: BoolFilter<"Promotion"> | boolean
    startDate?: DateTimeFilter<"Promotion"> | Date | string
    endDate?: DateTimeFilter<"Promotion"> | Date | string
    createdAt?: DateTimeFilter<"Promotion"> | Date | string
    updatedAt?: DateTimeFilter<"Promotion"> | Date | string
    products?: ProductListRelationFilter
  }, "id">

  export type PromotionOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    type?: SortOrder
    value?: SortOrderInput | SortOrder
    isActive?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PromotionCountOrderByAggregateInput
    _avg?: PromotionAvgOrderByAggregateInput
    _max?: PromotionMaxOrderByAggregateInput
    _min?: PromotionMinOrderByAggregateInput
    _sum?: PromotionSumOrderByAggregateInput
  }

  export type PromotionScalarWhereWithAggregatesInput = {
    AND?: PromotionScalarWhereWithAggregatesInput | PromotionScalarWhereWithAggregatesInput[]
    OR?: PromotionScalarWhereWithAggregatesInput[]
    NOT?: PromotionScalarWhereWithAggregatesInput | PromotionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Promotion"> | string
    name?: StringWithAggregatesFilter<"Promotion"> | string
    description?: StringNullableWithAggregatesFilter<"Promotion"> | string | null
    type?: EnumPromoTypeWithAggregatesFilter<"Promotion"> | $Enums.PromoType
    value?: FloatNullableWithAggregatesFilter<"Promotion"> | number | null
    isActive?: BoolWithAggregatesFilter<"Promotion"> | boolean
    startDate?: DateTimeWithAggregatesFilter<"Promotion"> | Date | string
    endDate?: DateTimeWithAggregatesFilter<"Promotion"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"Promotion"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Promotion"> | Date | string
  }

  export type VoucherWhereInput = {
    AND?: VoucherWhereInput | VoucherWhereInput[]
    OR?: VoucherWhereInput[]
    NOT?: VoucherWhereInput | VoucherWhereInput[]
    id?: StringFilter<"Voucher"> | string
    code?: StringFilter<"Voucher"> | string
    description?: StringNullableFilter<"Voucher"> | string | null
    type?: EnumPromoTypeFilter<"Voucher"> | $Enums.PromoType
    value?: FloatFilter<"Voucher"> | number
    usageLimit?: IntNullableFilter<"Voucher"> | number | null
    usedCount?: IntFilter<"Voucher"> | number
    isActive?: BoolFilter<"Voucher"> | boolean
    startDate?: DateTimeFilter<"Voucher"> | Date | string
    endDate?: DateTimeFilter<"Voucher"> | Date | string
    createdAt?: DateTimeFilter<"Voucher"> | Date | string
    updatedAt?: DateTimeFilter<"Voucher"> | Date | string
    products?: ProductListRelationFilter
    usages?: VoucherUsageListRelationFilter
    orders?: OrderListRelationFilter
  }

  export type VoucherOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    description?: SortOrderInput | SortOrder
    type?: SortOrder
    value?: SortOrder
    usageLimit?: SortOrderInput | SortOrder
    usedCount?: SortOrder
    isActive?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    products?: ProductOrderByRelationAggregateInput
    usages?: VoucherUsageOrderByRelationAggregateInput
    orders?: OrderOrderByRelationAggregateInput
  }

  export type VoucherWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    code?: string
    AND?: VoucherWhereInput | VoucherWhereInput[]
    OR?: VoucherWhereInput[]
    NOT?: VoucherWhereInput | VoucherWhereInput[]
    description?: StringNullableFilter<"Voucher"> | string | null
    type?: EnumPromoTypeFilter<"Voucher"> | $Enums.PromoType
    value?: FloatFilter<"Voucher"> | number
    usageLimit?: IntNullableFilter<"Voucher"> | number | null
    usedCount?: IntFilter<"Voucher"> | number
    isActive?: BoolFilter<"Voucher"> | boolean
    startDate?: DateTimeFilter<"Voucher"> | Date | string
    endDate?: DateTimeFilter<"Voucher"> | Date | string
    createdAt?: DateTimeFilter<"Voucher"> | Date | string
    updatedAt?: DateTimeFilter<"Voucher"> | Date | string
    products?: ProductListRelationFilter
    usages?: VoucherUsageListRelationFilter
    orders?: OrderListRelationFilter
  }, "id" | "code">

  export type VoucherOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    description?: SortOrderInput | SortOrder
    type?: SortOrder
    value?: SortOrder
    usageLimit?: SortOrderInput | SortOrder
    usedCount?: SortOrder
    isActive?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: VoucherCountOrderByAggregateInput
    _avg?: VoucherAvgOrderByAggregateInput
    _max?: VoucherMaxOrderByAggregateInput
    _min?: VoucherMinOrderByAggregateInput
    _sum?: VoucherSumOrderByAggregateInput
  }

  export type VoucherScalarWhereWithAggregatesInput = {
    AND?: VoucherScalarWhereWithAggregatesInput | VoucherScalarWhereWithAggregatesInput[]
    OR?: VoucherScalarWhereWithAggregatesInput[]
    NOT?: VoucherScalarWhereWithAggregatesInput | VoucherScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Voucher"> | string
    code?: StringWithAggregatesFilter<"Voucher"> | string
    description?: StringNullableWithAggregatesFilter<"Voucher"> | string | null
    type?: EnumPromoTypeWithAggregatesFilter<"Voucher"> | $Enums.PromoType
    value?: FloatWithAggregatesFilter<"Voucher"> | number
    usageLimit?: IntNullableWithAggregatesFilter<"Voucher"> | number | null
    usedCount?: IntWithAggregatesFilter<"Voucher"> | number
    isActive?: BoolWithAggregatesFilter<"Voucher"> | boolean
    startDate?: DateTimeWithAggregatesFilter<"Voucher"> | Date | string
    endDate?: DateTimeWithAggregatesFilter<"Voucher"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"Voucher"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Voucher"> | Date | string
  }

  export type VoucherUsageWhereInput = {
    AND?: VoucherUsageWhereInput | VoucherUsageWhereInput[]
    OR?: VoucherUsageWhereInput[]
    NOT?: VoucherUsageWhereInput | VoucherUsageWhereInput[]
    id?: StringFilter<"VoucherUsage"> | string
    voucherId?: StringFilter<"VoucherUsage"> | string
    userId?: StringFilter<"VoucherUsage"> | string
    usedAt?: DateTimeFilter<"VoucherUsage"> | Date | string
    voucher?: XOR<VoucherScalarRelationFilter, VoucherWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type VoucherUsageOrderByWithRelationInput = {
    id?: SortOrder
    voucherId?: SortOrder
    userId?: SortOrder
    usedAt?: SortOrder
    voucher?: VoucherOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type VoucherUsageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    voucherId_userId?: VoucherUsageVoucherIdUserIdCompoundUniqueInput
    AND?: VoucherUsageWhereInput | VoucherUsageWhereInput[]
    OR?: VoucherUsageWhereInput[]
    NOT?: VoucherUsageWhereInput | VoucherUsageWhereInput[]
    voucherId?: StringFilter<"VoucherUsage"> | string
    userId?: StringFilter<"VoucherUsage"> | string
    usedAt?: DateTimeFilter<"VoucherUsage"> | Date | string
    voucher?: XOR<VoucherScalarRelationFilter, VoucherWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "voucherId_userId">

  export type VoucherUsageOrderByWithAggregationInput = {
    id?: SortOrder
    voucherId?: SortOrder
    userId?: SortOrder
    usedAt?: SortOrder
    _count?: VoucherUsageCountOrderByAggregateInput
    _max?: VoucherUsageMaxOrderByAggregateInput
    _min?: VoucherUsageMinOrderByAggregateInput
  }

  export type VoucherUsageScalarWhereWithAggregatesInput = {
    AND?: VoucherUsageScalarWhereWithAggregatesInput | VoucherUsageScalarWhereWithAggregatesInput[]
    OR?: VoucherUsageScalarWhereWithAggregatesInput[]
    NOT?: VoucherUsageScalarWhereWithAggregatesInput | VoucherUsageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"VoucherUsage"> | string
    voucherId?: StringWithAggregatesFilter<"VoucherUsage"> | string
    userId?: StringWithAggregatesFilter<"VoucherUsage"> | string
    usedAt?: DateTimeWithAggregatesFilter<"VoucherUsage"> | Date | string
  }

  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    firstName?: StringNullableFilter<"User"> | string | null
    lastName?: StringNullableFilter<"User"> | string | null
    name?: StringNullableFilter<"User"> | string | null
    userName?: StringNullableFilter<"User"> | string | null
    email?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    emailVerified?: DateTimeNullableFilter<"User"> | Date | string | null
    image?: StringNullableFilter<"User"> | string | null
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    orders?: OrderListRelationFilter
    accounts?: AccountListRelationFilter
    sessions?: SessionListRelationFilter
    vouchers?: VoucherUsageListRelationFilter
    Authenticator?: AuthenticatorListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    firstName?: SortOrderInput | SortOrder
    lastName?: SortOrderInput | SortOrder
    name?: SortOrderInput | SortOrder
    userName?: SortOrderInput | SortOrder
    email?: SortOrder
    password?: SortOrder
    emailVerified?: SortOrderInput | SortOrder
    image?: SortOrderInput | SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    orders?: OrderOrderByRelationAggregateInput
    accounts?: AccountOrderByRelationAggregateInput
    sessions?: SessionOrderByRelationAggregateInput
    vouchers?: VoucherUsageOrderByRelationAggregateInput
    Authenticator?: AuthenticatorOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    firstName?: StringNullableFilter<"User"> | string | null
    lastName?: StringNullableFilter<"User"> | string | null
    name?: StringNullableFilter<"User"> | string | null
    userName?: StringNullableFilter<"User"> | string | null
    password?: StringFilter<"User"> | string
    emailVerified?: DateTimeNullableFilter<"User"> | Date | string | null
    image?: StringNullableFilter<"User"> | string | null
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    orders?: OrderListRelationFilter
    accounts?: AccountListRelationFilter
    sessions?: SessionListRelationFilter
    vouchers?: VoucherUsageListRelationFilter
    Authenticator?: AuthenticatorListRelationFilter
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    firstName?: SortOrderInput | SortOrder
    lastName?: SortOrderInput | SortOrder
    name?: SortOrderInput | SortOrder
    userName?: SortOrderInput | SortOrder
    email?: SortOrder
    password?: SortOrder
    emailVerified?: SortOrderInput | SortOrder
    image?: SortOrderInput | SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    firstName?: StringNullableWithAggregatesFilter<"User"> | string | null
    lastName?: StringNullableWithAggregatesFilter<"User"> | string | null
    name?: StringNullableWithAggregatesFilter<"User"> | string | null
    userName?: StringNullableWithAggregatesFilter<"User"> | string | null
    email?: StringWithAggregatesFilter<"User"> | string
    password?: StringWithAggregatesFilter<"User"> | string
    emailVerified?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    image?: StringNullableWithAggregatesFilter<"User"> | string | null
    role?: EnumUserRoleWithAggregatesFilter<"User"> | $Enums.UserRole
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type AuthenticatorWhereInput = {
    AND?: AuthenticatorWhereInput | AuthenticatorWhereInput[]
    OR?: AuthenticatorWhereInput[]
    NOT?: AuthenticatorWhereInput | AuthenticatorWhereInput[]
    credentialID?: StringFilter<"Authenticator"> | string
    userId?: StringFilter<"Authenticator"> | string
    providerAccountId?: StringFilter<"Authenticator"> | string
    credentialPublicKey?: StringFilter<"Authenticator"> | string
    counter?: IntFilter<"Authenticator"> | number
    credentialDeviceType?: StringFilter<"Authenticator"> | string
    credentialBackedUp?: BoolFilter<"Authenticator"> | boolean
    transports?: StringNullableFilter<"Authenticator"> | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type AuthenticatorOrderByWithRelationInput = {
    credentialID?: SortOrder
    userId?: SortOrder
    providerAccountId?: SortOrder
    credentialPublicKey?: SortOrder
    counter?: SortOrder
    credentialDeviceType?: SortOrder
    credentialBackedUp?: SortOrder
    transports?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type AuthenticatorWhereUniqueInput = Prisma.AtLeast<{
    credentialID?: string
    userId_credentialID?: AuthenticatorUserIdCredentialIDCompoundUniqueInput
    AND?: AuthenticatorWhereInput | AuthenticatorWhereInput[]
    OR?: AuthenticatorWhereInput[]
    NOT?: AuthenticatorWhereInput | AuthenticatorWhereInput[]
    userId?: StringFilter<"Authenticator"> | string
    providerAccountId?: StringFilter<"Authenticator"> | string
    credentialPublicKey?: StringFilter<"Authenticator"> | string
    counter?: IntFilter<"Authenticator"> | number
    credentialDeviceType?: StringFilter<"Authenticator"> | string
    credentialBackedUp?: BoolFilter<"Authenticator"> | boolean
    transports?: StringNullableFilter<"Authenticator"> | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "userId_credentialID" | "credentialID">

  export type AuthenticatorOrderByWithAggregationInput = {
    credentialID?: SortOrder
    userId?: SortOrder
    providerAccountId?: SortOrder
    credentialPublicKey?: SortOrder
    counter?: SortOrder
    credentialDeviceType?: SortOrder
    credentialBackedUp?: SortOrder
    transports?: SortOrderInput | SortOrder
    _count?: AuthenticatorCountOrderByAggregateInput
    _avg?: AuthenticatorAvgOrderByAggregateInput
    _max?: AuthenticatorMaxOrderByAggregateInput
    _min?: AuthenticatorMinOrderByAggregateInput
    _sum?: AuthenticatorSumOrderByAggregateInput
  }

  export type AuthenticatorScalarWhereWithAggregatesInput = {
    AND?: AuthenticatorScalarWhereWithAggregatesInput | AuthenticatorScalarWhereWithAggregatesInput[]
    OR?: AuthenticatorScalarWhereWithAggregatesInput[]
    NOT?: AuthenticatorScalarWhereWithAggregatesInput | AuthenticatorScalarWhereWithAggregatesInput[]
    credentialID?: StringWithAggregatesFilter<"Authenticator"> | string
    userId?: StringWithAggregatesFilter<"Authenticator"> | string
    providerAccountId?: StringWithAggregatesFilter<"Authenticator"> | string
    credentialPublicKey?: StringWithAggregatesFilter<"Authenticator"> | string
    counter?: IntWithAggregatesFilter<"Authenticator"> | number
    credentialDeviceType?: StringWithAggregatesFilter<"Authenticator"> | string
    credentialBackedUp?: BoolWithAggregatesFilter<"Authenticator"> | boolean
    transports?: StringNullableWithAggregatesFilter<"Authenticator"> | string | null
  }

  export type OrderWhereInput = {
    AND?: OrderWhereInput | OrderWhereInput[]
    OR?: OrderWhereInput[]
    NOT?: OrderWhereInput | OrderWhereInput[]
    id?: StringFilter<"Order"> | string
    email?: StringFilter<"Order"> | string
    name?: StringNullableFilter<"Order"> | string | null
    userId?: StringNullableFilter<"Order"> | string | null
    voucherId?: StringNullableFilter<"Order"> | string | null
    totalPrice?: FloatFilter<"Order"> | number
    status?: EnumOrderStatusFilter<"Order"> | $Enums.OrderStatus
    createdAt?: DateTimeFilter<"Order"> | Date | string
    updatedAt?: DateTimeFilter<"Order"> | Date | string
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    products?: ProductListRelationFilter
    voucher?: XOR<VoucherNullableScalarRelationFilter, VoucherWhereInput> | null
  }

  export type OrderOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrderInput | SortOrder
    userId?: SortOrderInput | SortOrder
    voucherId?: SortOrderInput | SortOrder
    totalPrice?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    products?: ProductOrderByRelationAggregateInput
    voucher?: VoucherOrderByWithRelationInput
  }

  export type OrderWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: OrderWhereInput | OrderWhereInput[]
    OR?: OrderWhereInput[]
    NOT?: OrderWhereInput | OrderWhereInput[]
    email?: StringFilter<"Order"> | string
    name?: StringNullableFilter<"Order"> | string | null
    userId?: StringNullableFilter<"Order"> | string | null
    voucherId?: StringNullableFilter<"Order"> | string | null
    totalPrice?: FloatFilter<"Order"> | number
    status?: EnumOrderStatusFilter<"Order"> | $Enums.OrderStatus
    createdAt?: DateTimeFilter<"Order"> | Date | string
    updatedAt?: DateTimeFilter<"Order"> | Date | string
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    products?: ProductListRelationFilter
    voucher?: XOR<VoucherNullableScalarRelationFilter, VoucherWhereInput> | null
  }, "id">

  export type OrderOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrderInput | SortOrder
    userId?: SortOrderInput | SortOrder
    voucherId?: SortOrderInput | SortOrder
    totalPrice?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: OrderCountOrderByAggregateInput
    _avg?: OrderAvgOrderByAggregateInput
    _max?: OrderMaxOrderByAggregateInput
    _min?: OrderMinOrderByAggregateInput
    _sum?: OrderSumOrderByAggregateInput
  }

  export type OrderScalarWhereWithAggregatesInput = {
    AND?: OrderScalarWhereWithAggregatesInput | OrderScalarWhereWithAggregatesInput[]
    OR?: OrderScalarWhereWithAggregatesInput[]
    NOT?: OrderScalarWhereWithAggregatesInput | OrderScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Order"> | string
    email?: StringWithAggregatesFilter<"Order"> | string
    name?: StringNullableWithAggregatesFilter<"Order"> | string | null
    userId?: StringNullableWithAggregatesFilter<"Order"> | string | null
    voucherId?: StringNullableWithAggregatesFilter<"Order"> | string | null
    totalPrice?: FloatWithAggregatesFilter<"Order"> | number
    status?: EnumOrderStatusWithAggregatesFilter<"Order"> | $Enums.OrderStatus
    createdAt?: DateTimeWithAggregatesFilter<"Order"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Order"> | Date | string
  }

  export type MenuWhereInput = {
    AND?: MenuWhereInput | MenuWhereInput[]
    OR?: MenuWhereInput[]
    NOT?: MenuWhereInput | MenuWhereInput[]
    id?: StringFilter<"Menu"> | string
    title?: StringFilter<"Menu"> | string
    slug?: StringFilter<"Menu"> | string
    type?: EnumMenuTypeFilter<"Menu"> | $Enums.MenuType
    order?: IntFilter<"Menu"> | number
    icon?: StringNullableFilter<"Menu"> | string | null
    parentId?: StringNullableFilter<"Menu"> | string | null
    createdAt?: DateTimeFilter<"Menu"> | Date | string
    updatedAt?: DateTimeFilter<"Menu"> | Date | string
    parent?: XOR<MenuNullableScalarRelationFilter, MenuWhereInput> | null
    children?: MenuListRelationFilter
  }

  export type MenuOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    type?: SortOrder
    order?: SortOrder
    icon?: SortOrderInput | SortOrder
    parentId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    parent?: MenuOrderByWithRelationInput
    children?: MenuOrderByRelationAggregateInput
  }

  export type MenuWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MenuWhereInput | MenuWhereInput[]
    OR?: MenuWhereInput[]
    NOT?: MenuWhereInput | MenuWhereInput[]
    title?: StringFilter<"Menu"> | string
    slug?: StringFilter<"Menu"> | string
    type?: EnumMenuTypeFilter<"Menu"> | $Enums.MenuType
    order?: IntFilter<"Menu"> | number
    icon?: StringNullableFilter<"Menu"> | string | null
    parentId?: StringNullableFilter<"Menu"> | string | null
    createdAt?: DateTimeFilter<"Menu"> | Date | string
    updatedAt?: DateTimeFilter<"Menu"> | Date | string
    parent?: XOR<MenuNullableScalarRelationFilter, MenuWhereInput> | null
    children?: MenuListRelationFilter
  }, "id">

  export type MenuOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    type?: SortOrder
    order?: SortOrder
    icon?: SortOrderInput | SortOrder
    parentId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: MenuCountOrderByAggregateInput
    _avg?: MenuAvgOrderByAggregateInput
    _max?: MenuMaxOrderByAggregateInput
    _min?: MenuMinOrderByAggregateInput
    _sum?: MenuSumOrderByAggregateInput
  }

  export type MenuScalarWhereWithAggregatesInput = {
    AND?: MenuScalarWhereWithAggregatesInput | MenuScalarWhereWithAggregatesInput[]
    OR?: MenuScalarWhereWithAggregatesInput[]
    NOT?: MenuScalarWhereWithAggregatesInput | MenuScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Menu"> | string
    title?: StringWithAggregatesFilter<"Menu"> | string
    slug?: StringWithAggregatesFilter<"Menu"> | string
    type?: EnumMenuTypeWithAggregatesFilter<"Menu"> | $Enums.MenuType
    order?: IntWithAggregatesFilter<"Menu"> | number
    icon?: StringNullableWithAggregatesFilter<"Menu"> | string | null
    parentId?: StringNullableWithAggregatesFilter<"Menu"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Menu"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Menu"> | Date | string
  }

  export type FooterInfoWhereInput = {
    AND?: FooterInfoWhereInput | FooterInfoWhereInput[]
    OR?: FooterInfoWhereInput[]
    NOT?: FooterInfoWhereInput | FooterInfoWhereInput[]
    id?: StringFilter<"FooterInfo"> | string
    label?: StringFilter<"FooterInfo"> | string
    value?: StringFilter<"FooterInfo"> | string
    type?: EnumFooterInfoTypeFilter<"FooterInfo"> | $Enums.FooterInfoType
    icon?: StringNullableFilter<"FooterInfo"> | string | null
    order?: IntFilter<"FooterInfo"> | number
  }

  export type FooterInfoOrderByWithRelationInput = {
    id?: SortOrder
    label?: SortOrder
    value?: SortOrder
    type?: SortOrder
    icon?: SortOrderInput | SortOrder
    order?: SortOrder
  }

  export type FooterInfoWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: FooterInfoWhereInput | FooterInfoWhereInput[]
    OR?: FooterInfoWhereInput[]
    NOT?: FooterInfoWhereInput | FooterInfoWhereInput[]
    label?: StringFilter<"FooterInfo"> | string
    value?: StringFilter<"FooterInfo"> | string
    type?: EnumFooterInfoTypeFilter<"FooterInfo"> | $Enums.FooterInfoType
    icon?: StringNullableFilter<"FooterInfo"> | string | null
    order?: IntFilter<"FooterInfo"> | number
  }, "id">

  export type FooterInfoOrderByWithAggregationInput = {
    id?: SortOrder
    label?: SortOrder
    value?: SortOrder
    type?: SortOrder
    icon?: SortOrderInput | SortOrder
    order?: SortOrder
    _count?: FooterInfoCountOrderByAggregateInput
    _avg?: FooterInfoAvgOrderByAggregateInput
    _max?: FooterInfoMaxOrderByAggregateInput
    _min?: FooterInfoMinOrderByAggregateInput
    _sum?: FooterInfoSumOrderByAggregateInput
  }

  export type FooterInfoScalarWhereWithAggregatesInput = {
    AND?: FooterInfoScalarWhereWithAggregatesInput | FooterInfoScalarWhereWithAggregatesInput[]
    OR?: FooterInfoScalarWhereWithAggregatesInput[]
    NOT?: FooterInfoScalarWhereWithAggregatesInput | FooterInfoScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"FooterInfo"> | string
    label?: StringWithAggregatesFilter<"FooterInfo"> | string
    value?: StringWithAggregatesFilter<"FooterInfo"> | string
    type?: EnumFooterInfoTypeWithAggregatesFilter<"FooterInfo"> | $Enums.FooterInfoType
    icon?: StringNullableWithAggregatesFilter<"FooterInfo"> | string | null
    order?: IntWithAggregatesFilter<"FooterInfo"> | number
  }

  export type AccountWhereInput = {
    AND?: AccountWhereInput | AccountWhereInput[]
    OR?: AccountWhereInput[]
    NOT?: AccountWhereInput | AccountWhereInput[]
    id?: StringFilter<"Account"> | string
    userId?: StringFilter<"Account"> | string
    type?: StringFilter<"Account"> | string
    provider?: StringFilter<"Account"> | string
    providerAccountId?: StringFilter<"Account"> | string
    refresh_token?: StringNullableFilter<"Account"> | string | null
    access_token?: StringNullableFilter<"Account"> | string | null
    expires_at?: IntNullableFilter<"Account"> | number | null
    token_type?: StringNullableFilter<"Account"> | string | null
    scope?: StringNullableFilter<"Account"> | string | null
    id_token?: StringNullableFilter<"Account"> | string | null
    session_state?: StringNullableFilter<"Account"> | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type AccountOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrderInput | SortOrder
    access_token?: SortOrderInput | SortOrder
    expires_at?: SortOrderInput | SortOrder
    token_type?: SortOrderInput | SortOrder
    scope?: SortOrderInput | SortOrder
    id_token?: SortOrderInput | SortOrder
    session_state?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type AccountWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    provider_providerAccountId?: AccountProviderProviderAccountIdCompoundUniqueInput
    AND?: AccountWhereInput | AccountWhereInput[]
    OR?: AccountWhereInput[]
    NOT?: AccountWhereInput | AccountWhereInput[]
    userId?: StringFilter<"Account"> | string
    type?: StringFilter<"Account"> | string
    provider?: StringFilter<"Account"> | string
    providerAccountId?: StringFilter<"Account"> | string
    refresh_token?: StringNullableFilter<"Account"> | string | null
    access_token?: StringNullableFilter<"Account"> | string | null
    expires_at?: IntNullableFilter<"Account"> | number | null
    token_type?: StringNullableFilter<"Account"> | string | null
    scope?: StringNullableFilter<"Account"> | string | null
    id_token?: StringNullableFilter<"Account"> | string | null
    session_state?: StringNullableFilter<"Account"> | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "provider_providerAccountId">

  export type AccountOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrderInput | SortOrder
    access_token?: SortOrderInput | SortOrder
    expires_at?: SortOrderInput | SortOrder
    token_type?: SortOrderInput | SortOrder
    scope?: SortOrderInput | SortOrder
    id_token?: SortOrderInput | SortOrder
    session_state?: SortOrderInput | SortOrder
    _count?: AccountCountOrderByAggregateInput
    _avg?: AccountAvgOrderByAggregateInput
    _max?: AccountMaxOrderByAggregateInput
    _min?: AccountMinOrderByAggregateInput
    _sum?: AccountSumOrderByAggregateInput
  }

  export type AccountScalarWhereWithAggregatesInput = {
    AND?: AccountScalarWhereWithAggregatesInput | AccountScalarWhereWithAggregatesInput[]
    OR?: AccountScalarWhereWithAggregatesInput[]
    NOT?: AccountScalarWhereWithAggregatesInput | AccountScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Account"> | string
    userId?: StringWithAggregatesFilter<"Account"> | string
    type?: StringWithAggregatesFilter<"Account"> | string
    provider?: StringWithAggregatesFilter<"Account"> | string
    providerAccountId?: StringWithAggregatesFilter<"Account"> | string
    refresh_token?: StringNullableWithAggregatesFilter<"Account"> | string | null
    access_token?: StringNullableWithAggregatesFilter<"Account"> | string | null
    expires_at?: IntNullableWithAggregatesFilter<"Account"> | number | null
    token_type?: StringNullableWithAggregatesFilter<"Account"> | string | null
    scope?: StringNullableWithAggregatesFilter<"Account"> | string | null
    id_token?: StringNullableWithAggregatesFilter<"Account"> | string | null
    session_state?: StringNullableWithAggregatesFilter<"Account"> | string | null
  }

  export type SessionWhereInput = {
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    id?: StringFilter<"Session"> | string
    sessionToken?: StringFilter<"Session"> | string
    userId?: StringFilter<"Session"> | string
    expires?: DateTimeFilter<"Session"> | Date | string
    createdAt?: DateTimeFilter<"Session"> | Date | string
    updatedAt?: DateTimeFilter<"Session"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type SessionOrderByWithRelationInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type SessionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    sessionToken?: string
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    userId?: StringFilter<"Session"> | string
    expires?: DateTimeFilter<"Session"> | Date | string
    createdAt?: DateTimeFilter<"Session"> | Date | string
    updatedAt?: DateTimeFilter<"Session"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "sessionToken">

  export type SessionOrderByWithAggregationInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SessionCountOrderByAggregateInput
    _max?: SessionMaxOrderByAggregateInput
    _min?: SessionMinOrderByAggregateInput
  }

  export type SessionScalarWhereWithAggregatesInput = {
    AND?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    OR?: SessionScalarWhereWithAggregatesInput[]
    NOT?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Session"> | string
    sessionToken?: StringWithAggregatesFilter<"Session"> | string
    userId?: StringWithAggregatesFilter<"Session"> | string
    expires?: DateTimeWithAggregatesFilter<"Session"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"Session"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Session"> | Date | string
  }

  export type VerificationTokenWhereInput = {
    AND?: VerificationTokenWhereInput | VerificationTokenWhereInput[]
    OR?: VerificationTokenWhereInput[]
    NOT?: VerificationTokenWhereInput | VerificationTokenWhereInput[]
    identifier?: StringFilter<"VerificationToken"> | string
    token?: StringFilter<"VerificationToken"> | string
    expires?: DateTimeFilter<"VerificationToken"> | Date | string
  }

  export type VerificationTokenOrderByWithRelationInput = {
    identifier?: SortOrder
    token?: SortOrder
    expires?: SortOrder
  }

  export type VerificationTokenWhereUniqueInput = Prisma.AtLeast<{
    token?: string
    identifier_token?: VerificationTokenIdentifierTokenCompoundUniqueInput
    AND?: VerificationTokenWhereInput | VerificationTokenWhereInput[]
    OR?: VerificationTokenWhereInput[]
    NOT?: VerificationTokenWhereInput | VerificationTokenWhereInput[]
    identifier?: StringFilter<"VerificationToken"> | string
    expires?: DateTimeFilter<"VerificationToken"> | Date | string
  }, "token" | "identifier_token">

  export type VerificationTokenOrderByWithAggregationInput = {
    identifier?: SortOrder
    token?: SortOrder
    expires?: SortOrder
    _count?: VerificationTokenCountOrderByAggregateInput
    _max?: VerificationTokenMaxOrderByAggregateInput
    _min?: VerificationTokenMinOrderByAggregateInput
  }

  export type VerificationTokenScalarWhereWithAggregatesInput = {
    AND?: VerificationTokenScalarWhereWithAggregatesInput | VerificationTokenScalarWhereWithAggregatesInput[]
    OR?: VerificationTokenScalarWhereWithAggregatesInput[]
    NOT?: VerificationTokenScalarWhereWithAggregatesInput | VerificationTokenScalarWhereWithAggregatesInput[]
    identifier?: StringWithAggregatesFilter<"VerificationToken"> | string
    token?: StringWithAggregatesFilter<"VerificationToken"> | string
    expires?: DateTimeWithAggregatesFilter<"VerificationToken"> | Date | string
  }

  export type LandingPageWhereInput = {
    AND?: LandingPageWhereInput | LandingPageWhereInput[]
    OR?: LandingPageWhereInput[]
    NOT?: LandingPageWhereInput | LandingPageWhereInput[]
    id?: StringFilter<"LandingPage"> | string
    name?: StringFilter<"LandingPage"> | string
    slug?: StringFilter<"LandingPage"> | string
    description?: StringFilter<"LandingPage"> | string
    image?: StringFilter<"LandingPage"> | string
    lpDesignStyleId?: StringNullableFilter<"LandingPage"> | string | null
    marketingTools?: StringNullableFilter<"LandingPage"> | string | null
    isActive?: BoolFilter<"LandingPage"> | boolean
    createdAt?: DateTimeFilter<"LandingPage"> | Date | string
    updatedAt?: DateTimeFilter<"LandingPage"> | Date | string
    lpFor?: LpForListRelationFilter
    lpContentTypes?: LpContentTypeListRelationFilter
    lpDesignStyle?: XOR<LpDesignStyleNullableScalarRelationFilter, LpDesignStyleWhereInput> | null
  }

  export type LandingPageOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    image?: SortOrder
    lpDesignStyleId?: SortOrderInput | SortOrder
    marketingTools?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lpFor?: LpForOrderByRelationAggregateInput
    lpContentTypes?: LpContentTypeOrderByRelationAggregateInput
    lpDesignStyle?: LpDesignStyleOrderByWithRelationInput
  }

  export type LandingPageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    slug?: string
    AND?: LandingPageWhereInput | LandingPageWhereInput[]
    OR?: LandingPageWhereInput[]
    NOT?: LandingPageWhereInput | LandingPageWhereInput[]
    name?: StringFilter<"LandingPage"> | string
    description?: StringFilter<"LandingPage"> | string
    image?: StringFilter<"LandingPage"> | string
    lpDesignStyleId?: StringNullableFilter<"LandingPage"> | string | null
    marketingTools?: StringNullableFilter<"LandingPage"> | string | null
    isActive?: BoolFilter<"LandingPage"> | boolean
    createdAt?: DateTimeFilter<"LandingPage"> | Date | string
    updatedAt?: DateTimeFilter<"LandingPage"> | Date | string
    lpFor?: LpForListRelationFilter
    lpContentTypes?: LpContentTypeListRelationFilter
    lpDesignStyle?: XOR<LpDesignStyleNullableScalarRelationFilter, LpDesignStyleWhereInput> | null
  }, "id" | "slug">

  export type LandingPageOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    image?: SortOrder
    lpDesignStyleId?: SortOrderInput | SortOrder
    marketingTools?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: LandingPageCountOrderByAggregateInput
    _max?: LandingPageMaxOrderByAggregateInput
    _min?: LandingPageMinOrderByAggregateInput
  }

  export type LandingPageScalarWhereWithAggregatesInput = {
    AND?: LandingPageScalarWhereWithAggregatesInput | LandingPageScalarWhereWithAggregatesInput[]
    OR?: LandingPageScalarWhereWithAggregatesInput[]
    NOT?: LandingPageScalarWhereWithAggregatesInput | LandingPageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"LandingPage"> | string
    name?: StringWithAggregatesFilter<"LandingPage"> | string
    slug?: StringWithAggregatesFilter<"LandingPage"> | string
    description?: StringWithAggregatesFilter<"LandingPage"> | string
    image?: StringWithAggregatesFilter<"LandingPage"> | string
    lpDesignStyleId?: StringNullableWithAggregatesFilter<"LandingPage"> | string | null
    marketingTools?: StringNullableWithAggregatesFilter<"LandingPage"> | string | null
    isActive?: BoolWithAggregatesFilter<"LandingPage"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"LandingPage"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"LandingPage"> | Date | string
  }

  export type LpForWhereInput = {
    AND?: LpForWhereInput | LpForWhereInput[]
    OR?: LpForWhereInput[]
    NOT?: LpForWhereInput | LpForWhereInput[]
    id?: StringFilter<"LpFor"> | string
    description?: StringNullableFilter<"LpFor"> | string | null
    landingPages?: LandingPageListRelationFilter
  }

  export type LpForOrderByWithRelationInput = {
    id?: SortOrder
    description?: SortOrderInput | SortOrder
    landingPages?: LandingPageOrderByRelationAggregateInput
  }

  export type LpForWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: LpForWhereInput | LpForWhereInput[]
    OR?: LpForWhereInput[]
    NOT?: LpForWhereInput | LpForWhereInput[]
    description?: StringNullableFilter<"LpFor"> | string | null
    landingPages?: LandingPageListRelationFilter
  }, "id">

  export type LpForOrderByWithAggregationInput = {
    id?: SortOrder
    description?: SortOrderInput | SortOrder
    _count?: LpForCountOrderByAggregateInput
    _max?: LpForMaxOrderByAggregateInput
    _min?: LpForMinOrderByAggregateInput
  }

  export type LpForScalarWhereWithAggregatesInput = {
    AND?: LpForScalarWhereWithAggregatesInput | LpForScalarWhereWithAggregatesInput[]
    OR?: LpForScalarWhereWithAggregatesInput[]
    NOT?: LpForScalarWhereWithAggregatesInput | LpForScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"LpFor"> | string
    description?: StringNullableWithAggregatesFilter<"LpFor"> | string | null
  }

  export type LpContentTypeWhereInput = {
    AND?: LpContentTypeWhereInput | LpContentTypeWhereInput[]
    OR?: LpContentTypeWhereInput[]
    NOT?: LpContentTypeWhereInput | LpContentTypeWhereInput[]
    id?: StringFilter<"LpContentType"> | string
    type?: StringFilter<"LpContentType"> | string
    landingPages?: LandingPageListRelationFilter
  }

  export type LpContentTypeOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrder
    landingPages?: LandingPageOrderByRelationAggregateInput
  }

  export type LpContentTypeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: LpContentTypeWhereInput | LpContentTypeWhereInput[]
    OR?: LpContentTypeWhereInput[]
    NOT?: LpContentTypeWhereInput | LpContentTypeWhereInput[]
    type?: StringFilter<"LpContentType"> | string
    landingPages?: LandingPageListRelationFilter
  }, "id">

  export type LpContentTypeOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrder
    _count?: LpContentTypeCountOrderByAggregateInput
    _max?: LpContentTypeMaxOrderByAggregateInput
    _min?: LpContentTypeMinOrderByAggregateInput
  }

  export type LpContentTypeScalarWhereWithAggregatesInput = {
    AND?: LpContentTypeScalarWhereWithAggregatesInput | LpContentTypeScalarWhereWithAggregatesInput[]
    OR?: LpContentTypeScalarWhereWithAggregatesInput[]
    NOT?: LpContentTypeScalarWhereWithAggregatesInput | LpContentTypeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"LpContentType"> | string
    type?: StringWithAggregatesFilter<"LpContentType"> | string
  }

  export type LpDesignStyleWhereInput = {
    AND?: LpDesignStyleWhereInput | LpDesignStyleWhereInput[]
    OR?: LpDesignStyleWhereInput[]
    NOT?: LpDesignStyleWhereInput | LpDesignStyleWhereInput[]
    id?: StringFilter<"LpDesignStyle"> | string
    name?: StringFilter<"LpDesignStyle"> | string
    description?: StringFilter<"LpDesignStyle"> | string
    templates?: LandingPageListRelationFilter
  }

  export type LpDesignStyleOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    templates?: LandingPageOrderByRelationAggregateInput
  }

  export type LpDesignStyleWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: LpDesignStyleWhereInput | LpDesignStyleWhereInput[]
    OR?: LpDesignStyleWhereInput[]
    NOT?: LpDesignStyleWhereInput | LpDesignStyleWhereInput[]
    description?: StringFilter<"LpDesignStyle"> | string
    templates?: LandingPageListRelationFilter
  }, "id" | "name">

  export type LpDesignStyleOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    _count?: LpDesignStyleCountOrderByAggregateInput
    _max?: LpDesignStyleMaxOrderByAggregateInput
    _min?: LpDesignStyleMinOrderByAggregateInput
  }

  export type LpDesignStyleScalarWhereWithAggregatesInput = {
    AND?: LpDesignStyleScalarWhereWithAggregatesInput | LpDesignStyleScalarWhereWithAggregatesInput[]
    OR?: LpDesignStyleScalarWhereWithAggregatesInput[]
    NOT?: LpDesignStyleScalarWhereWithAggregatesInput | LpDesignStyleScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"LpDesignStyle"> | string
    name?: StringWithAggregatesFilter<"LpDesignStyle"> | string
    description?: StringWithAggregatesFilter<"LpDesignStyle"> | string
  }

  export type RegisterFormCreateInput = {
    name: string
    type: string
    placeholder: string
    position?: number
    row?: number
    options?: string | null
    required?: boolean
    hint?: string | null
    hintTrue?: string
    hintFalse?: string
    isActive?: boolean
    createDate?: Date | string
    updateDate?: Date | string
  }

  export type RegisterFormUncheckedCreateInput = {
    id?: number
    name: string
    type: string
    placeholder: string
    position?: number
    row?: number
    options?: string | null
    required?: boolean
    hint?: string | null
    hintTrue?: string
    hintFalse?: string
    isActive?: boolean
    createDate?: Date | string
    updateDate?: Date | string
  }

  export type RegisterFormUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    placeholder?: StringFieldUpdateOperationsInput | string
    position?: IntFieldUpdateOperationsInput | number
    row?: IntFieldUpdateOperationsInput | number
    options?: NullableStringFieldUpdateOperationsInput | string | null
    required?: BoolFieldUpdateOperationsInput | boolean
    hint?: NullableStringFieldUpdateOperationsInput | string | null
    hintTrue?: StringFieldUpdateOperationsInput | string
    hintFalse?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createDate?: DateTimeFieldUpdateOperationsInput | Date | string
    updateDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RegisterFormUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    placeholder?: StringFieldUpdateOperationsInput | string
    position?: IntFieldUpdateOperationsInput | number
    row?: IntFieldUpdateOperationsInput | number
    options?: NullableStringFieldUpdateOperationsInput | string | null
    required?: BoolFieldUpdateOperationsInput | boolean
    hint?: NullableStringFieldUpdateOperationsInput | string | null
    hintTrue?: StringFieldUpdateOperationsInput | string
    hintFalse?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createDate?: DateTimeFieldUpdateOperationsInput | Date | string
    updateDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RegisterFormCreateManyInput = {
    id?: number
    name: string
    type: string
    placeholder: string
    position?: number
    row?: number
    options?: string | null
    required?: boolean
    hint?: string | null
    hintTrue?: string
    hintFalse?: string
    isActive?: boolean
    createDate?: Date | string
    updateDate?: Date | string
  }

  export type RegisterFormUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    placeholder?: StringFieldUpdateOperationsInput | string
    position?: IntFieldUpdateOperationsInput | number
    row?: IntFieldUpdateOperationsInput | number
    options?: NullableStringFieldUpdateOperationsInput | string | null
    required?: BoolFieldUpdateOperationsInput | boolean
    hint?: NullableStringFieldUpdateOperationsInput | string | null
    hintTrue?: StringFieldUpdateOperationsInput | string
    hintFalse?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createDate?: DateTimeFieldUpdateOperationsInput | Date | string
    updateDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RegisterFormUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    placeholder?: StringFieldUpdateOperationsInput | string
    position?: IntFieldUpdateOperationsInput | number
    row?: IntFieldUpdateOperationsInput | number
    options?: NullableStringFieldUpdateOperationsInput | string | null
    required?: BoolFieldUpdateOperationsInput | boolean
    hint?: NullableStringFieldUpdateOperationsInput | string | null
    hintTrue?: StringFieldUpdateOperationsInput | string
    hintFalse?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createDate?: DateTimeFieldUpdateOperationsInput | Date | string
    updateDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApiListCreateInput = {
    name: string
    createDate?: Date | string
    updateDate?: Date | string
  }

  export type ApiListUncheckedCreateInput = {
    id?: number
    name: string
    createDate?: Date | string
    updateDate?: Date | string
  }

  export type ApiListUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    createDate?: DateTimeFieldUpdateOperationsInput | Date | string
    updateDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApiListUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createDate?: DateTimeFieldUpdateOperationsInput | Date | string
    updateDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApiListCreateManyInput = {
    id?: number
    name: string
    createDate?: Date | string
    updateDate?: Date | string
  }

  export type ApiListUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    createDate?: DateTimeFieldUpdateOperationsInput | Date | string
    updateDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApiListUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createDate?: DateTimeFieldUpdateOperationsInput | Date | string
    updateDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FacebookPixelCreateInput = {
    pixelId: string
    campaignName: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FacebookPixelUncheckedCreateInput = {
    id?: number
    pixelId: string
    campaignName: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FacebookPixelUpdateInput = {
    pixelId?: StringFieldUpdateOperationsInput | string
    campaignName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FacebookPixelUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    pixelId?: StringFieldUpdateOperationsInput | string
    campaignName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FacebookPixelCreateManyInput = {
    id?: number
    pixelId: string
    campaignName: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FacebookPixelUpdateManyMutationInput = {
    pixelId?: StringFieldUpdateOperationsInput | string
    campaignName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FacebookPixelUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    pixelId?: StringFieldUpdateOperationsInput | string
    campaignName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SiteIdentityCreateInput = {
    id?: string
    siteName: string
    tagline?: string | null
    description?: string | null
    keywords?: NullableJsonNullValueInput | InputJsonValue
    logoUrl?: string
    ogImage?: string | null
    faviconUrl?: string
    email?: string | null
    phone?: string | null
    address?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    socialLinks?: SocialLinksCreateNestedManyWithoutIdentityInput
  }

  export type SiteIdentityUncheckedCreateInput = {
    id?: string
    siteName: string
    tagline?: string | null
    description?: string | null
    keywords?: NullableJsonNullValueInput | InputJsonValue
    logoUrl?: string
    ogImage?: string | null
    faviconUrl?: string
    email?: string | null
    phone?: string | null
    address?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    socialLinks?: SocialLinksUncheckedCreateNestedManyWithoutIdentityInput
  }

  export type SiteIdentityUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    siteName?: StringFieldUpdateOperationsInput | string
    tagline?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    keywords?: NullableJsonNullValueInput | InputJsonValue
    logoUrl?: StringFieldUpdateOperationsInput | string
    ogImage?: NullableStringFieldUpdateOperationsInput | string | null
    faviconUrl?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    socialLinks?: SocialLinksUpdateManyWithoutIdentityNestedInput
  }

  export type SiteIdentityUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    siteName?: StringFieldUpdateOperationsInput | string
    tagline?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    keywords?: NullableJsonNullValueInput | InputJsonValue
    logoUrl?: StringFieldUpdateOperationsInput | string
    ogImage?: NullableStringFieldUpdateOperationsInput | string | null
    faviconUrl?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    socialLinks?: SocialLinksUncheckedUpdateManyWithoutIdentityNestedInput
  }

  export type SiteIdentityCreateManyInput = {
    id?: string
    siteName: string
    tagline?: string | null
    description?: string | null
    keywords?: NullableJsonNullValueInput | InputJsonValue
    logoUrl?: string
    ogImage?: string | null
    faviconUrl?: string
    email?: string | null
    phone?: string | null
    address?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SiteIdentityUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    siteName?: StringFieldUpdateOperationsInput | string
    tagline?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    keywords?: NullableJsonNullValueInput | InputJsonValue
    logoUrl?: StringFieldUpdateOperationsInput | string
    ogImage?: NullableStringFieldUpdateOperationsInput | string | null
    faviconUrl?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SiteIdentityUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    siteName?: StringFieldUpdateOperationsInput | string
    tagline?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    keywords?: NullableJsonNullValueInput | InputJsonValue
    logoUrl?: StringFieldUpdateOperationsInput | string
    ogImage?: NullableStringFieldUpdateOperationsInput | string | null
    faviconUrl?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SocialLinksCreateInput = {
    id?: string
    platform?: string | null
    url?: string | null
    platformUsername?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    identity?: SiteIdentityCreateNestedOneWithoutSocialLinksInput
  }

  export type SocialLinksUncheckedCreateInput = {
    id?: string
    platform?: string | null
    url?: string | null
    platformUsername?: string | null
    identityId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SocialLinksUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    platform?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    platformUsername?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    identity?: SiteIdentityUpdateOneWithoutSocialLinksNestedInput
  }

  export type SocialLinksUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    platform?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    platformUsername?: NullableStringFieldUpdateOperationsInput | string | null
    identityId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SocialLinksCreateManyInput = {
    id?: string
    platform?: string | null
    url?: string | null
    platformUsername?: string | null
    identityId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SocialLinksUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    platform?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    platformUsername?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SocialLinksUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    platform?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    platformUsername?: NullableStringFieldUpdateOperationsInput | string | null
    identityId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PageCreateInput = {
    id?: string
    slug: string
    name: string
    title: string
    description?: string | null
    keywords?: NullableJsonNullValueInput | InputJsonValue
    ogTitle?: string | null
    ogDescription?: string | null
    ogImage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sections?: SectionCreateNestedManyWithoutPageInput
  }

  export type PageUncheckedCreateInput = {
    id?: string
    slug: string
    name: string
    title: string
    description?: string | null
    keywords?: NullableJsonNullValueInput | InputJsonValue
    ogTitle?: string | null
    ogDescription?: string | null
    ogImage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sections?: SectionUncheckedCreateNestedManyWithoutPageInput
  }

  export type PageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    keywords?: NullableJsonNullValueInput | InputJsonValue
    ogTitle?: NullableStringFieldUpdateOperationsInput | string | null
    ogDescription?: NullableStringFieldUpdateOperationsInput | string | null
    ogImage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sections?: SectionUpdateManyWithoutPageNestedInput
  }

  export type PageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    keywords?: NullableJsonNullValueInput | InputJsonValue
    ogTitle?: NullableStringFieldUpdateOperationsInput | string | null
    ogDescription?: NullableStringFieldUpdateOperationsInput | string | null
    ogImage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sections?: SectionUncheckedUpdateManyWithoutPageNestedInput
  }

  export type PageCreateManyInput = {
    id?: string
    slug: string
    name: string
    title: string
    description?: string | null
    keywords?: NullableJsonNullValueInput | InputJsonValue
    ogTitle?: string | null
    ogDescription?: string | null
    ogImage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    keywords?: NullableJsonNullValueInput | InputJsonValue
    ogTitle?: NullableStringFieldUpdateOperationsInput | string | null
    ogDescription?: NullableStringFieldUpdateOperationsInput | string | null
    ogImage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    keywords?: NullableJsonNullValueInput | InputJsonValue
    ogTitle?: NullableStringFieldUpdateOperationsInput | string | null
    ogDescription?: NullableStringFieldUpdateOperationsInput | string | null
    ogImage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SectionCreateInput = {
    id?: string
    name?: string | null
    type: $Enums.SectionType
    title: string
    subTitle?: string | null
    description?: string | null
    additionalText?: string | null
    image?: string | null
    video?: string | null
    icon?: string | null
    order: number
    page: PageCreateNestedOneWithoutSectionsInput
    listItems?: ListItemCreateNestedManyWithoutSectionInput
  }

  export type SectionUncheckedCreateInput = {
    id?: string
    name?: string | null
    pageId: string
    type: $Enums.SectionType
    title: string
    subTitle?: string | null
    description?: string | null
    additionalText?: string | null
    image?: string | null
    video?: string | null
    icon?: string | null
    order: number
    listItems?: ListItemUncheckedCreateNestedManyWithoutSectionInput
  }

  export type SectionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumSectionTypeFieldUpdateOperationsInput | $Enums.SectionType
    title?: StringFieldUpdateOperationsInput | string
    subTitle?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    additionalText?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    video?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    page?: PageUpdateOneRequiredWithoutSectionsNestedInput
    listItems?: ListItemUpdateManyWithoutSectionNestedInput
  }

  export type SectionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    pageId?: StringFieldUpdateOperationsInput | string
    type?: EnumSectionTypeFieldUpdateOperationsInput | $Enums.SectionType
    title?: StringFieldUpdateOperationsInput | string
    subTitle?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    additionalText?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    video?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    listItems?: ListItemUncheckedUpdateManyWithoutSectionNestedInput
  }

  export type SectionCreateManyInput = {
    id?: string
    name?: string | null
    pageId: string
    type: $Enums.SectionType
    title: string
    subTitle?: string | null
    description?: string | null
    additionalText?: string | null
    image?: string | null
    video?: string | null
    icon?: string | null
    order: number
  }

  export type SectionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumSectionTypeFieldUpdateOperationsInput | $Enums.SectionType
    title?: StringFieldUpdateOperationsInput | string
    subTitle?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    additionalText?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    video?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
  }

  export type SectionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    pageId?: StringFieldUpdateOperationsInput | string
    type?: EnumSectionTypeFieldUpdateOperationsInput | $Enums.SectionType
    title?: StringFieldUpdateOperationsInput | string
    subTitle?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    additionalText?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    video?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
  }

  export type ListItemCreateInput = {
    id?: string
    type: $Enums.ListItemType
    title: string
    description?: string | null
    section: SectionCreateNestedOneWithoutListItemsInput
    entries?: ListEntryCreateNestedManyWithoutListItemInput
  }

  export type ListItemUncheckedCreateInput = {
    id?: string
    sectionId: string
    type: $Enums.ListItemType
    title: string
    description?: string | null
    entries?: ListEntryUncheckedCreateNestedManyWithoutListItemInput
  }

  export type ListItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumListItemTypeFieldUpdateOperationsInput | $Enums.ListItemType
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    section?: SectionUpdateOneRequiredWithoutListItemsNestedInput
    entries?: ListEntryUpdateManyWithoutListItemNestedInput
  }

  export type ListItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sectionId?: StringFieldUpdateOperationsInput | string
    type?: EnumListItemTypeFieldUpdateOperationsInput | $Enums.ListItemType
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    entries?: ListEntryUncheckedUpdateManyWithoutListItemNestedInput
  }

  export type ListItemCreateManyInput = {
    id?: string
    sectionId: string
    type: $Enums.ListItemType
    title: string
    description?: string | null
  }

  export type ListItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumListItemTypeFieldUpdateOperationsInput | $Enums.ListItemType
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ListItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    sectionId?: StringFieldUpdateOperationsInput | string
    type?: EnumListItemTypeFieldUpdateOperationsInput | $Enums.ListItemType
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ListEntryCreateInput = {
    id?: string
    title: string
    price?: number | null
    description?: string | null
    icon?: string | null
    image?: string | null
    listItem: ListItemCreateNestedOneWithoutEntriesInput
  }

  export type ListEntryUncheckedCreateInput = {
    id?: string
    listItemId: string
    title: string
    price?: number | null
    description?: string | null
    icon?: string | null
    image?: string | null
  }

  export type ListEntryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    price?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    listItem?: ListItemUpdateOneRequiredWithoutEntriesNestedInput
  }

  export type ListEntryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    listItemId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    price?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ListEntryCreateManyInput = {
    id?: string
    listItemId: string
    title: string
    price?: number | null
    description?: string | null
    icon?: string | null
    image?: string | null
  }

  export type ListEntryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    price?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ListEntryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    listItemId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    price?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProductCreateInput = {
    id?: string
    sku: string
    name: string
    slug: string
    description?: string | null
    bestFor?: string | null
    image?: string | null
    price: number
    proccessTime?: number | null
    inStock?: boolean
    status?: $Enums.ProductStatus
    keywords?: NullableJsonNullValueInput | InputJsonValue
    quality: number
    isBest?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    category: CategoryCreateNestedOneWithoutProductsInput
    tags?: TagCreateNestedManyWithoutProductsInput
    gallery?: ProductGalleryCreateNestedManyWithoutProductInput
    benefits?: ProductBenefitCreateNestedManyWithoutProductInput
    benefitPoints?: ProductBenefitPointCreateNestedManyWithoutProductInput
    promotions?: PromotionCreateNestedManyWithoutProductsInput
    vouchers?: VoucherCreateNestedManyWithoutProductsInput
    orders?: OrderCreateNestedManyWithoutProductsInput
  }

  export type ProductUncheckedCreateInput = {
    id?: string
    sku: string
    name: string
    slug: string
    description?: string | null
    bestFor?: string | null
    image?: string | null
    price: number
    proccessTime?: number | null
    inStock?: boolean
    status?: $Enums.ProductStatus
    categoryId: string
    keywords?: NullableJsonNullValueInput | InputJsonValue
    quality: number
    isBest?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    tags?: TagUncheckedCreateNestedManyWithoutProductsInput
    gallery?: ProductGalleryUncheckedCreateNestedManyWithoutProductInput
    benefits?: ProductBenefitUncheckedCreateNestedManyWithoutProductInput
    benefitPoints?: ProductBenefitPointUncheckedCreateNestedManyWithoutProductInput
    promotions?: PromotionUncheckedCreateNestedManyWithoutProductsInput
    vouchers?: VoucherUncheckedCreateNestedManyWithoutProductsInput
    orders?: OrderUncheckedCreateNestedManyWithoutProductsInput
  }

  export type ProductUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    bestFor?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    proccessTime?: NullableIntFieldUpdateOperationsInput | number | null
    inStock?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumProductStatusFieldUpdateOperationsInput | $Enums.ProductStatus
    keywords?: NullableJsonNullValueInput | InputJsonValue
    quality?: IntFieldUpdateOperationsInput | number
    isBest?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: CategoryUpdateOneRequiredWithoutProductsNestedInput
    tags?: TagUpdateManyWithoutProductsNestedInput
    gallery?: ProductGalleryUpdateManyWithoutProductNestedInput
    benefits?: ProductBenefitUpdateManyWithoutProductNestedInput
    benefitPoints?: ProductBenefitPointUpdateManyWithoutProductNestedInput
    promotions?: PromotionUpdateManyWithoutProductsNestedInput
    vouchers?: VoucherUpdateManyWithoutProductsNestedInput
    orders?: OrderUpdateManyWithoutProductsNestedInput
  }

  export type ProductUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    bestFor?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    proccessTime?: NullableIntFieldUpdateOperationsInput | number | null
    inStock?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumProductStatusFieldUpdateOperationsInput | $Enums.ProductStatus
    categoryId?: StringFieldUpdateOperationsInput | string
    keywords?: NullableJsonNullValueInput | InputJsonValue
    quality?: IntFieldUpdateOperationsInput | number
    isBest?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tags?: TagUncheckedUpdateManyWithoutProductsNestedInput
    gallery?: ProductGalleryUncheckedUpdateManyWithoutProductNestedInput
    benefits?: ProductBenefitUncheckedUpdateManyWithoutProductNestedInput
    benefitPoints?: ProductBenefitPointUncheckedUpdateManyWithoutProductNestedInput
    promotions?: PromotionUncheckedUpdateManyWithoutProductsNestedInput
    vouchers?: VoucherUncheckedUpdateManyWithoutProductsNestedInput
    orders?: OrderUncheckedUpdateManyWithoutProductsNestedInput
  }

  export type ProductCreateManyInput = {
    id?: string
    sku: string
    name: string
    slug: string
    description?: string | null
    bestFor?: string | null
    image?: string | null
    price: number
    proccessTime?: number | null
    inStock?: boolean
    status?: $Enums.ProductStatus
    categoryId: string
    keywords?: NullableJsonNullValueInput | InputJsonValue
    quality: number
    isBest?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    bestFor?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    proccessTime?: NullableIntFieldUpdateOperationsInput | number | null
    inStock?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumProductStatusFieldUpdateOperationsInput | $Enums.ProductStatus
    keywords?: NullableJsonNullValueInput | InputJsonValue
    quality?: IntFieldUpdateOperationsInput | number
    isBest?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    bestFor?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    proccessTime?: NullableIntFieldUpdateOperationsInput | number | null
    inStock?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumProductStatusFieldUpdateOperationsInput | $Enums.ProductStatus
    categoryId?: StringFieldUpdateOperationsInput | string
    keywords?: NullableJsonNullValueInput | InputJsonValue
    quality?: IntFieldUpdateOperationsInput | number
    isBest?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CategoryCreateInput = {
    id?: string
    name: string
    slug: string
    createdAt?: Date | string
    updatedAt?: Date | string
    products?: ProductCreateNestedManyWithoutCategoryInput
  }

  export type CategoryUncheckedCreateInput = {
    id?: string
    name: string
    slug: string
    createdAt?: Date | string
    updatedAt?: Date | string
    products?: ProductUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type CategoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    products?: ProductUpdateManyWithoutCategoryNestedInput
  }

  export type CategoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    products?: ProductUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type CategoryCreateManyInput = {
    id?: string
    name: string
    slug: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CategoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CategoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TagCreateInput = {
    id?: string
    name: string
    slug: string
    products?: ProductCreateNestedManyWithoutTagsInput
  }

  export type TagUncheckedCreateInput = {
    id?: string
    name: string
    slug: string
    products?: ProductUncheckedCreateNestedManyWithoutTagsInput
  }

  export type TagUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    products?: ProductUpdateManyWithoutTagsNestedInput
  }

  export type TagUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    products?: ProductUncheckedUpdateManyWithoutTagsNestedInput
  }

  export type TagCreateManyInput = {
    id?: string
    name: string
    slug: string
  }

  export type TagUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
  }

  export type TagUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
  }

  export type ProductGalleryCreateInput = {
    id?: string
    imageUrl: string
    order: number
    createdAt?: Date | string
    product: ProductCreateNestedOneWithoutGalleryInput
  }

  export type ProductGalleryUncheckedCreateInput = {
    id?: string
    productId: string
    imageUrl: string
    order: number
    createdAt?: Date | string
  }

  export type ProductGalleryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUpdateOneRequiredWithoutGalleryNestedInput
  }

  export type ProductGalleryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductGalleryCreateManyInput = {
    id?: string
    productId: string
    imageUrl: string
    order: number
    createdAt?: Date | string
  }

  export type ProductGalleryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductGalleryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BenefitCreateInput = {
    id?: string
    title: string
    description?: string | null
    icon?: string | null
    products?: ProductBenefitCreateNestedManyWithoutBenefitInput
  }

  export type BenefitUncheckedCreateInput = {
    id?: string
    title: string
    description?: string | null
    icon?: string | null
    products?: ProductBenefitUncheckedCreateNestedManyWithoutBenefitInput
  }

  export type BenefitUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    products?: ProductBenefitUpdateManyWithoutBenefitNestedInput
  }

  export type BenefitUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    products?: ProductBenefitUncheckedUpdateManyWithoutBenefitNestedInput
  }

  export type BenefitCreateManyInput = {
    id?: string
    title: string
    description?: string | null
    icon?: string | null
  }

  export type BenefitUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BenefitUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProductBenefitCreateInput = {
    id?: string
    isActive?: boolean
    order?: number
    product: ProductCreateNestedOneWithoutBenefitsInput
    benefit: BenefitCreateNestedOneWithoutProductsInput
  }

  export type ProductBenefitUncheckedCreateInput = {
    id?: string
    productId: string
    benefitId: string
    isActive?: boolean
    order?: number
  }

  export type ProductBenefitUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
    product?: ProductUpdateOneRequiredWithoutBenefitsNestedInput
    benefit?: BenefitUpdateOneRequiredWithoutProductsNestedInput
  }

  export type ProductBenefitUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    benefitId?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
  }

  export type ProductBenefitCreateManyInput = {
    id?: string
    productId: string
    benefitId: string
    isActive?: boolean
    order?: number
  }

  export type ProductBenefitUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
  }

  export type ProductBenefitUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    benefitId?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
  }

  export type ProductBenefitPointCreateInput = {
    id?: string
    text: string
    order: number
    icon?: string | null
    product: ProductCreateNestedOneWithoutBenefitPointsInput
  }

  export type ProductBenefitPointUncheckedCreateInput = {
    id?: string
    productId: string
    text: string
    order: number
    icon?: string | null
  }

  export type ProductBenefitPointUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    product?: ProductUpdateOneRequiredWithoutBenefitPointsNestedInput
  }

  export type ProductBenefitPointUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    icon?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProductBenefitPointCreateManyInput = {
    id?: string
    productId: string
    text: string
    order: number
    icon?: string | null
  }

  export type ProductBenefitPointUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    icon?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProductBenefitPointUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    icon?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PromotionCreateInput = {
    id?: string
    name: string
    description?: string | null
    type: $Enums.PromoType
    value?: number | null
    isActive?: boolean
    startDate: Date | string
    endDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    products?: ProductCreateNestedManyWithoutPromotionsInput
  }

  export type PromotionUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    type: $Enums.PromoType
    value?: number | null
    isActive?: boolean
    startDate: Date | string
    endDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    products?: ProductUncheckedCreateNestedManyWithoutPromotionsInput
  }

  export type PromotionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumPromoTypeFieldUpdateOperationsInput | $Enums.PromoType
    value?: NullableFloatFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    products?: ProductUpdateManyWithoutPromotionsNestedInput
  }

  export type PromotionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumPromoTypeFieldUpdateOperationsInput | $Enums.PromoType
    value?: NullableFloatFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    products?: ProductUncheckedUpdateManyWithoutPromotionsNestedInput
  }

  export type PromotionCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    type: $Enums.PromoType
    value?: number | null
    isActive?: boolean
    startDate: Date | string
    endDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PromotionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumPromoTypeFieldUpdateOperationsInput | $Enums.PromoType
    value?: NullableFloatFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PromotionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumPromoTypeFieldUpdateOperationsInput | $Enums.PromoType
    value?: NullableFloatFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VoucherCreateInput = {
    id?: string
    code: string
    description?: string | null
    type: $Enums.PromoType
    value: number
    usageLimit?: number | null
    usedCount?: number
    isActive?: boolean
    startDate: Date | string
    endDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    products?: ProductCreateNestedManyWithoutVouchersInput
    usages?: VoucherUsageCreateNestedManyWithoutVoucherInput
    orders?: OrderCreateNestedManyWithoutVoucherInput
  }

  export type VoucherUncheckedCreateInput = {
    id?: string
    code: string
    description?: string | null
    type: $Enums.PromoType
    value: number
    usageLimit?: number | null
    usedCount?: number
    isActive?: boolean
    startDate: Date | string
    endDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    products?: ProductUncheckedCreateNestedManyWithoutVouchersInput
    usages?: VoucherUsageUncheckedCreateNestedManyWithoutVoucherInput
    orders?: OrderUncheckedCreateNestedManyWithoutVoucherInput
  }

  export type VoucherUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumPromoTypeFieldUpdateOperationsInput | $Enums.PromoType
    value?: FloatFieldUpdateOperationsInput | number
    usageLimit?: NullableIntFieldUpdateOperationsInput | number | null
    usedCount?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    products?: ProductUpdateManyWithoutVouchersNestedInput
    usages?: VoucherUsageUpdateManyWithoutVoucherNestedInput
    orders?: OrderUpdateManyWithoutVoucherNestedInput
  }

  export type VoucherUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumPromoTypeFieldUpdateOperationsInput | $Enums.PromoType
    value?: FloatFieldUpdateOperationsInput | number
    usageLimit?: NullableIntFieldUpdateOperationsInput | number | null
    usedCount?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    products?: ProductUncheckedUpdateManyWithoutVouchersNestedInput
    usages?: VoucherUsageUncheckedUpdateManyWithoutVoucherNestedInput
    orders?: OrderUncheckedUpdateManyWithoutVoucherNestedInput
  }

  export type VoucherCreateManyInput = {
    id?: string
    code: string
    description?: string | null
    type: $Enums.PromoType
    value: number
    usageLimit?: number | null
    usedCount?: number
    isActive?: boolean
    startDate: Date | string
    endDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VoucherUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumPromoTypeFieldUpdateOperationsInput | $Enums.PromoType
    value?: FloatFieldUpdateOperationsInput | number
    usageLimit?: NullableIntFieldUpdateOperationsInput | number | null
    usedCount?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VoucherUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumPromoTypeFieldUpdateOperationsInput | $Enums.PromoType
    value?: FloatFieldUpdateOperationsInput | number
    usageLimit?: NullableIntFieldUpdateOperationsInput | number | null
    usedCount?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VoucherUsageCreateInput = {
    id?: string
    usedAt?: Date | string
    voucher: VoucherCreateNestedOneWithoutUsagesInput
    user: UserCreateNestedOneWithoutVouchersInput
  }

  export type VoucherUsageUncheckedCreateInput = {
    id?: string
    voucherId: string
    userId: string
    usedAt?: Date | string
  }

  export type VoucherUsageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    usedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    voucher?: VoucherUpdateOneRequiredWithoutUsagesNestedInput
    user?: UserUpdateOneRequiredWithoutVouchersNestedInput
  }

  export type VoucherUsageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    voucherId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    usedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VoucherUsageCreateManyInput = {
    id?: string
    voucherId: string
    userId: string
    usedAt?: Date | string
  }

  export type VoucherUsageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    usedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VoucherUsageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    voucherId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    usedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateInput = {
    id?: string
    firstName?: string | null
    lastName?: string | null
    name?: string | null
    userName?: string | null
    email: string
    password?: string
    emailVerified?: Date | string | null
    image?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    orders?: OrderCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    vouchers?: VoucherUsageCreateNestedManyWithoutUserInput
    Authenticator?: AuthenticatorCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    firstName?: string | null
    lastName?: string | null
    name?: string | null
    userName?: string | null
    email: string
    password?: string
    emailVerified?: Date | string | null
    image?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    vouchers?: VoucherUsageUncheckedCreateNestedManyWithoutUserInput
    Authenticator?: AuthenticatorUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    userName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orders?: OrderUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    vouchers?: VoucherUsageUpdateManyWithoutUserNestedInput
    Authenticator?: AuthenticatorUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    userName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    vouchers?: VoucherUsageUncheckedUpdateManyWithoutUserNestedInput
    Authenticator?: AuthenticatorUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    firstName?: string | null
    lastName?: string | null
    name?: string | null
    userName?: string | null
    email: string
    password?: string
    emailVerified?: Date | string | null
    image?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    userName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    userName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuthenticatorCreateInput = {
    credentialID: string
    providerAccountId: string
    credentialPublicKey: string
    counter: number
    credentialDeviceType: string
    credentialBackedUp: boolean
    transports?: string | null
    user: UserCreateNestedOneWithoutAuthenticatorInput
  }

  export type AuthenticatorUncheckedCreateInput = {
    credentialID: string
    userId: string
    providerAccountId: string
    credentialPublicKey: string
    counter: number
    credentialDeviceType: string
    credentialBackedUp: boolean
    transports?: string | null
  }

  export type AuthenticatorUpdateInput = {
    credentialID?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    credentialPublicKey?: StringFieldUpdateOperationsInput | string
    counter?: IntFieldUpdateOperationsInput | number
    credentialDeviceType?: StringFieldUpdateOperationsInput | string
    credentialBackedUp?: BoolFieldUpdateOperationsInput | boolean
    transports?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutAuthenticatorNestedInput
  }

  export type AuthenticatorUncheckedUpdateInput = {
    credentialID?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    credentialPublicKey?: StringFieldUpdateOperationsInput | string
    counter?: IntFieldUpdateOperationsInput | number
    credentialDeviceType?: StringFieldUpdateOperationsInput | string
    credentialBackedUp?: BoolFieldUpdateOperationsInput | boolean
    transports?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AuthenticatorCreateManyInput = {
    credentialID: string
    userId: string
    providerAccountId: string
    credentialPublicKey: string
    counter: number
    credentialDeviceType: string
    credentialBackedUp: boolean
    transports?: string | null
  }

  export type AuthenticatorUpdateManyMutationInput = {
    credentialID?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    credentialPublicKey?: StringFieldUpdateOperationsInput | string
    counter?: IntFieldUpdateOperationsInput | number
    credentialDeviceType?: StringFieldUpdateOperationsInput | string
    credentialBackedUp?: BoolFieldUpdateOperationsInput | boolean
    transports?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AuthenticatorUncheckedUpdateManyInput = {
    credentialID?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    credentialPublicKey?: StringFieldUpdateOperationsInput | string
    counter?: IntFieldUpdateOperationsInput | number
    credentialDeviceType?: StringFieldUpdateOperationsInput | string
    credentialBackedUp?: BoolFieldUpdateOperationsInput | boolean
    transports?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OrderCreateInput = {
    id?: string
    email: string
    name?: string | null
    totalPrice: number
    status?: $Enums.OrderStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutOrdersInput
    products?: ProductCreateNestedManyWithoutOrdersInput
    voucher?: VoucherCreateNestedOneWithoutOrdersInput
  }

  export type OrderUncheckedCreateInput = {
    id?: string
    email: string
    name?: string | null
    userId?: string | null
    voucherId?: string | null
    totalPrice: number
    status?: $Enums.OrderStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    products?: ProductUncheckedCreateNestedManyWithoutOrdersInput
  }

  export type OrderUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    totalPrice?: FloatFieldUpdateOperationsInput | number
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutOrdersNestedInput
    products?: ProductUpdateManyWithoutOrdersNestedInput
    voucher?: VoucherUpdateOneWithoutOrdersNestedInput
  }

  export type OrderUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    voucherId?: NullableStringFieldUpdateOperationsInput | string | null
    totalPrice?: FloatFieldUpdateOperationsInput | number
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    products?: ProductUncheckedUpdateManyWithoutOrdersNestedInput
  }

  export type OrderCreateManyInput = {
    id?: string
    email: string
    name?: string | null
    userId?: string | null
    voucherId?: string | null
    totalPrice: number
    status?: $Enums.OrderStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrderUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    totalPrice?: FloatFieldUpdateOperationsInput | number
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    voucherId?: NullableStringFieldUpdateOperationsInput | string | null
    totalPrice?: FloatFieldUpdateOperationsInput | number
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MenuCreateInput = {
    id?: string
    title: string
    slug: string
    type: $Enums.MenuType
    order: number
    icon?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    parent?: MenuCreateNestedOneWithoutChildrenInput
    children?: MenuCreateNestedManyWithoutParentInput
  }

  export type MenuUncheckedCreateInput = {
    id?: string
    title: string
    slug: string
    type: $Enums.MenuType
    order: number
    icon?: string | null
    parentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    children?: MenuUncheckedCreateNestedManyWithoutParentInput
  }

  export type MenuUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    type?: EnumMenuTypeFieldUpdateOperationsInput | $Enums.MenuType
    order?: IntFieldUpdateOperationsInput | number
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parent?: MenuUpdateOneWithoutChildrenNestedInput
    children?: MenuUpdateManyWithoutParentNestedInput
  }

  export type MenuUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    type?: EnumMenuTypeFieldUpdateOperationsInput | $Enums.MenuType
    order?: IntFieldUpdateOperationsInput | number
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: MenuUncheckedUpdateManyWithoutParentNestedInput
  }

  export type MenuCreateManyInput = {
    id?: string
    title: string
    slug: string
    type: $Enums.MenuType
    order: number
    icon?: string | null
    parentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MenuUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    type?: EnumMenuTypeFieldUpdateOperationsInput | $Enums.MenuType
    order?: IntFieldUpdateOperationsInput | number
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MenuUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    type?: EnumMenuTypeFieldUpdateOperationsInput | $Enums.MenuType
    order?: IntFieldUpdateOperationsInput | number
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FooterInfoCreateInput = {
    id?: string
    label: string
    value: string
    type: $Enums.FooterInfoType
    icon?: string | null
    order: number
  }

  export type FooterInfoUncheckedCreateInput = {
    id?: string
    label: string
    value: string
    type: $Enums.FooterInfoType
    icon?: string | null
    order: number
  }

  export type FooterInfoUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    type?: EnumFooterInfoTypeFieldUpdateOperationsInput | $Enums.FooterInfoType
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
  }

  export type FooterInfoUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    type?: EnumFooterInfoTypeFieldUpdateOperationsInput | $Enums.FooterInfoType
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
  }

  export type FooterInfoCreateManyInput = {
    id?: string
    label: string
    value: string
    type: $Enums.FooterInfoType
    icon?: string | null
    order: number
  }

  export type FooterInfoUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    type?: EnumFooterInfoTypeFieldUpdateOperationsInput | $Enums.FooterInfoType
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
  }

  export type FooterInfoUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    type?: EnumFooterInfoTypeFieldUpdateOperationsInput | $Enums.FooterInfoType
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
  }

  export type AccountCreateInput = {
    id?: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
    user: UserCreateNestedOneWithoutAccountsInput
  }

  export type AccountUncheckedCreateInput = {
    id?: string
    userId: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
  }

  export type AccountUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutAccountsNestedInput
  }

  export type AccountUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountCreateManyInput = {
    id?: string
    userId: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
  }

  export type AccountUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SessionCreateInput = {
    id?: string
    sessionToken: string
    expires: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutSessionsInput
  }

  export type SessionUncheckedCreateInput = {
    id?: string
    sessionToken: string
    userId: string
    expires: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SessionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSessionsNestedInput
  }

  export type SessionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionCreateManyInput = {
    id?: string
    sessionToken: string
    userId: string
    expires: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SessionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationTokenCreateInput = {
    identifier: string
    token: string
    expires: Date | string
  }

  export type VerificationTokenUncheckedCreateInput = {
    identifier: string
    token: string
    expires: Date | string
  }

  export type VerificationTokenUpdateInput = {
    identifier?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationTokenUncheckedUpdateInput = {
    identifier?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationTokenCreateManyInput = {
    identifier: string
    token: string
    expires: Date | string
  }

  export type VerificationTokenUpdateManyMutationInput = {
    identifier?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationTokenUncheckedUpdateManyInput = {
    identifier?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LandingPageCreateInput = {
    id?: string
    name: string
    slug: string
    description: string
    image: string
    marketingTools?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lpFor?: LpForCreateNestedManyWithoutLandingPagesInput
    lpContentTypes?: LpContentTypeCreateNestedManyWithoutLandingPagesInput
    lpDesignStyle?: LpDesignStyleCreateNestedOneWithoutTemplatesInput
  }

  export type LandingPageUncheckedCreateInput = {
    id?: string
    name: string
    slug: string
    description: string
    image: string
    lpDesignStyleId?: string | null
    marketingTools?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lpFor?: LpForUncheckedCreateNestedManyWithoutLandingPagesInput
    lpContentTypes?: LpContentTypeUncheckedCreateNestedManyWithoutLandingPagesInput
  }

  export type LandingPageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    marketingTools?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lpFor?: LpForUpdateManyWithoutLandingPagesNestedInput
    lpContentTypes?: LpContentTypeUpdateManyWithoutLandingPagesNestedInput
    lpDesignStyle?: LpDesignStyleUpdateOneWithoutTemplatesNestedInput
  }

  export type LandingPageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    lpDesignStyleId?: NullableStringFieldUpdateOperationsInput | string | null
    marketingTools?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lpFor?: LpForUncheckedUpdateManyWithoutLandingPagesNestedInput
    lpContentTypes?: LpContentTypeUncheckedUpdateManyWithoutLandingPagesNestedInput
  }

  export type LandingPageCreateManyInput = {
    id?: string
    name: string
    slug: string
    description: string
    image: string
    lpDesignStyleId?: string | null
    marketingTools?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LandingPageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    marketingTools?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LandingPageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    lpDesignStyleId?: NullableStringFieldUpdateOperationsInput | string | null
    marketingTools?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LpForCreateInput = {
    id?: string
    description?: string | null
    landingPages?: LandingPageCreateNestedManyWithoutLpForInput
  }

  export type LpForUncheckedCreateInput = {
    id?: string
    description?: string | null
    landingPages?: LandingPageUncheckedCreateNestedManyWithoutLpForInput
  }

  export type LpForUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    landingPages?: LandingPageUpdateManyWithoutLpForNestedInput
  }

  export type LpForUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    landingPages?: LandingPageUncheckedUpdateManyWithoutLpForNestedInput
  }

  export type LpForCreateManyInput = {
    id?: string
    description?: string | null
  }

  export type LpForUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type LpForUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type LpContentTypeCreateInput = {
    id?: string
    type: string
    landingPages?: LandingPageCreateNestedManyWithoutLpContentTypesInput
  }

  export type LpContentTypeUncheckedCreateInput = {
    id?: string
    type: string
    landingPages?: LandingPageUncheckedCreateNestedManyWithoutLpContentTypesInput
  }

  export type LpContentTypeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    landingPages?: LandingPageUpdateManyWithoutLpContentTypesNestedInput
  }

  export type LpContentTypeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    landingPages?: LandingPageUncheckedUpdateManyWithoutLpContentTypesNestedInput
  }

  export type LpContentTypeCreateManyInput = {
    id?: string
    type: string
  }

  export type LpContentTypeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
  }

  export type LpContentTypeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
  }

  export type LpDesignStyleCreateInput = {
    id?: string
    name: string
    description: string
    templates?: LandingPageCreateNestedManyWithoutLpDesignStyleInput
  }

  export type LpDesignStyleUncheckedCreateInput = {
    id?: string
    name: string
    description: string
    templates?: LandingPageUncheckedCreateNestedManyWithoutLpDesignStyleInput
  }

  export type LpDesignStyleUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    templates?: LandingPageUpdateManyWithoutLpDesignStyleNestedInput
  }

  export type LpDesignStyleUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    templates?: LandingPageUncheckedUpdateManyWithoutLpDesignStyleNestedInput
  }

  export type LpDesignStyleCreateManyInput = {
    id?: string
    name: string
    description: string
  }

  export type LpDesignStyleUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
  }

  export type LpDesignStyleUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type RegisterFormCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    placeholder?: SortOrder
    position?: SortOrder
    row?: SortOrder
    options?: SortOrder
    required?: SortOrder
    hint?: SortOrder
    hintTrue?: SortOrder
    hintFalse?: SortOrder
    isActive?: SortOrder
    createDate?: SortOrder
    updateDate?: SortOrder
  }

  export type RegisterFormAvgOrderByAggregateInput = {
    id?: SortOrder
    position?: SortOrder
    row?: SortOrder
  }

  export type RegisterFormMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    placeholder?: SortOrder
    position?: SortOrder
    row?: SortOrder
    options?: SortOrder
    required?: SortOrder
    hint?: SortOrder
    hintTrue?: SortOrder
    hintFalse?: SortOrder
    isActive?: SortOrder
    createDate?: SortOrder
    updateDate?: SortOrder
  }

  export type RegisterFormMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    placeholder?: SortOrder
    position?: SortOrder
    row?: SortOrder
    options?: SortOrder
    required?: SortOrder
    hint?: SortOrder
    hintTrue?: SortOrder
    hintFalse?: SortOrder
    isActive?: SortOrder
    createDate?: SortOrder
    updateDate?: SortOrder
  }

  export type RegisterFormSumOrderByAggregateInput = {
    id?: SortOrder
    position?: SortOrder
    row?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type ApiListCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createDate?: SortOrder
    updateDate?: SortOrder
  }

  export type ApiListAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ApiListMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createDate?: SortOrder
    updateDate?: SortOrder
  }

  export type ApiListMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createDate?: SortOrder
    updateDate?: SortOrder
  }

  export type ApiListSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type FacebookPixelCountOrderByAggregateInput = {
    id?: SortOrder
    pixelId?: SortOrder
    campaignName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FacebookPixelAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type FacebookPixelMaxOrderByAggregateInput = {
    id?: SortOrder
    pixelId?: SortOrder
    campaignName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FacebookPixelMinOrderByAggregateInput = {
    id?: SortOrder
    pixelId?: SortOrder
    campaignName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FacebookPixelSumOrderByAggregateInput = {
    id?: SortOrder
  }
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type SocialLinksListRelationFilter = {
    every?: SocialLinksWhereInput
    some?: SocialLinksWhereInput
    none?: SocialLinksWhereInput
  }

  export type SocialLinksOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SiteIdentityCountOrderByAggregateInput = {
    id?: SortOrder
    siteName?: SortOrder
    tagline?: SortOrder
    description?: SortOrder
    keywords?: SortOrder
    logoUrl?: SortOrder
    ogImage?: SortOrder
    faviconUrl?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    address?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SiteIdentityMaxOrderByAggregateInput = {
    id?: SortOrder
    siteName?: SortOrder
    tagline?: SortOrder
    description?: SortOrder
    logoUrl?: SortOrder
    ogImage?: SortOrder
    faviconUrl?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    address?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SiteIdentityMinOrderByAggregateInput = {
    id?: SortOrder
    siteName?: SortOrder
    tagline?: SortOrder
    description?: SortOrder
    logoUrl?: SortOrder
    ogImage?: SortOrder
    faviconUrl?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    address?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type SiteIdentityNullableScalarRelationFilter = {
    is?: SiteIdentityWhereInput | null
    isNot?: SiteIdentityWhereInput | null
  }

  export type SocialLinksCountOrderByAggregateInput = {
    id?: SortOrder
    platform?: SortOrder
    url?: SortOrder
    platformUsername?: SortOrder
    identityId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SocialLinksMaxOrderByAggregateInput = {
    id?: SortOrder
    platform?: SortOrder
    url?: SortOrder
    platformUsername?: SortOrder
    identityId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SocialLinksMinOrderByAggregateInput = {
    id?: SortOrder
    platform?: SortOrder
    url?: SortOrder
    platformUsername?: SortOrder
    identityId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SectionListRelationFilter = {
    every?: SectionWhereInput
    some?: SectionWhereInput
    none?: SectionWhereInput
  }

  export type SectionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PageCountOrderByAggregateInput = {
    id?: SortOrder
    slug?: SortOrder
    name?: SortOrder
    title?: SortOrder
    description?: SortOrder
    keywords?: SortOrder
    ogTitle?: SortOrder
    ogDescription?: SortOrder
    ogImage?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PageMaxOrderByAggregateInput = {
    id?: SortOrder
    slug?: SortOrder
    name?: SortOrder
    title?: SortOrder
    description?: SortOrder
    ogTitle?: SortOrder
    ogDescription?: SortOrder
    ogImage?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PageMinOrderByAggregateInput = {
    id?: SortOrder
    slug?: SortOrder
    name?: SortOrder
    title?: SortOrder
    description?: SortOrder
    ogTitle?: SortOrder
    ogDescription?: SortOrder
    ogImage?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumSectionTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.SectionType | EnumSectionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SectionType[]
    notIn?: $Enums.SectionType[]
    not?: NestedEnumSectionTypeFilter<$PrismaModel> | $Enums.SectionType
  }

  export type PageScalarRelationFilter = {
    is?: PageWhereInput
    isNot?: PageWhereInput
  }

  export type ListItemListRelationFilter = {
    every?: ListItemWhereInput
    some?: ListItemWhereInput
    none?: ListItemWhereInput
  }

  export type ListItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SectionCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    pageId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    subTitle?: SortOrder
    description?: SortOrder
    additionalText?: SortOrder
    image?: SortOrder
    video?: SortOrder
    icon?: SortOrder
    order?: SortOrder
  }

  export type SectionAvgOrderByAggregateInput = {
    order?: SortOrder
  }

  export type SectionMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    pageId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    subTitle?: SortOrder
    description?: SortOrder
    additionalText?: SortOrder
    image?: SortOrder
    video?: SortOrder
    icon?: SortOrder
    order?: SortOrder
  }

  export type SectionMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    pageId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    subTitle?: SortOrder
    description?: SortOrder
    additionalText?: SortOrder
    image?: SortOrder
    video?: SortOrder
    icon?: SortOrder
    order?: SortOrder
  }

  export type SectionSumOrderByAggregateInput = {
    order?: SortOrder
  }

  export type EnumSectionTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SectionType | EnumSectionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SectionType[]
    notIn?: $Enums.SectionType[]
    not?: NestedEnumSectionTypeWithAggregatesFilter<$PrismaModel> | $Enums.SectionType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSectionTypeFilter<$PrismaModel>
    _max?: NestedEnumSectionTypeFilter<$PrismaModel>
  }

  export type EnumListItemTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ListItemType | EnumListItemTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ListItemType[]
    notIn?: $Enums.ListItemType[]
    not?: NestedEnumListItemTypeFilter<$PrismaModel> | $Enums.ListItemType
  }

  export type SectionScalarRelationFilter = {
    is?: SectionWhereInput
    isNot?: SectionWhereInput
  }

  export type ListEntryListRelationFilter = {
    every?: ListEntryWhereInput
    some?: ListEntryWhereInput
    none?: ListEntryWhereInput
  }

  export type ListEntryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ListItemCountOrderByAggregateInput = {
    id?: SortOrder
    sectionId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    description?: SortOrder
  }

  export type ListItemMaxOrderByAggregateInput = {
    id?: SortOrder
    sectionId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    description?: SortOrder
  }

  export type ListItemMinOrderByAggregateInput = {
    id?: SortOrder
    sectionId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    description?: SortOrder
  }

  export type EnumListItemTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ListItemType | EnumListItemTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ListItemType[]
    notIn?: $Enums.ListItemType[]
    not?: NestedEnumListItemTypeWithAggregatesFilter<$PrismaModel> | $Enums.ListItemType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumListItemTypeFilter<$PrismaModel>
    _max?: NestedEnumListItemTypeFilter<$PrismaModel>
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type ListItemScalarRelationFilter = {
    is?: ListItemWhereInput
    isNot?: ListItemWhereInput
  }

  export type ListEntryCountOrderByAggregateInput = {
    id?: SortOrder
    listItemId?: SortOrder
    title?: SortOrder
    price?: SortOrder
    description?: SortOrder
    icon?: SortOrder
    image?: SortOrder
  }

  export type ListEntryAvgOrderByAggregateInput = {
    price?: SortOrder
  }

  export type ListEntryMaxOrderByAggregateInput = {
    id?: SortOrder
    listItemId?: SortOrder
    title?: SortOrder
    price?: SortOrder
    description?: SortOrder
    icon?: SortOrder
    image?: SortOrder
  }

  export type ListEntryMinOrderByAggregateInput = {
    id?: SortOrder
    listItemId?: SortOrder
    title?: SortOrder
    price?: SortOrder
    description?: SortOrder
    icon?: SortOrder
    image?: SortOrder
  }

  export type ListEntrySumOrderByAggregateInput = {
    price?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type EnumProductStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ProductStatus | EnumProductStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ProductStatus[]
    notIn?: $Enums.ProductStatus[]
    not?: NestedEnumProductStatusFilter<$PrismaModel> | $Enums.ProductStatus
  }

  export type CategoryScalarRelationFilter = {
    is?: CategoryWhereInput
    isNot?: CategoryWhereInput
  }

  export type TagListRelationFilter = {
    every?: TagWhereInput
    some?: TagWhereInput
    none?: TagWhereInput
  }

  export type ProductGalleryListRelationFilter = {
    every?: ProductGalleryWhereInput
    some?: ProductGalleryWhereInput
    none?: ProductGalleryWhereInput
  }

  export type ProductBenefitListRelationFilter = {
    every?: ProductBenefitWhereInput
    some?: ProductBenefitWhereInput
    none?: ProductBenefitWhereInput
  }

  export type ProductBenefitPointListRelationFilter = {
    every?: ProductBenefitPointWhereInput
    some?: ProductBenefitPointWhereInput
    none?: ProductBenefitPointWhereInput
  }

  export type PromotionListRelationFilter = {
    every?: PromotionWhereInput
    some?: PromotionWhereInput
    none?: PromotionWhereInput
  }

  export type VoucherListRelationFilter = {
    every?: VoucherWhereInput
    some?: VoucherWhereInput
    none?: VoucherWhereInput
  }

  export type OrderListRelationFilter = {
    every?: OrderWhereInput
    some?: OrderWhereInput
    none?: OrderWhereInput
  }

  export type TagOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProductGalleryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProductBenefitOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProductBenefitPointOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PromotionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type VoucherOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OrderOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProductCountOrderByAggregateInput = {
    id?: SortOrder
    sku?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    bestFor?: SortOrder
    image?: SortOrder
    price?: SortOrder
    proccessTime?: SortOrder
    inStock?: SortOrder
    status?: SortOrder
    categoryId?: SortOrder
    keywords?: SortOrder
    quality?: SortOrder
    isBest?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductAvgOrderByAggregateInput = {
    price?: SortOrder
    proccessTime?: SortOrder
    quality?: SortOrder
  }

  export type ProductMaxOrderByAggregateInput = {
    id?: SortOrder
    sku?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    bestFor?: SortOrder
    image?: SortOrder
    price?: SortOrder
    proccessTime?: SortOrder
    inStock?: SortOrder
    status?: SortOrder
    categoryId?: SortOrder
    quality?: SortOrder
    isBest?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductMinOrderByAggregateInput = {
    id?: SortOrder
    sku?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    bestFor?: SortOrder
    image?: SortOrder
    price?: SortOrder
    proccessTime?: SortOrder
    inStock?: SortOrder
    status?: SortOrder
    categoryId?: SortOrder
    quality?: SortOrder
    isBest?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductSumOrderByAggregateInput = {
    price?: SortOrder
    proccessTime?: SortOrder
    quality?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type EnumProductStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ProductStatus | EnumProductStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ProductStatus[]
    notIn?: $Enums.ProductStatus[]
    not?: NestedEnumProductStatusWithAggregatesFilter<$PrismaModel> | $Enums.ProductStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumProductStatusFilter<$PrismaModel>
    _max?: NestedEnumProductStatusFilter<$PrismaModel>
  }

  export type ProductListRelationFilter = {
    every?: ProductWhereInput
    some?: ProductWhereInput
    none?: ProductWhereInput
  }

  export type ProductOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CategoryCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CategoryMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CategoryMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TagCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
  }

  export type TagMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
  }

  export type TagMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
  }

  export type ProductScalarRelationFilter = {
    is?: ProductWhereInput
    isNot?: ProductWhereInput
  }

  export type ProductGalleryCountOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    imageUrl?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
  }

  export type ProductGalleryAvgOrderByAggregateInput = {
    order?: SortOrder
  }

  export type ProductGalleryMaxOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    imageUrl?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
  }

  export type ProductGalleryMinOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    imageUrl?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
  }

  export type ProductGallerySumOrderByAggregateInput = {
    order?: SortOrder
  }

  export type BenefitCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    icon?: SortOrder
  }

  export type BenefitMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    icon?: SortOrder
  }

  export type BenefitMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    icon?: SortOrder
  }

  export type BenefitScalarRelationFilter = {
    is?: BenefitWhereInput
    isNot?: BenefitWhereInput
  }

  export type ProductBenefitCountOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    benefitId?: SortOrder
    isActive?: SortOrder
    order?: SortOrder
  }

  export type ProductBenefitAvgOrderByAggregateInput = {
    order?: SortOrder
  }

  export type ProductBenefitMaxOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    benefitId?: SortOrder
    isActive?: SortOrder
    order?: SortOrder
  }

  export type ProductBenefitMinOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    benefitId?: SortOrder
    isActive?: SortOrder
    order?: SortOrder
  }

  export type ProductBenefitSumOrderByAggregateInput = {
    order?: SortOrder
  }

  export type ProductBenefitPointCountOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    text?: SortOrder
    order?: SortOrder
    icon?: SortOrder
  }

  export type ProductBenefitPointAvgOrderByAggregateInput = {
    order?: SortOrder
  }

  export type ProductBenefitPointMaxOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    text?: SortOrder
    order?: SortOrder
    icon?: SortOrder
  }

  export type ProductBenefitPointMinOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    text?: SortOrder
    order?: SortOrder
    icon?: SortOrder
  }

  export type ProductBenefitPointSumOrderByAggregateInput = {
    order?: SortOrder
  }

  export type EnumPromoTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.PromoType | EnumPromoTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PromoType[]
    notIn?: $Enums.PromoType[]
    not?: NestedEnumPromoTypeFilter<$PrismaModel> | $Enums.PromoType
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type PromotionCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    type?: SortOrder
    value?: SortOrder
    isActive?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PromotionAvgOrderByAggregateInput = {
    value?: SortOrder
  }

  export type PromotionMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    type?: SortOrder
    value?: SortOrder
    isActive?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PromotionMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    type?: SortOrder
    value?: SortOrder
    isActive?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PromotionSumOrderByAggregateInput = {
    value?: SortOrder
  }

  export type EnumPromoTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PromoType | EnumPromoTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PromoType[]
    notIn?: $Enums.PromoType[]
    not?: NestedEnumPromoTypeWithAggregatesFilter<$PrismaModel> | $Enums.PromoType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPromoTypeFilter<$PrismaModel>
    _max?: NestedEnumPromoTypeFilter<$PrismaModel>
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type VoucherUsageListRelationFilter = {
    every?: VoucherUsageWhereInput
    some?: VoucherUsageWhereInput
    none?: VoucherUsageWhereInput
  }

  export type VoucherUsageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type VoucherCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    description?: SortOrder
    type?: SortOrder
    value?: SortOrder
    usageLimit?: SortOrder
    usedCount?: SortOrder
    isActive?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VoucherAvgOrderByAggregateInput = {
    value?: SortOrder
    usageLimit?: SortOrder
    usedCount?: SortOrder
  }

  export type VoucherMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    description?: SortOrder
    type?: SortOrder
    value?: SortOrder
    usageLimit?: SortOrder
    usedCount?: SortOrder
    isActive?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VoucherMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    description?: SortOrder
    type?: SortOrder
    value?: SortOrder
    usageLimit?: SortOrder
    usedCount?: SortOrder
    isActive?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VoucherSumOrderByAggregateInput = {
    value?: SortOrder
    usageLimit?: SortOrder
    usedCount?: SortOrder
  }

  export type VoucherScalarRelationFilter = {
    is?: VoucherWhereInput
    isNot?: VoucherWhereInput
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type VoucherUsageVoucherIdUserIdCompoundUniqueInput = {
    voucherId: string
    userId: string
  }

  export type VoucherUsageCountOrderByAggregateInput = {
    id?: SortOrder
    voucherId?: SortOrder
    userId?: SortOrder
    usedAt?: SortOrder
  }

  export type VoucherUsageMaxOrderByAggregateInput = {
    id?: SortOrder
    voucherId?: SortOrder
    userId?: SortOrder
    usedAt?: SortOrder
  }

  export type VoucherUsageMinOrderByAggregateInput = {
    id?: SortOrder
    voucherId?: SortOrder
    userId?: SortOrder
    usedAt?: SortOrder
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type EnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[]
    notIn?: $Enums.UserRole[]
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type AccountListRelationFilter = {
    every?: AccountWhereInput
    some?: AccountWhereInput
    none?: AccountWhereInput
  }

  export type SessionListRelationFilter = {
    every?: SessionWhereInput
    some?: SessionWhereInput
    none?: SessionWhereInput
  }

  export type AuthenticatorListRelationFilter = {
    every?: AuthenticatorWhereInput
    some?: AuthenticatorWhereInput
    none?: AuthenticatorWhereInput
  }

  export type AccountOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AuthenticatorOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    name?: SortOrder
    userName?: SortOrder
    email?: SortOrder
    password?: SortOrder
    emailVerified?: SortOrder
    image?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    name?: SortOrder
    userName?: SortOrder
    email?: SortOrder
    password?: SortOrder
    emailVerified?: SortOrder
    image?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    name?: SortOrder
    userName?: SortOrder
    email?: SortOrder
    password?: SortOrder
    emailVerified?: SortOrder
    image?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type EnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[]
    notIn?: $Enums.UserRole[]
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type AuthenticatorUserIdCredentialIDCompoundUniqueInput = {
    userId: string
    credentialID: string
  }

  export type AuthenticatorCountOrderByAggregateInput = {
    credentialID?: SortOrder
    userId?: SortOrder
    providerAccountId?: SortOrder
    credentialPublicKey?: SortOrder
    counter?: SortOrder
    credentialDeviceType?: SortOrder
    credentialBackedUp?: SortOrder
    transports?: SortOrder
  }

  export type AuthenticatorAvgOrderByAggregateInput = {
    counter?: SortOrder
  }

  export type AuthenticatorMaxOrderByAggregateInput = {
    credentialID?: SortOrder
    userId?: SortOrder
    providerAccountId?: SortOrder
    credentialPublicKey?: SortOrder
    counter?: SortOrder
    credentialDeviceType?: SortOrder
    credentialBackedUp?: SortOrder
    transports?: SortOrder
  }

  export type AuthenticatorMinOrderByAggregateInput = {
    credentialID?: SortOrder
    userId?: SortOrder
    providerAccountId?: SortOrder
    credentialPublicKey?: SortOrder
    counter?: SortOrder
    credentialDeviceType?: SortOrder
    credentialBackedUp?: SortOrder
    transports?: SortOrder
  }

  export type AuthenticatorSumOrderByAggregateInput = {
    counter?: SortOrder
  }

  export type EnumOrderStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.OrderStatus | EnumOrderStatusFieldRefInput<$PrismaModel>
    in?: $Enums.OrderStatus[]
    notIn?: $Enums.OrderStatus[]
    not?: NestedEnumOrderStatusFilter<$PrismaModel> | $Enums.OrderStatus
  }

  export type UserNullableScalarRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type VoucherNullableScalarRelationFilter = {
    is?: VoucherWhereInput | null
    isNot?: VoucherWhereInput | null
  }

  export type OrderCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    userId?: SortOrder
    voucherId?: SortOrder
    totalPrice?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OrderAvgOrderByAggregateInput = {
    totalPrice?: SortOrder
  }

  export type OrderMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    userId?: SortOrder
    voucherId?: SortOrder
    totalPrice?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OrderMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    userId?: SortOrder
    voucherId?: SortOrder
    totalPrice?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OrderSumOrderByAggregateInput = {
    totalPrice?: SortOrder
  }

  export type EnumOrderStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OrderStatus | EnumOrderStatusFieldRefInput<$PrismaModel>
    in?: $Enums.OrderStatus[]
    notIn?: $Enums.OrderStatus[]
    not?: NestedEnumOrderStatusWithAggregatesFilter<$PrismaModel> | $Enums.OrderStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumOrderStatusFilter<$PrismaModel>
    _max?: NestedEnumOrderStatusFilter<$PrismaModel>
  }

  export type EnumMenuTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.MenuType | EnumMenuTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MenuType[]
    notIn?: $Enums.MenuType[]
    not?: NestedEnumMenuTypeFilter<$PrismaModel> | $Enums.MenuType
  }

  export type MenuNullableScalarRelationFilter = {
    is?: MenuWhereInput | null
    isNot?: MenuWhereInput | null
  }

  export type MenuListRelationFilter = {
    every?: MenuWhereInput
    some?: MenuWhereInput
    none?: MenuWhereInput
  }

  export type MenuOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MenuCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    type?: SortOrder
    order?: SortOrder
    icon?: SortOrder
    parentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MenuAvgOrderByAggregateInput = {
    order?: SortOrder
  }

  export type MenuMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    type?: SortOrder
    order?: SortOrder
    icon?: SortOrder
    parentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MenuMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    type?: SortOrder
    order?: SortOrder
    icon?: SortOrder
    parentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MenuSumOrderByAggregateInput = {
    order?: SortOrder
  }

  export type EnumMenuTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MenuType | EnumMenuTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MenuType[]
    notIn?: $Enums.MenuType[]
    not?: NestedEnumMenuTypeWithAggregatesFilter<$PrismaModel> | $Enums.MenuType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMenuTypeFilter<$PrismaModel>
    _max?: NestedEnumMenuTypeFilter<$PrismaModel>
  }

  export type EnumFooterInfoTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.FooterInfoType | EnumFooterInfoTypeFieldRefInput<$PrismaModel>
    in?: $Enums.FooterInfoType[]
    notIn?: $Enums.FooterInfoType[]
    not?: NestedEnumFooterInfoTypeFilter<$PrismaModel> | $Enums.FooterInfoType
  }

  export type FooterInfoCountOrderByAggregateInput = {
    id?: SortOrder
    label?: SortOrder
    value?: SortOrder
    type?: SortOrder
    icon?: SortOrder
    order?: SortOrder
  }

  export type FooterInfoAvgOrderByAggregateInput = {
    order?: SortOrder
  }

  export type FooterInfoMaxOrderByAggregateInput = {
    id?: SortOrder
    label?: SortOrder
    value?: SortOrder
    type?: SortOrder
    icon?: SortOrder
    order?: SortOrder
  }

  export type FooterInfoMinOrderByAggregateInput = {
    id?: SortOrder
    label?: SortOrder
    value?: SortOrder
    type?: SortOrder
    icon?: SortOrder
    order?: SortOrder
  }

  export type FooterInfoSumOrderByAggregateInput = {
    order?: SortOrder
  }

  export type EnumFooterInfoTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FooterInfoType | EnumFooterInfoTypeFieldRefInput<$PrismaModel>
    in?: $Enums.FooterInfoType[]
    notIn?: $Enums.FooterInfoType[]
    not?: NestedEnumFooterInfoTypeWithAggregatesFilter<$PrismaModel> | $Enums.FooterInfoType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumFooterInfoTypeFilter<$PrismaModel>
    _max?: NestedEnumFooterInfoTypeFilter<$PrismaModel>
  }

  export type AccountProviderProviderAccountIdCompoundUniqueInput = {
    provider: string
    providerAccountId: string
  }

  export type AccountCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrder
    access_token?: SortOrder
    expires_at?: SortOrder
    token_type?: SortOrder
    scope?: SortOrder
    id_token?: SortOrder
    session_state?: SortOrder
  }

  export type AccountAvgOrderByAggregateInput = {
    expires_at?: SortOrder
  }

  export type AccountMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrder
    access_token?: SortOrder
    expires_at?: SortOrder
    token_type?: SortOrder
    scope?: SortOrder
    id_token?: SortOrder
    session_state?: SortOrder
  }

  export type AccountMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrder
    access_token?: SortOrder
    expires_at?: SortOrder
    token_type?: SortOrder
    scope?: SortOrder
    id_token?: SortOrder
    session_state?: SortOrder
  }

  export type AccountSumOrderByAggregateInput = {
    expires_at?: SortOrder
  }

  export type SessionCountOrderByAggregateInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SessionMaxOrderByAggregateInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SessionMinOrderByAggregateInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VerificationTokenIdentifierTokenCompoundUniqueInput = {
    identifier: string
    token: string
  }

  export type VerificationTokenCountOrderByAggregateInput = {
    identifier?: SortOrder
    token?: SortOrder
    expires?: SortOrder
  }

  export type VerificationTokenMaxOrderByAggregateInput = {
    identifier?: SortOrder
    token?: SortOrder
    expires?: SortOrder
  }

  export type VerificationTokenMinOrderByAggregateInput = {
    identifier?: SortOrder
    token?: SortOrder
    expires?: SortOrder
  }

  export type LpForListRelationFilter = {
    every?: LpForWhereInput
    some?: LpForWhereInput
    none?: LpForWhereInput
  }

  export type LpContentTypeListRelationFilter = {
    every?: LpContentTypeWhereInput
    some?: LpContentTypeWhereInput
    none?: LpContentTypeWhereInput
  }

  export type LpDesignStyleNullableScalarRelationFilter = {
    is?: LpDesignStyleWhereInput | null
    isNot?: LpDesignStyleWhereInput | null
  }

  export type LpForOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LpContentTypeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LandingPageCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    image?: SortOrder
    lpDesignStyleId?: SortOrder
    marketingTools?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LandingPageMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    image?: SortOrder
    lpDesignStyleId?: SortOrder
    marketingTools?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LandingPageMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    image?: SortOrder
    lpDesignStyleId?: SortOrder
    marketingTools?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LandingPageListRelationFilter = {
    every?: LandingPageWhereInput
    some?: LandingPageWhereInput
    none?: LandingPageWhereInput
  }

  export type LandingPageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LpForCountOrderByAggregateInput = {
    id?: SortOrder
    description?: SortOrder
  }

  export type LpForMaxOrderByAggregateInput = {
    id?: SortOrder
    description?: SortOrder
  }

  export type LpForMinOrderByAggregateInput = {
    id?: SortOrder
    description?: SortOrder
  }

  export type LpContentTypeCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
  }

  export type LpContentTypeMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
  }

  export type LpContentTypeMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
  }

  export type LpDesignStyleCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
  }

  export type LpDesignStyleMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
  }

  export type LpDesignStyleMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type SocialLinksCreateNestedManyWithoutIdentityInput = {
    create?: XOR<SocialLinksCreateWithoutIdentityInput, SocialLinksUncheckedCreateWithoutIdentityInput> | SocialLinksCreateWithoutIdentityInput[] | SocialLinksUncheckedCreateWithoutIdentityInput[]
    connectOrCreate?: SocialLinksCreateOrConnectWithoutIdentityInput | SocialLinksCreateOrConnectWithoutIdentityInput[]
    createMany?: SocialLinksCreateManyIdentityInputEnvelope
    connect?: SocialLinksWhereUniqueInput | SocialLinksWhereUniqueInput[]
  }

  export type SocialLinksUncheckedCreateNestedManyWithoutIdentityInput = {
    create?: XOR<SocialLinksCreateWithoutIdentityInput, SocialLinksUncheckedCreateWithoutIdentityInput> | SocialLinksCreateWithoutIdentityInput[] | SocialLinksUncheckedCreateWithoutIdentityInput[]
    connectOrCreate?: SocialLinksCreateOrConnectWithoutIdentityInput | SocialLinksCreateOrConnectWithoutIdentityInput[]
    createMany?: SocialLinksCreateManyIdentityInputEnvelope
    connect?: SocialLinksWhereUniqueInput | SocialLinksWhereUniqueInput[]
  }

  export type SocialLinksUpdateManyWithoutIdentityNestedInput = {
    create?: XOR<SocialLinksCreateWithoutIdentityInput, SocialLinksUncheckedCreateWithoutIdentityInput> | SocialLinksCreateWithoutIdentityInput[] | SocialLinksUncheckedCreateWithoutIdentityInput[]
    connectOrCreate?: SocialLinksCreateOrConnectWithoutIdentityInput | SocialLinksCreateOrConnectWithoutIdentityInput[]
    upsert?: SocialLinksUpsertWithWhereUniqueWithoutIdentityInput | SocialLinksUpsertWithWhereUniqueWithoutIdentityInput[]
    createMany?: SocialLinksCreateManyIdentityInputEnvelope
    set?: SocialLinksWhereUniqueInput | SocialLinksWhereUniqueInput[]
    disconnect?: SocialLinksWhereUniqueInput | SocialLinksWhereUniqueInput[]
    delete?: SocialLinksWhereUniqueInput | SocialLinksWhereUniqueInput[]
    connect?: SocialLinksWhereUniqueInput | SocialLinksWhereUniqueInput[]
    update?: SocialLinksUpdateWithWhereUniqueWithoutIdentityInput | SocialLinksUpdateWithWhereUniqueWithoutIdentityInput[]
    updateMany?: SocialLinksUpdateManyWithWhereWithoutIdentityInput | SocialLinksUpdateManyWithWhereWithoutIdentityInput[]
    deleteMany?: SocialLinksScalarWhereInput | SocialLinksScalarWhereInput[]
  }

  export type SocialLinksUncheckedUpdateManyWithoutIdentityNestedInput = {
    create?: XOR<SocialLinksCreateWithoutIdentityInput, SocialLinksUncheckedCreateWithoutIdentityInput> | SocialLinksCreateWithoutIdentityInput[] | SocialLinksUncheckedCreateWithoutIdentityInput[]
    connectOrCreate?: SocialLinksCreateOrConnectWithoutIdentityInput | SocialLinksCreateOrConnectWithoutIdentityInput[]
    upsert?: SocialLinksUpsertWithWhereUniqueWithoutIdentityInput | SocialLinksUpsertWithWhereUniqueWithoutIdentityInput[]
    createMany?: SocialLinksCreateManyIdentityInputEnvelope
    set?: SocialLinksWhereUniqueInput | SocialLinksWhereUniqueInput[]
    disconnect?: SocialLinksWhereUniqueInput | SocialLinksWhereUniqueInput[]
    delete?: SocialLinksWhereUniqueInput | SocialLinksWhereUniqueInput[]
    connect?: SocialLinksWhereUniqueInput | SocialLinksWhereUniqueInput[]
    update?: SocialLinksUpdateWithWhereUniqueWithoutIdentityInput | SocialLinksUpdateWithWhereUniqueWithoutIdentityInput[]
    updateMany?: SocialLinksUpdateManyWithWhereWithoutIdentityInput | SocialLinksUpdateManyWithWhereWithoutIdentityInput[]
    deleteMany?: SocialLinksScalarWhereInput | SocialLinksScalarWhereInput[]
  }

  export type SiteIdentityCreateNestedOneWithoutSocialLinksInput = {
    create?: XOR<SiteIdentityCreateWithoutSocialLinksInput, SiteIdentityUncheckedCreateWithoutSocialLinksInput>
    connectOrCreate?: SiteIdentityCreateOrConnectWithoutSocialLinksInput
    connect?: SiteIdentityWhereUniqueInput
  }

  export type SiteIdentityUpdateOneWithoutSocialLinksNestedInput = {
    create?: XOR<SiteIdentityCreateWithoutSocialLinksInput, SiteIdentityUncheckedCreateWithoutSocialLinksInput>
    connectOrCreate?: SiteIdentityCreateOrConnectWithoutSocialLinksInput
    upsert?: SiteIdentityUpsertWithoutSocialLinksInput
    disconnect?: SiteIdentityWhereInput | boolean
    delete?: SiteIdentityWhereInput | boolean
    connect?: SiteIdentityWhereUniqueInput
    update?: XOR<XOR<SiteIdentityUpdateToOneWithWhereWithoutSocialLinksInput, SiteIdentityUpdateWithoutSocialLinksInput>, SiteIdentityUncheckedUpdateWithoutSocialLinksInput>
  }

  export type SectionCreateNestedManyWithoutPageInput = {
    create?: XOR<SectionCreateWithoutPageInput, SectionUncheckedCreateWithoutPageInput> | SectionCreateWithoutPageInput[] | SectionUncheckedCreateWithoutPageInput[]
    connectOrCreate?: SectionCreateOrConnectWithoutPageInput | SectionCreateOrConnectWithoutPageInput[]
    createMany?: SectionCreateManyPageInputEnvelope
    connect?: SectionWhereUniqueInput | SectionWhereUniqueInput[]
  }

  export type SectionUncheckedCreateNestedManyWithoutPageInput = {
    create?: XOR<SectionCreateWithoutPageInput, SectionUncheckedCreateWithoutPageInput> | SectionCreateWithoutPageInput[] | SectionUncheckedCreateWithoutPageInput[]
    connectOrCreate?: SectionCreateOrConnectWithoutPageInput | SectionCreateOrConnectWithoutPageInput[]
    createMany?: SectionCreateManyPageInputEnvelope
    connect?: SectionWhereUniqueInput | SectionWhereUniqueInput[]
  }

  export type SectionUpdateManyWithoutPageNestedInput = {
    create?: XOR<SectionCreateWithoutPageInput, SectionUncheckedCreateWithoutPageInput> | SectionCreateWithoutPageInput[] | SectionUncheckedCreateWithoutPageInput[]
    connectOrCreate?: SectionCreateOrConnectWithoutPageInput | SectionCreateOrConnectWithoutPageInput[]
    upsert?: SectionUpsertWithWhereUniqueWithoutPageInput | SectionUpsertWithWhereUniqueWithoutPageInput[]
    createMany?: SectionCreateManyPageInputEnvelope
    set?: SectionWhereUniqueInput | SectionWhereUniqueInput[]
    disconnect?: SectionWhereUniqueInput | SectionWhereUniqueInput[]
    delete?: SectionWhereUniqueInput | SectionWhereUniqueInput[]
    connect?: SectionWhereUniqueInput | SectionWhereUniqueInput[]
    update?: SectionUpdateWithWhereUniqueWithoutPageInput | SectionUpdateWithWhereUniqueWithoutPageInput[]
    updateMany?: SectionUpdateManyWithWhereWithoutPageInput | SectionUpdateManyWithWhereWithoutPageInput[]
    deleteMany?: SectionScalarWhereInput | SectionScalarWhereInput[]
  }

  export type SectionUncheckedUpdateManyWithoutPageNestedInput = {
    create?: XOR<SectionCreateWithoutPageInput, SectionUncheckedCreateWithoutPageInput> | SectionCreateWithoutPageInput[] | SectionUncheckedCreateWithoutPageInput[]
    connectOrCreate?: SectionCreateOrConnectWithoutPageInput | SectionCreateOrConnectWithoutPageInput[]
    upsert?: SectionUpsertWithWhereUniqueWithoutPageInput | SectionUpsertWithWhereUniqueWithoutPageInput[]
    createMany?: SectionCreateManyPageInputEnvelope
    set?: SectionWhereUniqueInput | SectionWhereUniqueInput[]
    disconnect?: SectionWhereUniqueInput | SectionWhereUniqueInput[]
    delete?: SectionWhereUniqueInput | SectionWhereUniqueInput[]
    connect?: SectionWhereUniqueInput | SectionWhereUniqueInput[]
    update?: SectionUpdateWithWhereUniqueWithoutPageInput | SectionUpdateWithWhereUniqueWithoutPageInput[]
    updateMany?: SectionUpdateManyWithWhereWithoutPageInput | SectionUpdateManyWithWhereWithoutPageInput[]
    deleteMany?: SectionScalarWhereInput | SectionScalarWhereInput[]
  }

  export type PageCreateNestedOneWithoutSectionsInput = {
    create?: XOR<PageCreateWithoutSectionsInput, PageUncheckedCreateWithoutSectionsInput>
    connectOrCreate?: PageCreateOrConnectWithoutSectionsInput
    connect?: PageWhereUniqueInput
  }

  export type ListItemCreateNestedManyWithoutSectionInput = {
    create?: XOR<ListItemCreateWithoutSectionInput, ListItemUncheckedCreateWithoutSectionInput> | ListItemCreateWithoutSectionInput[] | ListItemUncheckedCreateWithoutSectionInput[]
    connectOrCreate?: ListItemCreateOrConnectWithoutSectionInput | ListItemCreateOrConnectWithoutSectionInput[]
    createMany?: ListItemCreateManySectionInputEnvelope
    connect?: ListItemWhereUniqueInput | ListItemWhereUniqueInput[]
  }

  export type ListItemUncheckedCreateNestedManyWithoutSectionInput = {
    create?: XOR<ListItemCreateWithoutSectionInput, ListItemUncheckedCreateWithoutSectionInput> | ListItemCreateWithoutSectionInput[] | ListItemUncheckedCreateWithoutSectionInput[]
    connectOrCreate?: ListItemCreateOrConnectWithoutSectionInput | ListItemCreateOrConnectWithoutSectionInput[]
    createMany?: ListItemCreateManySectionInputEnvelope
    connect?: ListItemWhereUniqueInput | ListItemWhereUniqueInput[]
  }

  export type EnumSectionTypeFieldUpdateOperationsInput = {
    set?: $Enums.SectionType
  }

  export type PageUpdateOneRequiredWithoutSectionsNestedInput = {
    create?: XOR<PageCreateWithoutSectionsInput, PageUncheckedCreateWithoutSectionsInput>
    connectOrCreate?: PageCreateOrConnectWithoutSectionsInput
    upsert?: PageUpsertWithoutSectionsInput
    connect?: PageWhereUniqueInput
    update?: XOR<XOR<PageUpdateToOneWithWhereWithoutSectionsInput, PageUpdateWithoutSectionsInput>, PageUncheckedUpdateWithoutSectionsInput>
  }

  export type ListItemUpdateManyWithoutSectionNestedInput = {
    create?: XOR<ListItemCreateWithoutSectionInput, ListItemUncheckedCreateWithoutSectionInput> | ListItemCreateWithoutSectionInput[] | ListItemUncheckedCreateWithoutSectionInput[]
    connectOrCreate?: ListItemCreateOrConnectWithoutSectionInput | ListItemCreateOrConnectWithoutSectionInput[]
    upsert?: ListItemUpsertWithWhereUniqueWithoutSectionInput | ListItemUpsertWithWhereUniqueWithoutSectionInput[]
    createMany?: ListItemCreateManySectionInputEnvelope
    set?: ListItemWhereUniqueInput | ListItemWhereUniqueInput[]
    disconnect?: ListItemWhereUniqueInput | ListItemWhereUniqueInput[]
    delete?: ListItemWhereUniqueInput | ListItemWhereUniqueInput[]
    connect?: ListItemWhereUniqueInput | ListItemWhereUniqueInput[]
    update?: ListItemUpdateWithWhereUniqueWithoutSectionInput | ListItemUpdateWithWhereUniqueWithoutSectionInput[]
    updateMany?: ListItemUpdateManyWithWhereWithoutSectionInput | ListItemUpdateManyWithWhereWithoutSectionInput[]
    deleteMany?: ListItemScalarWhereInput | ListItemScalarWhereInput[]
  }

  export type ListItemUncheckedUpdateManyWithoutSectionNestedInput = {
    create?: XOR<ListItemCreateWithoutSectionInput, ListItemUncheckedCreateWithoutSectionInput> | ListItemCreateWithoutSectionInput[] | ListItemUncheckedCreateWithoutSectionInput[]
    connectOrCreate?: ListItemCreateOrConnectWithoutSectionInput | ListItemCreateOrConnectWithoutSectionInput[]
    upsert?: ListItemUpsertWithWhereUniqueWithoutSectionInput | ListItemUpsertWithWhereUniqueWithoutSectionInput[]
    createMany?: ListItemCreateManySectionInputEnvelope
    set?: ListItemWhereUniqueInput | ListItemWhereUniqueInput[]
    disconnect?: ListItemWhereUniqueInput | ListItemWhereUniqueInput[]
    delete?: ListItemWhereUniqueInput | ListItemWhereUniqueInput[]
    connect?: ListItemWhereUniqueInput | ListItemWhereUniqueInput[]
    update?: ListItemUpdateWithWhereUniqueWithoutSectionInput | ListItemUpdateWithWhereUniqueWithoutSectionInput[]
    updateMany?: ListItemUpdateManyWithWhereWithoutSectionInput | ListItemUpdateManyWithWhereWithoutSectionInput[]
    deleteMany?: ListItemScalarWhereInput | ListItemScalarWhereInput[]
  }

  export type SectionCreateNestedOneWithoutListItemsInput = {
    create?: XOR<SectionCreateWithoutListItemsInput, SectionUncheckedCreateWithoutListItemsInput>
    connectOrCreate?: SectionCreateOrConnectWithoutListItemsInput
    connect?: SectionWhereUniqueInput
  }

  export type ListEntryCreateNestedManyWithoutListItemInput = {
    create?: XOR<ListEntryCreateWithoutListItemInput, ListEntryUncheckedCreateWithoutListItemInput> | ListEntryCreateWithoutListItemInput[] | ListEntryUncheckedCreateWithoutListItemInput[]
    connectOrCreate?: ListEntryCreateOrConnectWithoutListItemInput | ListEntryCreateOrConnectWithoutListItemInput[]
    createMany?: ListEntryCreateManyListItemInputEnvelope
    connect?: ListEntryWhereUniqueInput | ListEntryWhereUniqueInput[]
  }

  export type ListEntryUncheckedCreateNestedManyWithoutListItemInput = {
    create?: XOR<ListEntryCreateWithoutListItemInput, ListEntryUncheckedCreateWithoutListItemInput> | ListEntryCreateWithoutListItemInput[] | ListEntryUncheckedCreateWithoutListItemInput[]
    connectOrCreate?: ListEntryCreateOrConnectWithoutListItemInput | ListEntryCreateOrConnectWithoutListItemInput[]
    createMany?: ListEntryCreateManyListItemInputEnvelope
    connect?: ListEntryWhereUniqueInput | ListEntryWhereUniqueInput[]
  }

  export type EnumListItemTypeFieldUpdateOperationsInput = {
    set?: $Enums.ListItemType
  }

  export type SectionUpdateOneRequiredWithoutListItemsNestedInput = {
    create?: XOR<SectionCreateWithoutListItemsInput, SectionUncheckedCreateWithoutListItemsInput>
    connectOrCreate?: SectionCreateOrConnectWithoutListItemsInput
    upsert?: SectionUpsertWithoutListItemsInput
    connect?: SectionWhereUniqueInput
    update?: XOR<XOR<SectionUpdateToOneWithWhereWithoutListItemsInput, SectionUpdateWithoutListItemsInput>, SectionUncheckedUpdateWithoutListItemsInput>
  }

  export type ListEntryUpdateManyWithoutListItemNestedInput = {
    create?: XOR<ListEntryCreateWithoutListItemInput, ListEntryUncheckedCreateWithoutListItemInput> | ListEntryCreateWithoutListItemInput[] | ListEntryUncheckedCreateWithoutListItemInput[]
    connectOrCreate?: ListEntryCreateOrConnectWithoutListItemInput | ListEntryCreateOrConnectWithoutListItemInput[]
    upsert?: ListEntryUpsertWithWhereUniqueWithoutListItemInput | ListEntryUpsertWithWhereUniqueWithoutListItemInput[]
    createMany?: ListEntryCreateManyListItemInputEnvelope
    set?: ListEntryWhereUniqueInput | ListEntryWhereUniqueInput[]
    disconnect?: ListEntryWhereUniqueInput | ListEntryWhereUniqueInput[]
    delete?: ListEntryWhereUniqueInput | ListEntryWhereUniqueInput[]
    connect?: ListEntryWhereUniqueInput | ListEntryWhereUniqueInput[]
    update?: ListEntryUpdateWithWhereUniqueWithoutListItemInput | ListEntryUpdateWithWhereUniqueWithoutListItemInput[]
    updateMany?: ListEntryUpdateManyWithWhereWithoutListItemInput | ListEntryUpdateManyWithWhereWithoutListItemInput[]
    deleteMany?: ListEntryScalarWhereInput | ListEntryScalarWhereInput[]
  }

  export type ListEntryUncheckedUpdateManyWithoutListItemNestedInput = {
    create?: XOR<ListEntryCreateWithoutListItemInput, ListEntryUncheckedCreateWithoutListItemInput> | ListEntryCreateWithoutListItemInput[] | ListEntryUncheckedCreateWithoutListItemInput[]
    connectOrCreate?: ListEntryCreateOrConnectWithoutListItemInput | ListEntryCreateOrConnectWithoutListItemInput[]
    upsert?: ListEntryUpsertWithWhereUniqueWithoutListItemInput | ListEntryUpsertWithWhereUniqueWithoutListItemInput[]
    createMany?: ListEntryCreateManyListItemInputEnvelope
    set?: ListEntryWhereUniqueInput | ListEntryWhereUniqueInput[]
    disconnect?: ListEntryWhereUniqueInput | ListEntryWhereUniqueInput[]
    delete?: ListEntryWhereUniqueInput | ListEntryWhereUniqueInput[]
    connect?: ListEntryWhereUniqueInput | ListEntryWhereUniqueInput[]
    update?: ListEntryUpdateWithWhereUniqueWithoutListItemInput | ListEntryUpdateWithWhereUniqueWithoutListItemInput[]
    updateMany?: ListEntryUpdateManyWithWhereWithoutListItemInput | ListEntryUpdateManyWithWhereWithoutListItemInput[]
    deleteMany?: ListEntryScalarWhereInput | ListEntryScalarWhereInput[]
  }

  export type ListItemCreateNestedOneWithoutEntriesInput = {
    create?: XOR<ListItemCreateWithoutEntriesInput, ListItemUncheckedCreateWithoutEntriesInput>
    connectOrCreate?: ListItemCreateOrConnectWithoutEntriesInput
    connect?: ListItemWhereUniqueInput
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type ListItemUpdateOneRequiredWithoutEntriesNestedInput = {
    create?: XOR<ListItemCreateWithoutEntriesInput, ListItemUncheckedCreateWithoutEntriesInput>
    connectOrCreate?: ListItemCreateOrConnectWithoutEntriesInput
    upsert?: ListItemUpsertWithoutEntriesInput
    connect?: ListItemWhereUniqueInput
    update?: XOR<XOR<ListItemUpdateToOneWithWhereWithoutEntriesInput, ListItemUpdateWithoutEntriesInput>, ListItemUncheckedUpdateWithoutEntriesInput>
  }

  export type CategoryCreateNestedOneWithoutProductsInput = {
    create?: XOR<CategoryCreateWithoutProductsInput, CategoryUncheckedCreateWithoutProductsInput>
    connectOrCreate?: CategoryCreateOrConnectWithoutProductsInput
    connect?: CategoryWhereUniqueInput
  }

  export type TagCreateNestedManyWithoutProductsInput = {
    create?: XOR<TagCreateWithoutProductsInput, TagUncheckedCreateWithoutProductsInput> | TagCreateWithoutProductsInput[] | TagUncheckedCreateWithoutProductsInput[]
    connectOrCreate?: TagCreateOrConnectWithoutProductsInput | TagCreateOrConnectWithoutProductsInput[]
    connect?: TagWhereUniqueInput | TagWhereUniqueInput[]
  }

  export type ProductGalleryCreateNestedManyWithoutProductInput = {
    create?: XOR<ProductGalleryCreateWithoutProductInput, ProductGalleryUncheckedCreateWithoutProductInput> | ProductGalleryCreateWithoutProductInput[] | ProductGalleryUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductGalleryCreateOrConnectWithoutProductInput | ProductGalleryCreateOrConnectWithoutProductInput[]
    createMany?: ProductGalleryCreateManyProductInputEnvelope
    connect?: ProductGalleryWhereUniqueInput | ProductGalleryWhereUniqueInput[]
  }

  export type ProductBenefitCreateNestedManyWithoutProductInput = {
    create?: XOR<ProductBenefitCreateWithoutProductInput, ProductBenefitUncheckedCreateWithoutProductInput> | ProductBenefitCreateWithoutProductInput[] | ProductBenefitUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductBenefitCreateOrConnectWithoutProductInput | ProductBenefitCreateOrConnectWithoutProductInput[]
    createMany?: ProductBenefitCreateManyProductInputEnvelope
    connect?: ProductBenefitWhereUniqueInput | ProductBenefitWhereUniqueInput[]
  }

  export type ProductBenefitPointCreateNestedManyWithoutProductInput = {
    create?: XOR<ProductBenefitPointCreateWithoutProductInput, ProductBenefitPointUncheckedCreateWithoutProductInput> | ProductBenefitPointCreateWithoutProductInput[] | ProductBenefitPointUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductBenefitPointCreateOrConnectWithoutProductInput | ProductBenefitPointCreateOrConnectWithoutProductInput[]
    createMany?: ProductBenefitPointCreateManyProductInputEnvelope
    connect?: ProductBenefitPointWhereUniqueInput | ProductBenefitPointWhereUniqueInput[]
  }

  export type PromotionCreateNestedManyWithoutProductsInput = {
    create?: XOR<PromotionCreateWithoutProductsInput, PromotionUncheckedCreateWithoutProductsInput> | PromotionCreateWithoutProductsInput[] | PromotionUncheckedCreateWithoutProductsInput[]
    connectOrCreate?: PromotionCreateOrConnectWithoutProductsInput | PromotionCreateOrConnectWithoutProductsInput[]
    connect?: PromotionWhereUniqueInput | PromotionWhereUniqueInput[]
  }

  export type VoucherCreateNestedManyWithoutProductsInput = {
    create?: XOR<VoucherCreateWithoutProductsInput, VoucherUncheckedCreateWithoutProductsInput> | VoucherCreateWithoutProductsInput[] | VoucherUncheckedCreateWithoutProductsInput[]
    connectOrCreate?: VoucherCreateOrConnectWithoutProductsInput | VoucherCreateOrConnectWithoutProductsInput[]
    connect?: VoucherWhereUniqueInput | VoucherWhereUniqueInput[]
  }

  export type OrderCreateNestedManyWithoutProductsInput = {
    create?: XOR<OrderCreateWithoutProductsInput, OrderUncheckedCreateWithoutProductsInput> | OrderCreateWithoutProductsInput[] | OrderUncheckedCreateWithoutProductsInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutProductsInput | OrderCreateOrConnectWithoutProductsInput[]
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
  }

  export type TagUncheckedCreateNestedManyWithoutProductsInput = {
    create?: XOR<TagCreateWithoutProductsInput, TagUncheckedCreateWithoutProductsInput> | TagCreateWithoutProductsInput[] | TagUncheckedCreateWithoutProductsInput[]
    connectOrCreate?: TagCreateOrConnectWithoutProductsInput | TagCreateOrConnectWithoutProductsInput[]
    connect?: TagWhereUniqueInput | TagWhereUniqueInput[]
  }

  export type ProductGalleryUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<ProductGalleryCreateWithoutProductInput, ProductGalleryUncheckedCreateWithoutProductInput> | ProductGalleryCreateWithoutProductInput[] | ProductGalleryUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductGalleryCreateOrConnectWithoutProductInput | ProductGalleryCreateOrConnectWithoutProductInput[]
    createMany?: ProductGalleryCreateManyProductInputEnvelope
    connect?: ProductGalleryWhereUniqueInput | ProductGalleryWhereUniqueInput[]
  }

  export type ProductBenefitUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<ProductBenefitCreateWithoutProductInput, ProductBenefitUncheckedCreateWithoutProductInput> | ProductBenefitCreateWithoutProductInput[] | ProductBenefitUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductBenefitCreateOrConnectWithoutProductInput | ProductBenefitCreateOrConnectWithoutProductInput[]
    createMany?: ProductBenefitCreateManyProductInputEnvelope
    connect?: ProductBenefitWhereUniqueInput | ProductBenefitWhereUniqueInput[]
  }

  export type ProductBenefitPointUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<ProductBenefitPointCreateWithoutProductInput, ProductBenefitPointUncheckedCreateWithoutProductInput> | ProductBenefitPointCreateWithoutProductInput[] | ProductBenefitPointUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductBenefitPointCreateOrConnectWithoutProductInput | ProductBenefitPointCreateOrConnectWithoutProductInput[]
    createMany?: ProductBenefitPointCreateManyProductInputEnvelope
    connect?: ProductBenefitPointWhereUniqueInput | ProductBenefitPointWhereUniqueInput[]
  }

  export type PromotionUncheckedCreateNestedManyWithoutProductsInput = {
    create?: XOR<PromotionCreateWithoutProductsInput, PromotionUncheckedCreateWithoutProductsInput> | PromotionCreateWithoutProductsInput[] | PromotionUncheckedCreateWithoutProductsInput[]
    connectOrCreate?: PromotionCreateOrConnectWithoutProductsInput | PromotionCreateOrConnectWithoutProductsInput[]
    connect?: PromotionWhereUniqueInput | PromotionWhereUniqueInput[]
  }

  export type VoucherUncheckedCreateNestedManyWithoutProductsInput = {
    create?: XOR<VoucherCreateWithoutProductsInput, VoucherUncheckedCreateWithoutProductsInput> | VoucherCreateWithoutProductsInput[] | VoucherUncheckedCreateWithoutProductsInput[]
    connectOrCreate?: VoucherCreateOrConnectWithoutProductsInput | VoucherCreateOrConnectWithoutProductsInput[]
    connect?: VoucherWhereUniqueInput | VoucherWhereUniqueInput[]
  }

  export type OrderUncheckedCreateNestedManyWithoutProductsInput = {
    create?: XOR<OrderCreateWithoutProductsInput, OrderUncheckedCreateWithoutProductsInput> | OrderCreateWithoutProductsInput[] | OrderUncheckedCreateWithoutProductsInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutProductsInput | OrderCreateOrConnectWithoutProductsInput[]
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type EnumProductStatusFieldUpdateOperationsInput = {
    set?: $Enums.ProductStatus
  }

  export type CategoryUpdateOneRequiredWithoutProductsNestedInput = {
    create?: XOR<CategoryCreateWithoutProductsInput, CategoryUncheckedCreateWithoutProductsInput>
    connectOrCreate?: CategoryCreateOrConnectWithoutProductsInput
    upsert?: CategoryUpsertWithoutProductsInput
    connect?: CategoryWhereUniqueInput
    update?: XOR<XOR<CategoryUpdateToOneWithWhereWithoutProductsInput, CategoryUpdateWithoutProductsInput>, CategoryUncheckedUpdateWithoutProductsInput>
  }

  export type TagUpdateManyWithoutProductsNestedInput = {
    create?: XOR<TagCreateWithoutProductsInput, TagUncheckedCreateWithoutProductsInput> | TagCreateWithoutProductsInput[] | TagUncheckedCreateWithoutProductsInput[]
    connectOrCreate?: TagCreateOrConnectWithoutProductsInput | TagCreateOrConnectWithoutProductsInput[]
    upsert?: TagUpsertWithWhereUniqueWithoutProductsInput | TagUpsertWithWhereUniqueWithoutProductsInput[]
    set?: TagWhereUniqueInput | TagWhereUniqueInput[]
    disconnect?: TagWhereUniqueInput | TagWhereUniqueInput[]
    delete?: TagWhereUniqueInput | TagWhereUniqueInput[]
    connect?: TagWhereUniqueInput | TagWhereUniqueInput[]
    update?: TagUpdateWithWhereUniqueWithoutProductsInput | TagUpdateWithWhereUniqueWithoutProductsInput[]
    updateMany?: TagUpdateManyWithWhereWithoutProductsInput | TagUpdateManyWithWhereWithoutProductsInput[]
    deleteMany?: TagScalarWhereInput | TagScalarWhereInput[]
  }

  export type ProductGalleryUpdateManyWithoutProductNestedInput = {
    create?: XOR<ProductGalleryCreateWithoutProductInput, ProductGalleryUncheckedCreateWithoutProductInput> | ProductGalleryCreateWithoutProductInput[] | ProductGalleryUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductGalleryCreateOrConnectWithoutProductInput | ProductGalleryCreateOrConnectWithoutProductInput[]
    upsert?: ProductGalleryUpsertWithWhereUniqueWithoutProductInput | ProductGalleryUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: ProductGalleryCreateManyProductInputEnvelope
    set?: ProductGalleryWhereUniqueInput | ProductGalleryWhereUniqueInput[]
    disconnect?: ProductGalleryWhereUniqueInput | ProductGalleryWhereUniqueInput[]
    delete?: ProductGalleryWhereUniqueInput | ProductGalleryWhereUniqueInput[]
    connect?: ProductGalleryWhereUniqueInput | ProductGalleryWhereUniqueInput[]
    update?: ProductGalleryUpdateWithWhereUniqueWithoutProductInput | ProductGalleryUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: ProductGalleryUpdateManyWithWhereWithoutProductInput | ProductGalleryUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: ProductGalleryScalarWhereInput | ProductGalleryScalarWhereInput[]
  }

  export type ProductBenefitUpdateManyWithoutProductNestedInput = {
    create?: XOR<ProductBenefitCreateWithoutProductInput, ProductBenefitUncheckedCreateWithoutProductInput> | ProductBenefitCreateWithoutProductInput[] | ProductBenefitUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductBenefitCreateOrConnectWithoutProductInput | ProductBenefitCreateOrConnectWithoutProductInput[]
    upsert?: ProductBenefitUpsertWithWhereUniqueWithoutProductInput | ProductBenefitUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: ProductBenefitCreateManyProductInputEnvelope
    set?: ProductBenefitWhereUniqueInput | ProductBenefitWhereUniqueInput[]
    disconnect?: ProductBenefitWhereUniqueInput | ProductBenefitWhereUniqueInput[]
    delete?: ProductBenefitWhereUniqueInput | ProductBenefitWhereUniqueInput[]
    connect?: ProductBenefitWhereUniqueInput | ProductBenefitWhereUniqueInput[]
    update?: ProductBenefitUpdateWithWhereUniqueWithoutProductInput | ProductBenefitUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: ProductBenefitUpdateManyWithWhereWithoutProductInput | ProductBenefitUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: ProductBenefitScalarWhereInput | ProductBenefitScalarWhereInput[]
  }

  export type ProductBenefitPointUpdateManyWithoutProductNestedInput = {
    create?: XOR<ProductBenefitPointCreateWithoutProductInput, ProductBenefitPointUncheckedCreateWithoutProductInput> | ProductBenefitPointCreateWithoutProductInput[] | ProductBenefitPointUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductBenefitPointCreateOrConnectWithoutProductInput | ProductBenefitPointCreateOrConnectWithoutProductInput[]
    upsert?: ProductBenefitPointUpsertWithWhereUniqueWithoutProductInput | ProductBenefitPointUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: ProductBenefitPointCreateManyProductInputEnvelope
    set?: ProductBenefitPointWhereUniqueInput | ProductBenefitPointWhereUniqueInput[]
    disconnect?: ProductBenefitPointWhereUniqueInput | ProductBenefitPointWhereUniqueInput[]
    delete?: ProductBenefitPointWhereUniqueInput | ProductBenefitPointWhereUniqueInput[]
    connect?: ProductBenefitPointWhereUniqueInput | ProductBenefitPointWhereUniqueInput[]
    update?: ProductBenefitPointUpdateWithWhereUniqueWithoutProductInput | ProductBenefitPointUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: ProductBenefitPointUpdateManyWithWhereWithoutProductInput | ProductBenefitPointUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: ProductBenefitPointScalarWhereInput | ProductBenefitPointScalarWhereInput[]
  }

  export type PromotionUpdateManyWithoutProductsNestedInput = {
    create?: XOR<PromotionCreateWithoutProductsInput, PromotionUncheckedCreateWithoutProductsInput> | PromotionCreateWithoutProductsInput[] | PromotionUncheckedCreateWithoutProductsInput[]
    connectOrCreate?: PromotionCreateOrConnectWithoutProductsInput | PromotionCreateOrConnectWithoutProductsInput[]
    upsert?: PromotionUpsertWithWhereUniqueWithoutProductsInput | PromotionUpsertWithWhereUniqueWithoutProductsInput[]
    set?: PromotionWhereUniqueInput | PromotionWhereUniqueInput[]
    disconnect?: PromotionWhereUniqueInput | PromotionWhereUniqueInput[]
    delete?: PromotionWhereUniqueInput | PromotionWhereUniqueInput[]
    connect?: PromotionWhereUniqueInput | PromotionWhereUniqueInput[]
    update?: PromotionUpdateWithWhereUniqueWithoutProductsInput | PromotionUpdateWithWhereUniqueWithoutProductsInput[]
    updateMany?: PromotionUpdateManyWithWhereWithoutProductsInput | PromotionUpdateManyWithWhereWithoutProductsInput[]
    deleteMany?: PromotionScalarWhereInput | PromotionScalarWhereInput[]
  }

  export type VoucherUpdateManyWithoutProductsNestedInput = {
    create?: XOR<VoucherCreateWithoutProductsInput, VoucherUncheckedCreateWithoutProductsInput> | VoucherCreateWithoutProductsInput[] | VoucherUncheckedCreateWithoutProductsInput[]
    connectOrCreate?: VoucherCreateOrConnectWithoutProductsInput | VoucherCreateOrConnectWithoutProductsInput[]
    upsert?: VoucherUpsertWithWhereUniqueWithoutProductsInput | VoucherUpsertWithWhereUniqueWithoutProductsInput[]
    set?: VoucherWhereUniqueInput | VoucherWhereUniqueInput[]
    disconnect?: VoucherWhereUniqueInput | VoucherWhereUniqueInput[]
    delete?: VoucherWhereUniqueInput | VoucherWhereUniqueInput[]
    connect?: VoucherWhereUniqueInput | VoucherWhereUniqueInput[]
    update?: VoucherUpdateWithWhereUniqueWithoutProductsInput | VoucherUpdateWithWhereUniqueWithoutProductsInput[]
    updateMany?: VoucherUpdateManyWithWhereWithoutProductsInput | VoucherUpdateManyWithWhereWithoutProductsInput[]
    deleteMany?: VoucherScalarWhereInput | VoucherScalarWhereInput[]
  }

  export type OrderUpdateManyWithoutProductsNestedInput = {
    create?: XOR<OrderCreateWithoutProductsInput, OrderUncheckedCreateWithoutProductsInput> | OrderCreateWithoutProductsInput[] | OrderUncheckedCreateWithoutProductsInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutProductsInput | OrderCreateOrConnectWithoutProductsInput[]
    upsert?: OrderUpsertWithWhereUniqueWithoutProductsInput | OrderUpsertWithWhereUniqueWithoutProductsInput[]
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    update?: OrderUpdateWithWhereUniqueWithoutProductsInput | OrderUpdateWithWhereUniqueWithoutProductsInput[]
    updateMany?: OrderUpdateManyWithWhereWithoutProductsInput | OrderUpdateManyWithWhereWithoutProductsInput[]
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[]
  }

  export type TagUncheckedUpdateManyWithoutProductsNestedInput = {
    create?: XOR<TagCreateWithoutProductsInput, TagUncheckedCreateWithoutProductsInput> | TagCreateWithoutProductsInput[] | TagUncheckedCreateWithoutProductsInput[]
    connectOrCreate?: TagCreateOrConnectWithoutProductsInput | TagCreateOrConnectWithoutProductsInput[]
    upsert?: TagUpsertWithWhereUniqueWithoutProductsInput | TagUpsertWithWhereUniqueWithoutProductsInput[]
    set?: TagWhereUniqueInput | TagWhereUniqueInput[]
    disconnect?: TagWhereUniqueInput | TagWhereUniqueInput[]
    delete?: TagWhereUniqueInput | TagWhereUniqueInput[]
    connect?: TagWhereUniqueInput | TagWhereUniqueInput[]
    update?: TagUpdateWithWhereUniqueWithoutProductsInput | TagUpdateWithWhereUniqueWithoutProductsInput[]
    updateMany?: TagUpdateManyWithWhereWithoutProductsInput | TagUpdateManyWithWhereWithoutProductsInput[]
    deleteMany?: TagScalarWhereInput | TagScalarWhereInput[]
  }

  export type ProductGalleryUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<ProductGalleryCreateWithoutProductInput, ProductGalleryUncheckedCreateWithoutProductInput> | ProductGalleryCreateWithoutProductInput[] | ProductGalleryUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductGalleryCreateOrConnectWithoutProductInput | ProductGalleryCreateOrConnectWithoutProductInput[]
    upsert?: ProductGalleryUpsertWithWhereUniqueWithoutProductInput | ProductGalleryUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: ProductGalleryCreateManyProductInputEnvelope
    set?: ProductGalleryWhereUniqueInput | ProductGalleryWhereUniqueInput[]
    disconnect?: ProductGalleryWhereUniqueInput | ProductGalleryWhereUniqueInput[]
    delete?: ProductGalleryWhereUniqueInput | ProductGalleryWhereUniqueInput[]
    connect?: ProductGalleryWhereUniqueInput | ProductGalleryWhereUniqueInput[]
    update?: ProductGalleryUpdateWithWhereUniqueWithoutProductInput | ProductGalleryUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: ProductGalleryUpdateManyWithWhereWithoutProductInput | ProductGalleryUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: ProductGalleryScalarWhereInput | ProductGalleryScalarWhereInput[]
  }

  export type ProductBenefitUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<ProductBenefitCreateWithoutProductInput, ProductBenefitUncheckedCreateWithoutProductInput> | ProductBenefitCreateWithoutProductInput[] | ProductBenefitUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductBenefitCreateOrConnectWithoutProductInput | ProductBenefitCreateOrConnectWithoutProductInput[]
    upsert?: ProductBenefitUpsertWithWhereUniqueWithoutProductInput | ProductBenefitUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: ProductBenefitCreateManyProductInputEnvelope
    set?: ProductBenefitWhereUniqueInput | ProductBenefitWhereUniqueInput[]
    disconnect?: ProductBenefitWhereUniqueInput | ProductBenefitWhereUniqueInput[]
    delete?: ProductBenefitWhereUniqueInput | ProductBenefitWhereUniqueInput[]
    connect?: ProductBenefitWhereUniqueInput | ProductBenefitWhereUniqueInput[]
    update?: ProductBenefitUpdateWithWhereUniqueWithoutProductInput | ProductBenefitUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: ProductBenefitUpdateManyWithWhereWithoutProductInput | ProductBenefitUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: ProductBenefitScalarWhereInput | ProductBenefitScalarWhereInput[]
  }

  export type ProductBenefitPointUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<ProductBenefitPointCreateWithoutProductInput, ProductBenefitPointUncheckedCreateWithoutProductInput> | ProductBenefitPointCreateWithoutProductInput[] | ProductBenefitPointUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductBenefitPointCreateOrConnectWithoutProductInput | ProductBenefitPointCreateOrConnectWithoutProductInput[]
    upsert?: ProductBenefitPointUpsertWithWhereUniqueWithoutProductInput | ProductBenefitPointUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: ProductBenefitPointCreateManyProductInputEnvelope
    set?: ProductBenefitPointWhereUniqueInput | ProductBenefitPointWhereUniqueInput[]
    disconnect?: ProductBenefitPointWhereUniqueInput | ProductBenefitPointWhereUniqueInput[]
    delete?: ProductBenefitPointWhereUniqueInput | ProductBenefitPointWhereUniqueInput[]
    connect?: ProductBenefitPointWhereUniqueInput | ProductBenefitPointWhereUniqueInput[]
    update?: ProductBenefitPointUpdateWithWhereUniqueWithoutProductInput | ProductBenefitPointUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: ProductBenefitPointUpdateManyWithWhereWithoutProductInput | ProductBenefitPointUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: ProductBenefitPointScalarWhereInput | ProductBenefitPointScalarWhereInput[]
  }

  export type PromotionUncheckedUpdateManyWithoutProductsNestedInput = {
    create?: XOR<PromotionCreateWithoutProductsInput, PromotionUncheckedCreateWithoutProductsInput> | PromotionCreateWithoutProductsInput[] | PromotionUncheckedCreateWithoutProductsInput[]
    connectOrCreate?: PromotionCreateOrConnectWithoutProductsInput | PromotionCreateOrConnectWithoutProductsInput[]
    upsert?: PromotionUpsertWithWhereUniqueWithoutProductsInput | PromotionUpsertWithWhereUniqueWithoutProductsInput[]
    set?: PromotionWhereUniqueInput | PromotionWhereUniqueInput[]
    disconnect?: PromotionWhereUniqueInput | PromotionWhereUniqueInput[]
    delete?: PromotionWhereUniqueInput | PromotionWhereUniqueInput[]
    connect?: PromotionWhereUniqueInput | PromotionWhereUniqueInput[]
    update?: PromotionUpdateWithWhereUniqueWithoutProductsInput | PromotionUpdateWithWhereUniqueWithoutProductsInput[]
    updateMany?: PromotionUpdateManyWithWhereWithoutProductsInput | PromotionUpdateManyWithWhereWithoutProductsInput[]
    deleteMany?: PromotionScalarWhereInput | PromotionScalarWhereInput[]
  }

  export type VoucherUncheckedUpdateManyWithoutProductsNestedInput = {
    create?: XOR<VoucherCreateWithoutProductsInput, VoucherUncheckedCreateWithoutProductsInput> | VoucherCreateWithoutProductsInput[] | VoucherUncheckedCreateWithoutProductsInput[]
    connectOrCreate?: VoucherCreateOrConnectWithoutProductsInput | VoucherCreateOrConnectWithoutProductsInput[]
    upsert?: VoucherUpsertWithWhereUniqueWithoutProductsInput | VoucherUpsertWithWhereUniqueWithoutProductsInput[]
    set?: VoucherWhereUniqueInput | VoucherWhereUniqueInput[]
    disconnect?: VoucherWhereUniqueInput | VoucherWhereUniqueInput[]
    delete?: VoucherWhereUniqueInput | VoucherWhereUniqueInput[]
    connect?: VoucherWhereUniqueInput | VoucherWhereUniqueInput[]
    update?: VoucherUpdateWithWhereUniqueWithoutProductsInput | VoucherUpdateWithWhereUniqueWithoutProductsInput[]
    updateMany?: VoucherUpdateManyWithWhereWithoutProductsInput | VoucherUpdateManyWithWhereWithoutProductsInput[]
    deleteMany?: VoucherScalarWhereInput | VoucherScalarWhereInput[]
  }

  export type OrderUncheckedUpdateManyWithoutProductsNestedInput = {
    create?: XOR<OrderCreateWithoutProductsInput, OrderUncheckedCreateWithoutProductsInput> | OrderCreateWithoutProductsInput[] | OrderUncheckedCreateWithoutProductsInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutProductsInput | OrderCreateOrConnectWithoutProductsInput[]
    upsert?: OrderUpsertWithWhereUniqueWithoutProductsInput | OrderUpsertWithWhereUniqueWithoutProductsInput[]
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    update?: OrderUpdateWithWhereUniqueWithoutProductsInput | OrderUpdateWithWhereUniqueWithoutProductsInput[]
    updateMany?: OrderUpdateManyWithWhereWithoutProductsInput | OrderUpdateManyWithWhereWithoutProductsInput[]
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[]
  }

  export type ProductCreateNestedManyWithoutCategoryInput = {
    create?: XOR<ProductCreateWithoutCategoryInput, ProductUncheckedCreateWithoutCategoryInput> | ProductCreateWithoutCategoryInput[] | ProductUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutCategoryInput | ProductCreateOrConnectWithoutCategoryInput[]
    createMany?: ProductCreateManyCategoryInputEnvelope
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type ProductUncheckedCreateNestedManyWithoutCategoryInput = {
    create?: XOR<ProductCreateWithoutCategoryInput, ProductUncheckedCreateWithoutCategoryInput> | ProductCreateWithoutCategoryInput[] | ProductUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutCategoryInput | ProductCreateOrConnectWithoutCategoryInput[]
    createMany?: ProductCreateManyCategoryInputEnvelope
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type ProductUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<ProductCreateWithoutCategoryInput, ProductUncheckedCreateWithoutCategoryInput> | ProductCreateWithoutCategoryInput[] | ProductUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutCategoryInput | ProductCreateOrConnectWithoutCategoryInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutCategoryInput | ProductUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: ProductCreateManyCategoryInputEnvelope
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutCategoryInput | ProductUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutCategoryInput | ProductUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type ProductUncheckedUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<ProductCreateWithoutCategoryInput, ProductUncheckedCreateWithoutCategoryInput> | ProductCreateWithoutCategoryInput[] | ProductUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutCategoryInput | ProductCreateOrConnectWithoutCategoryInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutCategoryInput | ProductUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: ProductCreateManyCategoryInputEnvelope
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutCategoryInput | ProductUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutCategoryInput | ProductUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type ProductCreateNestedManyWithoutTagsInput = {
    create?: XOR<ProductCreateWithoutTagsInput, ProductUncheckedCreateWithoutTagsInput> | ProductCreateWithoutTagsInput[] | ProductUncheckedCreateWithoutTagsInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutTagsInput | ProductCreateOrConnectWithoutTagsInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type ProductUncheckedCreateNestedManyWithoutTagsInput = {
    create?: XOR<ProductCreateWithoutTagsInput, ProductUncheckedCreateWithoutTagsInput> | ProductCreateWithoutTagsInput[] | ProductUncheckedCreateWithoutTagsInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutTagsInput | ProductCreateOrConnectWithoutTagsInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type ProductUpdateManyWithoutTagsNestedInput = {
    create?: XOR<ProductCreateWithoutTagsInput, ProductUncheckedCreateWithoutTagsInput> | ProductCreateWithoutTagsInput[] | ProductUncheckedCreateWithoutTagsInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutTagsInput | ProductCreateOrConnectWithoutTagsInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutTagsInput | ProductUpsertWithWhereUniqueWithoutTagsInput[]
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutTagsInput | ProductUpdateWithWhereUniqueWithoutTagsInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutTagsInput | ProductUpdateManyWithWhereWithoutTagsInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type ProductUncheckedUpdateManyWithoutTagsNestedInput = {
    create?: XOR<ProductCreateWithoutTagsInput, ProductUncheckedCreateWithoutTagsInput> | ProductCreateWithoutTagsInput[] | ProductUncheckedCreateWithoutTagsInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutTagsInput | ProductCreateOrConnectWithoutTagsInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutTagsInput | ProductUpsertWithWhereUniqueWithoutTagsInput[]
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutTagsInput | ProductUpdateWithWhereUniqueWithoutTagsInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutTagsInput | ProductUpdateManyWithWhereWithoutTagsInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type ProductCreateNestedOneWithoutGalleryInput = {
    create?: XOR<ProductCreateWithoutGalleryInput, ProductUncheckedCreateWithoutGalleryInput>
    connectOrCreate?: ProductCreateOrConnectWithoutGalleryInput
    connect?: ProductWhereUniqueInput
  }

  export type ProductUpdateOneRequiredWithoutGalleryNestedInput = {
    create?: XOR<ProductCreateWithoutGalleryInput, ProductUncheckedCreateWithoutGalleryInput>
    connectOrCreate?: ProductCreateOrConnectWithoutGalleryInput
    upsert?: ProductUpsertWithoutGalleryInput
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutGalleryInput, ProductUpdateWithoutGalleryInput>, ProductUncheckedUpdateWithoutGalleryInput>
  }

  export type ProductBenefitCreateNestedManyWithoutBenefitInput = {
    create?: XOR<ProductBenefitCreateWithoutBenefitInput, ProductBenefitUncheckedCreateWithoutBenefitInput> | ProductBenefitCreateWithoutBenefitInput[] | ProductBenefitUncheckedCreateWithoutBenefitInput[]
    connectOrCreate?: ProductBenefitCreateOrConnectWithoutBenefitInput | ProductBenefitCreateOrConnectWithoutBenefitInput[]
    createMany?: ProductBenefitCreateManyBenefitInputEnvelope
    connect?: ProductBenefitWhereUniqueInput | ProductBenefitWhereUniqueInput[]
  }

  export type ProductBenefitUncheckedCreateNestedManyWithoutBenefitInput = {
    create?: XOR<ProductBenefitCreateWithoutBenefitInput, ProductBenefitUncheckedCreateWithoutBenefitInput> | ProductBenefitCreateWithoutBenefitInput[] | ProductBenefitUncheckedCreateWithoutBenefitInput[]
    connectOrCreate?: ProductBenefitCreateOrConnectWithoutBenefitInput | ProductBenefitCreateOrConnectWithoutBenefitInput[]
    createMany?: ProductBenefitCreateManyBenefitInputEnvelope
    connect?: ProductBenefitWhereUniqueInput | ProductBenefitWhereUniqueInput[]
  }

  export type ProductBenefitUpdateManyWithoutBenefitNestedInput = {
    create?: XOR<ProductBenefitCreateWithoutBenefitInput, ProductBenefitUncheckedCreateWithoutBenefitInput> | ProductBenefitCreateWithoutBenefitInput[] | ProductBenefitUncheckedCreateWithoutBenefitInput[]
    connectOrCreate?: ProductBenefitCreateOrConnectWithoutBenefitInput | ProductBenefitCreateOrConnectWithoutBenefitInput[]
    upsert?: ProductBenefitUpsertWithWhereUniqueWithoutBenefitInput | ProductBenefitUpsertWithWhereUniqueWithoutBenefitInput[]
    createMany?: ProductBenefitCreateManyBenefitInputEnvelope
    set?: ProductBenefitWhereUniqueInput | ProductBenefitWhereUniqueInput[]
    disconnect?: ProductBenefitWhereUniqueInput | ProductBenefitWhereUniqueInput[]
    delete?: ProductBenefitWhereUniqueInput | ProductBenefitWhereUniqueInput[]
    connect?: ProductBenefitWhereUniqueInput | ProductBenefitWhereUniqueInput[]
    update?: ProductBenefitUpdateWithWhereUniqueWithoutBenefitInput | ProductBenefitUpdateWithWhereUniqueWithoutBenefitInput[]
    updateMany?: ProductBenefitUpdateManyWithWhereWithoutBenefitInput | ProductBenefitUpdateManyWithWhereWithoutBenefitInput[]
    deleteMany?: ProductBenefitScalarWhereInput | ProductBenefitScalarWhereInput[]
  }

  export type ProductBenefitUncheckedUpdateManyWithoutBenefitNestedInput = {
    create?: XOR<ProductBenefitCreateWithoutBenefitInput, ProductBenefitUncheckedCreateWithoutBenefitInput> | ProductBenefitCreateWithoutBenefitInput[] | ProductBenefitUncheckedCreateWithoutBenefitInput[]
    connectOrCreate?: ProductBenefitCreateOrConnectWithoutBenefitInput | ProductBenefitCreateOrConnectWithoutBenefitInput[]
    upsert?: ProductBenefitUpsertWithWhereUniqueWithoutBenefitInput | ProductBenefitUpsertWithWhereUniqueWithoutBenefitInput[]
    createMany?: ProductBenefitCreateManyBenefitInputEnvelope
    set?: ProductBenefitWhereUniqueInput | ProductBenefitWhereUniqueInput[]
    disconnect?: ProductBenefitWhereUniqueInput | ProductBenefitWhereUniqueInput[]
    delete?: ProductBenefitWhereUniqueInput | ProductBenefitWhereUniqueInput[]
    connect?: ProductBenefitWhereUniqueInput | ProductBenefitWhereUniqueInput[]
    update?: ProductBenefitUpdateWithWhereUniqueWithoutBenefitInput | ProductBenefitUpdateWithWhereUniqueWithoutBenefitInput[]
    updateMany?: ProductBenefitUpdateManyWithWhereWithoutBenefitInput | ProductBenefitUpdateManyWithWhereWithoutBenefitInput[]
    deleteMany?: ProductBenefitScalarWhereInput | ProductBenefitScalarWhereInput[]
  }

  export type ProductCreateNestedOneWithoutBenefitsInput = {
    create?: XOR<ProductCreateWithoutBenefitsInput, ProductUncheckedCreateWithoutBenefitsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutBenefitsInput
    connect?: ProductWhereUniqueInput
  }

  export type BenefitCreateNestedOneWithoutProductsInput = {
    create?: XOR<BenefitCreateWithoutProductsInput, BenefitUncheckedCreateWithoutProductsInput>
    connectOrCreate?: BenefitCreateOrConnectWithoutProductsInput
    connect?: BenefitWhereUniqueInput
  }

  export type ProductUpdateOneRequiredWithoutBenefitsNestedInput = {
    create?: XOR<ProductCreateWithoutBenefitsInput, ProductUncheckedCreateWithoutBenefitsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutBenefitsInput
    upsert?: ProductUpsertWithoutBenefitsInput
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutBenefitsInput, ProductUpdateWithoutBenefitsInput>, ProductUncheckedUpdateWithoutBenefitsInput>
  }

  export type BenefitUpdateOneRequiredWithoutProductsNestedInput = {
    create?: XOR<BenefitCreateWithoutProductsInput, BenefitUncheckedCreateWithoutProductsInput>
    connectOrCreate?: BenefitCreateOrConnectWithoutProductsInput
    upsert?: BenefitUpsertWithoutProductsInput
    connect?: BenefitWhereUniqueInput
    update?: XOR<XOR<BenefitUpdateToOneWithWhereWithoutProductsInput, BenefitUpdateWithoutProductsInput>, BenefitUncheckedUpdateWithoutProductsInput>
  }

  export type ProductCreateNestedOneWithoutBenefitPointsInput = {
    create?: XOR<ProductCreateWithoutBenefitPointsInput, ProductUncheckedCreateWithoutBenefitPointsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutBenefitPointsInput
    connect?: ProductWhereUniqueInput
  }

  export type ProductUpdateOneRequiredWithoutBenefitPointsNestedInput = {
    create?: XOR<ProductCreateWithoutBenefitPointsInput, ProductUncheckedCreateWithoutBenefitPointsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutBenefitPointsInput
    upsert?: ProductUpsertWithoutBenefitPointsInput
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutBenefitPointsInput, ProductUpdateWithoutBenefitPointsInput>, ProductUncheckedUpdateWithoutBenefitPointsInput>
  }

  export type ProductCreateNestedManyWithoutPromotionsInput = {
    create?: XOR<ProductCreateWithoutPromotionsInput, ProductUncheckedCreateWithoutPromotionsInput> | ProductCreateWithoutPromotionsInput[] | ProductUncheckedCreateWithoutPromotionsInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutPromotionsInput | ProductCreateOrConnectWithoutPromotionsInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type ProductUncheckedCreateNestedManyWithoutPromotionsInput = {
    create?: XOR<ProductCreateWithoutPromotionsInput, ProductUncheckedCreateWithoutPromotionsInput> | ProductCreateWithoutPromotionsInput[] | ProductUncheckedCreateWithoutPromotionsInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutPromotionsInput | ProductCreateOrConnectWithoutPromotionsInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type EnumPromoTypeFieldUpdateOperationsInput = {
    set?: $Enums.PromoType
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type ProductUpdateManyWithoutPromotionsNestedInput = {
    create?: XOR<ProductCreateWithoutPromotionsInput, ProductUncheckedCreateWithoutPromotionsInput> | ProductCreateWithoutPromotionsInput[] | ProductUncheckedCreateWithoutPromotionsInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutPromotionsInput | ProductCreateOrConnectWithoutPromotionsInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutPromotionsInput | ProductUpsertWithWhereUniqueWithoutPromotionsInput[]
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutPromotionsInput | ProductUpdateWithWhereUniqueWithoutPromotionsInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutPromotionsInput | ProductUpdateManyWithWhereWithoutPromotionsInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type ProductUncheckedUpdateManyWithoutPromotionsNestedInput = {
    create?: XOR<ProductCreateWithoutPromotionsInput, ProductUncheckedCreateWithoutPromotionsInput> | ProductCreateWithoutPromotionsInput[] | ProductUncheckedCreateWithoutPromotionsInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutPromotionsInput | ProductCreateOrConnectWithoutPromotionsInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutPromotionsInput | ProductUpsertWithWhereUniqueWithoutPromotionsInput[]
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutPromotionsInput | ProductUpdateWithWhereUniqueWithoutPromotionsInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutPromotionsInput | ProductUpdateManyWithWhereWithoutPromotionsInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type ProductCreateNestedManyWithoutVouchersInput = {
    create?: XOR<ProductCreateWithoutVouchersInput, ProductUncheckedCreateWithoutVouchersInput> | ProductCreateWithoutVouchersInput[] | ProductUncheckedCreateWithoutVouchersInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutVouchersInput | ProductCreateOrConnectWithoutVouchersInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type VoucherUsageCreateNestedManyWithoutVoucherInput = {
    create?: XOR<VoucherUsageCreateWithoutVoucherInput, VoucherUsageUncheckedCreateWithoutVoucherInput> | VoucherUsageCreateWithoutVoucherInput[] | VoucherUsageUncheckedCreateWithoutVoucherInput[]
    connectOrCreate?: VoucherUsageCreateOrConnectWithoutVoucherInput | VoucherUsageCreateOrConnectWithoutVoucherInput[]
    createMany?: VoucherUsageCreateManyVoucherInputEnvelope
    connect?: VoucherUsageWhereUniqueInput | VoucherUsageWhereUniqueInput[]
  }

  export type OrderCreateNestedManyWithoutVoucherInput = {
    create?: XOR<OrderCreateWithoutVoucherInput, OrderUncheckedCreateWithoutVoucherInput> | OrderCreateWithoutVoucherInput[] | OrderUncheckedCreateWithoutVoucherInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutVoucherInput | OrderCreateOrConnectWithoutVoucherInput[]
    createMany?: OrderCreateManyVoucherInputEnvelope
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
  }

  export type ProductUncheckedCreateNestedManyWithoutVouchersInput = {
    create?: XOR<ProductCreateWithoutVouchersInput, ProductUncheckedCreateWithoutVouchersInput> | ProductCreateWithoutVouchersInput[] | ProductUncheckedCreateWithoutVouchersInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutVouchersInput | ProductCreateOrConnectWithoutVouchersInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type VoucherUsageUncheckedCreateNestedManyWithoutVoucherInput = {
    create?: XOR<VoucherUsageCreateWithoutVoucherInput, VoucherUsageUncheckedCreateWithoutVoucherInput> | VoucherUsageCreateWithoutVoucherInput[] | VoucherUsageUncheckedCreateWithoutVoucherInput[]
    connectOrCreate?: VoucherUsageCreateOrConnectWithoutVoucherInput | VoucherUsageCreateOrConnectWithoutVoucherInput[]
    createMany?: VoucherUsageCreateManyVoucherInputEnvelope
    connect?: VoucherUsageWhereUniqueInput | VoucherUsageWhereUniqueInput[]
  }

  export type OrderUncheckedCreateNestedManyWithoutVoucherInput = {
    create?: XOR<OrderCreateWithoutVoucherInput, OrderUncheckedCreateWithoutVoucherInput> | OrderCreateWithoutVoucherInput[] | OrderUncheckedCreateWithoutVoucherInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutVoucherInput | OrderCreateOrConnectWithoutVoucherInput[]
    createMany?: OrderCreateManyVoucherInputEnvelope
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
  }

  export type ProductUpdateManyWithoutVouchersNestedInput = {
    create?: XOR<ProductCreateWithoutVouchersInput, ProductUncheckedCreateWithoutVouchersInput> | ProductCreateWithoutVouchersInput[] | ProductUncheckedCreateWithoutVouchersInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutVouchersInput | ProductCreateOrConnectWithoutVouchersInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutVouchersInput | ProductUpsertWithWhereUniqueWithoutVouchersInput[]
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutVouchersInput | ProductUpdateWithWhereUniqueWithoutVouchersInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutVouchersInput | ProductUpdateManyWithWhereWithoutVouchersInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type VoucherUsageUpdateManyWithoutVoucherNestedInput = {
    create?: XOR<VoucherUsageCreateWithoutVoucherInput, VoucherUsageUncheckedCreateWithoutVoucherInput> | VoucherUsageCreateWithoutVoucherInput[] | VoucherUsageUncheckedCreateWithoutVoucherInput[]
    connectOrCreate?: VoucherUsageCreateOrConnectWithoutVoucherInput | VoucherUsageCreateOrConnectWithoutVoucherInput[]
    upsert?: VoucherUsageUpsertWithWhereUniqueWithoutVoucherInput | VoucherUsageUpsertWithWhereUniqueWithoutVoucherInput[]
    createMany?: VoucherUsageCreateManyVoucherInputEnvelope
    set?: VoucherUsageWhereUniqueInput | VoucherUsageWhereUniqueInput[]
    disconnect?: VoucherUsageWhereUniqueInput | VoucherUsageWhereUniqueInput[]
    delete?: VoucherUsageWhereUniqueInput | VoucherUsageWhereUniqueInput[]
    connect?: VoucherUsageWhereUniqueInput | VoucherUsageWhereUniqueInput[]
    update?: VoucherUsageUpdateWithWhereUniqueWithoutVoucherInput | VoucherUsageUpdateWithWhereUniqueWithoutVoucherInput[]
    updateMany?: VoucherUsageUpdateManyWithWhereWithoutVoucherInput | VoucherUsageUpdateManyWithWhereWithoutVoucherInput[]
    deleteMany?: VoucherUsageScalarWhereInput | VoucherUsageScalarWhereInput[]
  }

  export type OrderUpdateManyWithoutVoucherNestedInput = {
    create?: XOR<OrderCreateWithoutVoucherInput, OrderUncheckedCreateWithoutVoucherInput> | OrderCreateWithoutVoucherInput[] | OrderUncheckedCreateWithoutVoucherInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutVoucherInput | OrderCreateOrConnectWithoutVoucherInput[]
    upsert?: OrderUpsertWithWhereUniqueWithoutVoucherInput | OrderUpsertWithWhereUniqueWithoutVoucherInput[]
    createMany?: OrderCreateManyVoucherInputEnvelope
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    update?: OrderUpdateWithWhereUniqueWithoutVoucherInput | OrderUpdateWithWhereUniqueWithoutVoucherInput[]
    updateMany?: OrderUpdateManyWithWhereWithoutVoucherInput | OrderUpdateManyWithWhereWithoutVoucherInput[]
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[]
  }

  export type ProductUncheckedUpdateManyWithoutVouchersNestedInput = {
    create?: XOR<ProductCreateWithoutVouchersInput, ProductUncheckedCreateWithoutVouchersInput> | ProductCreateWithoutVouchersInput[] | ProductUncheckedCreateWithoutVouchersInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutVouchersInput | ProductCreateOrConnectWithoutVouchersInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutVouchersInput | ProductUpsertWithWhereUniqueWithoutVouchersInput[]
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutVouchersInput | ProductUpdateWithWhereUniqueWithoutVouchersInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutVouchersInput | ProductUpdateManyWithWhereWithoutVouchersInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type VoucherUsageUncheckedUpdateManyWithoutVoucherNestedInput = {
    create?: XOR<VoucherUsageCreateWithoutVoucherInput, VoucherUsageUncheckedCreateWithoutVoucherInput> | VoucherUsageCreateWithoutVoucherInput[] | VoucherUsageUncheckedCreateWithoutVoucherInput[]
    connectOrCreate?: VoucherUsageCreateOrConnectWithoutVoucherInput | VoucherUsageCreateOrConnectWithoutVoucherInput[]
    upsert?: VoucherUsageUpsertWithWhereUniqueWithoutVoucherInput | VoucherUsageUpsertWithWhereUniqueWithoutVoucherInput[]
    createMany?: VoucherUsageCreateManyVoucherInputEnvelope
    set?: VoucherUsageWhereUniqueInput | VoucherUsageWhereUniqueInput[]
    disconnect?: VoucherUsageWhereUniqueInput | VoucherUsageWhereUniqueInput[]
    delete?: VoucherUsageWhereUniqueInput | VoucherUsageWhereUniqueInput[]
    connect?: VoucherUsageWhereUniqueInput | VoucherUsageWhereUniqueInput[]
    update?: VoucherUsageUpdateWithWhereUniqueWithoutVoucherInput | VoucherUsageUpdateWithWhereUniqueWithoutVoucherInput[]
    updateMany?: VoucherUsageUpdateManyWithWhereWithoutVoucherInput | VoucherUsageUpdateManyWithWhereWithoutVoucherInput[]
    deleteMany?: VoucherUsageScalarWhereInput | VoucherUsageScalarWhereInput[]
  }

  export type OrderUncheckedUpdateManyWithoutVoucherNestedInput = {
    create?: XOR<OrderCreateWithoutVoucherInput, OrderUncheckedCreateWithoutVoucherInput> | OrderCreateWithoutVoucherInput[] | OrderUncheckedCreateWithoutVoucherInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutVoucherInput | OrderCreateOrConnectWithoutVoucherInput[]
    upsert?: OrderUpsertWithWhereUniqueWithoutVoucherInput | OrderUpsertWithWhereUniqueWithoutVoucherInput[]
    createMany?: OrderCreateManyVoucherInputEnvelope
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    update?: OrderUpdateWithWhereUniqueWithoutVoucherInput | OrderUpdateWithWhereUniqueWithoutVoucherInput[]
    updateMany?: OrderUpdateManyWithWhereWithoutVoucherInput | OrderUpdateManyWithWhereWithoutVoucherInput[]
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[]
  }

  export type VoucherCreateNestedOneWithoutUsagesInput = {
    create?: XOR<VoucherCreateWithoutUsagesInput, VoucherUncheckedCreateWithoutUsagesInput>
    connectOrCreate?: VoucherCreateOrConnectWithoutUsagesInput
    connect?: VoucherWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutVouchersInput = {
    create?: XOR<UserCreateWithoutVouchersInput, UserUncheckedCreateWithoutVouchersInput>
    connectOrCreate?: UserCreateOrConnectWithoutVouchersInput
    connect?: UserWhereUniqueInput
  }

  export type VoucherUpdateOneRequiredWithoutUsagesNestedInput = {
    create?: XOR<VoucherCreateWithoutUsagesInput, VoucherUncheckedCreateWithoutUsagesInput>
    connectOrCreate?: VoucherCreateOrConnectWithoutUsagesInput
    upsert?: VoucherUpsertWithoutUsagesInput
    connect?: VoucherWhereUniqueInput
    update?: XOR<XOR<VoucherUpdateToOneWithWhereWithoutUsagesInput, VoucherUpdateWithoutUsagesInput>, VoucherUncheckedUpdateWithoutUsagesInput>
  }

  export type UserUpdateOneRequiredWithoutVouchersNestedInput = {
    create?: XOR<UserCreateWithoutVouchersInput, UserUncheckedCreateWithoutVouchersInput>
    connectOrCreate?: UserCreateOrConnectWithoutVouchersInput
    upsert?: UserUpsertWithoutVouchersInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutVouchersInput, UserUpdateWithoutVouchersInput>, UserUncheckedUpdateWithoutVouchersInput>
  }

  export type OrderCreateNestedManyWithoutUserInput = {
    create?: XOR<OrderCreateWithoutUserInput, OrderUncheckedCreateWithoutUserInput> | OrderCreateWithoutUserInput[] | OrderUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutUserInput | OrderCreateOrConnectWithoutUserInput[]
    createMany?: OrderCreateManyUserInputEnvelope
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
  }

  export type AccountCreateNestedManyWithoutUserInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
  }

  export type SessionCreateNestedManyWithoutUserInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type VoucherUsageCreateNestedManyWithoutUserInput = {
    create?: XOR<VoucherUsageCreateWithoutUserInput, VoucherUsageUncheckedCreateWithoutUserInput> | VoucherUsageCreateWithoutUserInput[] | VoucherUsageUncheckedCreateWithoutUserInput[]
    connectOrCreate?: VoucherUsageCreateOrConnectWithoutUserInput | VoucherUsageCreateOrConnectWithoutUserInput[]
    createMany?: VoucherUsageCreateManyUserInputEnvelope
    connect?: VoucherUsageWhereUniqueInput | VoucherUsageWhereUniqueInput[]
  }

  export type AuthenticatorCreateNestedManyWithoutUserInput = {
    create?: XOR<AuthenticatorCreateWithoutUserInput, AuthenticatorUncheckedCreateWithoutUserInput> | AuthenticatorCreateWithoutUserInput[] | AuthenticatorUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuthenticatorCreateOrConnectWithoutUserInput | AuthenticatorCreateOrConnectWithoutUserInput[]
    createMany?: AuthenticatorCreateManyUserInputEnvelope
    connect?: AuthenticatorWhereUniqueInput | AuthenticatorWhereUniqueInput[]
  }

  export type OrderUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<OrderCreateWithoutUserInput, OrderUncheckedCreateWithoutUserInput> | OrderCreateWithoutUserInput[] | OrderUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutUserInput | OrderCreateOrConnectWithoutUserInput[]
    createMany?: OrderCreateManyUserInputEnvelope
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
  }

  export type AccountUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
  }

  export type SessionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type VoucherUsageUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<VoucherUsageCreateWithoutUserInput, VoucherUsageUncheckedCreateWithoutUserInput> | VoucherUsageCreateWithoutUserInput[] | VoucherUsageUncheckedCreateWithoutUserInput[]
    connectOrCreate?: VoucherUsageCreateOrConnectWithoutUserInput | VoucherUsageCreateOrConnectWithoutUserInput[]
    createMany?: VoucherUsageCreateManyUserInputEnvelope
    connect?: VoucherUsageWhereUniqueInput | VoucherUsageWhereUniqueInput[]
  }

  export type AuthenticatorUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AuthenticatorCreateWithoutUserInput, AuthenticatorUncheckedCreateWithoutUserInput> | AuthenticatorCreateWithoutUserInput[] | AuthenticatorUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuthenticatorCreateOrConnectWithoutUserInput | AuthenticatorCreateOrConnectWithoutUserInput[]
    createMany?: AuthenticatorCreateManyUserInputEnvelope
    connect?: AuthenticatorWhereUniqueInput | AuthenticatorWhereUniqueInput[]
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type EnumUserRoleFieldUpdateOperationsInput = {
    set?: $Enums.UserRole
  }

  export type OrderUpdateManyWithoutUserNestedInput = {
    create?: XOR<OrderCreateWithoutUserInput, OrderUncheckedCreateWithoutUserInput> | OrderCreateWithoutUserInput[] | OrderUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutUserInput | OrderCreateOrConnectWithoutUserInput[]
    upsert?: OrderUpsertWithWhereUniqueWithoutUserInput | OrderUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: OrderCreateManyUserInputEnvelope
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    update?: OrderUpdateWithWhereUniqueWithoutUserInput | OrderUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: OrderUpdateManyWithWhereWithoutUserInput | OrderUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[]
  }

  export type AccountUpdateManyWithoutUserNestedInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    upsert?: AccountUpsertWithWhereUniqueWithoutUserInput | AccountUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    set?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    disconnect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    delete?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    update?: AccountUpdateWithWhereUniqueWithoutUserInput | AccountUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AccountUpdateManyWithWhereWithoutUserInput | AccountUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AccountScalarWhereInput | AccountScalarWhereInput[]
  }

  export type SessionUpdateManyWithoutUserNestedInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutUserInput | SessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutUserInput | SessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutUserInput | SessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type VoucherUsageUpdateManyWithoutUserNestedInput = {
    create?: XOR<VoucherUsageCreateWithoutUserInput, VoucherUsageUncheckedCreateWithoutUserInput> | VoucherUsageCreateWithoutUserInput[] | VoucherUsageUncheckedCreateWithoutUserInput[]
    connectOrCreate?: VoucherUsageCreateOrConnectWithoutUserInput | VoucherUsageCreateOrConnectWithoutUserInput[]
    upsert?: VoucherUsageUpsertWithWhereUniqueWithoutUserInput | VoucherUsageUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: VoucherUsageCreateManyUserInputEnvelope
    set?: VoucherUsageWhereUniqueInput | VoucherUsageWhereUniqueInput[]
    disconnect?: VoucherUsageWhereUniqueInput | VoucherUsageWhereUniqueInput[]
    delete?: VoucherUsageWhereUniqueInput | VoucherUsageWhereUniqueInput[]
    connect?: VoucherUsageWhereUniqueInput | VoucherUsageWhereUniqueInput[]
    update?: VoucherUsageUpdateWithWhereUniqueWithoutUserInput | VoucherUsageUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: VoucherUsageUpdateManyWithWhereWithoutUserInput | VoucherUsageUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: VoucherUsageScalarWhereInput | VoucherUsageScalarWhereInput[]
  }

  export type AuthenticatorUpdateManyWithoutUserNestedInput = {
    create?: XOR<AuthenticatorCreateWithoutUserInput, AuthenticatorUncheckedCreateWithoutUserInput> | AuthenticatorCreateWithoutUserInput[] | AuthenticatorUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuthenticatorCreateOrConnectWithoutUserInput | AuthenticatorCreateOrConnectWithoutUserInput[]
    upsert?: AuthenticatorUpsertWithWhereUniqueWithoutUserInput | AuthenticatorUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AuthenticatorCreateManyUserInputEnvelope
    set?: AuthenticatorWhereUniqueInput | AuthenticatorWhereUniqueInput[]
    disconnect?: AuthenticatorWhereUniqueInput | AuthenticatorWhereUniqueInput[]
    delete?: AuthenticatorWhereUniqueInput | AuthenticatorWhereUniqueInput[]
    connect?: AuthenticatorWhereUniqueInput | AuthenticatorWhereUniqueInput[]
    update?: AuthenticatorUpdateWithWhereUniqueWithoutUserInput | AuthenticatorUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AuthenticatorUpdateManyWithWhereWithoutUserInput | AuthenticatorUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AuthenticatorScalarWhereInput | AuthenticatorScalarWhereInput[]
  }

  export type OrderUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<OrderCreateWithoutUserInput, OrderUncheckedCreateWithoutUserInput> | OrderCreateWithoutUserInput[] | OrderUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutUserInput | OrderCreateOrConnectWithoutUserInput[]
    upsert?: OrderUpsertWithWhereUniqueWithoutUserInput | OrderUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: OrderCreateManyUserInputEnvelope
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    update?: OrderUpdateWithWhereUniqueWithoutUserInput | OrderUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: OrderUpdateManyWithWhereWithoutUserInput | OrderUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[]
  }

  export type AccountUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    upsert?: AccountUpsertWithWhereUniqueWithoutUserInput | AccountUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    set?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    disconnect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    delete?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    update?: AccountUpdateWithWhereUniqueWithoutUserInput | AccountUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AccountUpdateManyWithWhereWithoutUserInput | AccountUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AccountScalarWhereInput | AccountScalarWhereInput[]
  }

  export type SessionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutUserInput | SessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutUserInput | SessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutUserInput | SessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type VoucherUsageUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<VoucherUsageCreateWithoutUserInput, VoucherUsageUncheckedCreateWithoutUserInput> | VoucherUsageCreateWithoutUserInput[] | VoucherUsageUncheckedCreateWithoutUserInput[]
    connectOrCreate?: VoucherUsageCreateOrConnectWithoutUserInput | VoucherUsageCreateOrConnectWithoutUserInput[]
    upsert?: VoucherUsageUpsertWithWhereUniqueWithoutUserInput | VoucherUsageUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: VoucherUsageCreateManyUserInputEnvelope
    set?: VoucherUsageWhereUniqueInput | VoucherUsageWhereUniqueInput[]
    disconnect?: VoucherUsageWhereUniqueInput | VoucherUsageWhereUniqueInput[]
    delete?: VoucherUsageWhereUniqueInput | VoucherUsageWhereUniqueInput[]
    connect?: VoucherUsageWhereUniqueInput | VoucherUsageWhereUniqueInput[]
    update?: VoucherUsageUpdateWithWhereUniqueWithoutUserInput | VoucherUsageUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: VoucherUsageUpdateManyWithWhereWithoutUserInput | VoucherUsageUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: VoucherUsageScalarWhereInput | VoucherUsageScalarWhereInput[]
  }

  export type AuthenticatorUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AuthenticatorCreateWithoutUserInput, AuthenticatorUncheckedCreateWithoutUserInput> | AuthenticatorCreateWithoutUserInput[] | AuthenticatorUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuthenticatorCreateOrConnectWithoutUserInput | AuthenticatorCreateOrConnectWithoutUserInput[]
    upsert?: AuthenticatorUpsertWithWhereUniqueWithoutUserInput | AuthenticatorUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AuthenticatorCreateManyUserInputEnvelope
    set?: AuthenticatorWhereUniqueInput | AuthenticatorWhereUniqueInput[]
    disconnect?: AuthenticatorWhereUniqueInput | AuthenticatorWhereUniqueInput[]
    delete?: AuthenticatorWhereUniqueInput | AuthenticatorWhereUniqueInput[]
    connect?: AuthenticatorWhereUniqueInput | AuthenticatorWhereUniqueInput[]
    update?: AuthenticatorUpdateWithWhereUniqueWithoutUserInput | AuthenticatorUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AuthenticatorUpdateManyWithWhereWithoutUserInput | AuthenticatorUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AuthenticatorScalarWhereInput | AuthenticatorScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutAuthenticatorInput = {
    create?: XOR<UserCreateWithoutAuthenticatorInput, UserUncheckedCreateWithoutAuthenticatorInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuthenticatorInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutAuthenticatorNestedInput = {
    create?: XOR<UserCreateWithoutAuthenticatorInput, UserUncheckedCreateWithoutAuthenticatorInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuthenticatorInput
    upsert?: UserUpsertWithoutAuthenticatorInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAuthenticatorInput, UserUpdateWithoutAuthenticatorInput>, UserUncheckedUpdateWithoutAuthenticatorInput>
  }

  export type UserCreateNestedOneWithoutOrdersInput = {
    create?: XOR<UserCreateWithoutOrdersInput, UserUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: UserCreateOrConnectWithoutOrdersInput
    connect?: UserWhereUniqueInput
  }

  export type ProductCreateNestedManyWithoutOrdersInput = {
    create?: XOR<ProductCreateWithoutOrdersInput, ProductUncheckedCreateWithoutOrdersInput> | ProductCreateWithoutOrdersInput[] | ProductUncheckedCreateWithoutOrdersInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutOrdersInput | ProductCreateOrConnectWithoutOrdersInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type VoucherCreateNestedOneWithoutOrdersInput = {
    create?: XOR<VoucherCreateWithoutOrdersInput, VoucherUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: VoucherCreateOrConnectWithoutOrdersInput
    connect?: VoucherWhereUniqueInput
  }

  export type ProductUncheckedCreateNestedManyWithoutOrdersInput = {
    create?: XOR<ProductCreateWithoutOrdersInput, ProductUncheckedCreateWithoutOrdersInput> | ProductCreateWithoutOrdersInput[] | ProductUncheckedCreateWithoutOrdersInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutOrdersInput | ProductCreateOrConnectWithoutOrdersInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type EnumOrderStatusFieldUpdateOperationsInput = {
    set?: $Enums.OrderStatus
  }

  export type UserUpdateOneWithoutOrdersNestedInput = {
    create?: XOR<UserCreateWithoutOrdersInput, UserUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: UserCreateOrConnectWithoutOrdersInput
    upsert?: UserUpsertWithoutOrdersInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutOrdersInput, UserUpdateWithoutOrdersInput>, UserUncheckedUpdateWithoutOrdersInput>
  }

  export type ProductUpdateManyWithoutOrdersNestedInput = {
    create?: XOR<ProductCreateWithoutOrdersInput, ProductUncheckedCreateWithoutOrdersInput> | ProductCreateWithoutOrdersInput[] | ProductUncheckedCreateWithoutOrdersInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutOrdersInput | ProductCreateOrConnectWithoutOrdersInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutOrdersInput | ProductUpsertWithWhereUniqueWithoutOrdersInput[]
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutOrdersInput | ProductUpdateWithWhereUniqueWithoutOrdersInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutOrdersInput | ProductUpdateManyWithWhereWithoutOrdersInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type VoucherUpdateOneWithoutOrdersNestedInput = {
    create?: XOR<VoucherCreateWithoutOrdersInput, VoucherUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: VoucherCreateOrConnectWithoutOrdersInput
    upsert?: VoucherUpsertWithoutOrdersInput
    disconnect?: VoucherWhereInput | boolean
    delete?: VoucherWhereInput | boolean
    connect?: VoucherWhereUniqueInput
    update?: XOR<XOR<VoucherUpdateToOneWithWhereWithoutOrdersInput, VoucherUpdateWithoutOrdersInput>, VoucherUncheckedUpdateWithoutOrdersInput>
  }

  export type ProductUncheckedUpdateManyWithoutOrdersNestedInput = {
    create?: XOR<ProductCreateWithoutOrdersInput, ProductUncheckedCreateWithoutOrdersInput> | ProductCreateWithoutOrdersInput[] | ProductUncheckedCreateWithoutOrdersInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutOrdersInput | ProductCreateOrConnectWithoutOrdersInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutOrdersInput | ProductUpsertWithWhereUniqueWithoutOrdersInput[]
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutOrdersInput | ProductUpdateWithWhereUniqueWithoutOrdersInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutOrdersInput | ProductUpdateManyWithWhereWithoutOrdersInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type MenuCreateNestedOneWithoutChildrenInput = {
    create?: XOR<MenuCreateWithoutChildrenInput, MenuUncheckedCreateWithoutChildrenInput>
    connectOrCreate?: MenuCreateOrConnectWithoutChildrenInput
    connect?: MenuWhereUniqueInput
  }

  export type MenuCreateNestedManyWithoutParentInput = {
    create?: XOR<MenuCreateWithoutParentInput, MenuUncheckedCreateWithoutParentInput> | MenuCreateWithoutParentInput[] | MenuUncheckedCreateWithoutParentInput[]
    connectOrCreate?: MenuCreateOrConnectWithoutParentInput | MenuCreateOrConnectWithoutParentInput[]
    createMany?: MenuCreateManyParentInputEnvelope
    connect?: MenuWhereUniqueInput | MenuWhereUniqueInput[]
  }

  export type MenuUncheckedCreateNestedManyWithoutParentInput = {
    create?: XOR<MenuCreateWithoutParentInput, MenuUncheckedCreateWithoutParentInput> | MenuCreateWithoutParentInput[] | MenuUncheckedCreateWithoutParentInput[]
    connectOrCreate?: MenuCreateOrConnectWithoutParentInput | MenuCreateOrConnectWithoutParentInput[]
    createMany?: MenuCreateManyParentInputEnvelope
    connect?: MenuWhereUniqueInput | MenuWhereUniqueInput[]
  }

  export type EnumMenuTypeFieldUpdateOperationsInput = {
    set?: $Enums.MenuType
  }

  export type MenuUpdateOneWithoutChildrenNestedInput = {
    create?: XOR<MenuCreateWithoutChildrenInput, MenuUncheckedCreateWithoutChildrenInput>
    connectOrCreate?: MenuCreateOrConnectWithoutChildrenInput
    upsert?: MenuUpsertWithoutChildrenInput
    disconnect?: MenuWhereInput | boolean
    delete?: MenuWhereInput | boolean
    connect?: MenuWhereUniqueInput
    update?: XOR<XOR<MenuUpdateToOneWithWhereWithoutChildrenInput, MenuUpdateWithoutChildrenInput>, MenuUncheckedUpdateWithoutChildrenInput>
  }

  export type MenuUpdateManyWithoutParentNestedInput = {
    create?: XOR<MenuCreateWithoutParentInput, MenuUncheckedCreateWithoutParentInput> | MenuCreateWithoutParentInput[] | MenuUncheckedCreateWithoutParentInput[]
    connectOrCreate?: MenuCreateOrConnectWithoutParentInput | MenuCreateOrConnectWithoutParentInput[]
    upsert?: MenuUpsertWithWhereUniqueWithoutParentInput | MenuUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: MenuCreateManyParentInputEnvelope
    set?: MenuWhereUniqueInput | MenuWhereUniqueInput[]
    disconnect?: MenuWhereUniqueInput | MenuWhereUniqueInput[]
    delete?: MenuWhereUniqueInput | MenuWhereUniqueInput[]
    connect?: MenuWhereUniqueInput | MenuWhereUniqueInput[]
    update?: MenuUpdateWithWhereUniqueWithoutParentInput | MenuUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: MenuUpdateManyWithWhereWithoutParentInput | MenuUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: MenuScalarWhereInput | MenuScalarWhereInput[]
  }

  export type MenuUncheckedUpdateManyWithoutParentNestedInput = {
    create?: XOR<MenuCreateWithoutParentInput, MenuUncheckedCreateWithoutParentInput> | MenuCreateWithoutParentInput[] | MenuUncheckedCreateWithoutParentInput[]
    connectOrCreate?: MenuCreateOrConnectWithoutParentInput | MenuCreateOrConnectWithoutParentInput[]
    upsert?: MenuUpsertWithWhereUniqueWithoutParentInput | MenuUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: MenuCreateManyParentInputEnvelope
    set?: MenuWhereUniqueInput | MenuWhereUniqueInput[]
    disconnect?: MenuWhereUniqueInput | MenuWhereUniqueInput[]
    delete?: MenuWhereUniqueInput | MenuWhereUniqueInput[]
    connect?: MenuWhereUniqueInput | MenuWhereUniqueInput[]
    update?: MenuUpdateWithWhereUniqueWithoutParentInput | MenuUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: MenuUpdateManyWithWhereWithoutParentInput | MenuUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: MenuScalarWhereInput | MenuScalarWhereInput[]
  }

  export type EnumFooterInfoTypeFieldUpdateOperationsInput = {
    set?: $Enums.FooterInfoType
  }

  export type UserCreateNestedOneWithoutAccountsInput = {
    create?: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAccountsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutAccountsNestedInput = {
    create?: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAccountsInput
    upsert?: UserUpsertWithoutAccountsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAccountsInput, UserUpdateWithoutAccountsInput>, UserUncheckedUpdateWithoutAccountsInput>
  }

  export type UserCreateNestedOneWithoutSessionsInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutSessionsNestedInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    upsert?: UserUpsertWithoutSessionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSessionsInput, UserUpdateWithoutSessionsInput>, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type LpForCreateNestedManyWithoutLandingPagesInput = {
    create?: XOR<LpForCreateWithoutLandingPagesInput, LpForUncheckedCreateWithoutLandingPagesInput> | LpForCreateWithoutLandingPagesInput[] | LpForUncheckedCreateWithoutLandingPagesInput[]
    connectOrCreate?: LpForCreateOrConnectWithoutLandingPagesInput | LpForCreateOrConnectWithoutLandingPagesInput[]
    connect?: LpForWhereUniqueInput | LpForWhereUniqueInput[]
  }

  export type LpContentTypeCreateNestedManyWithoutLandingPagesInput = {
    create?: XOR<LpContentTypeCreateWithoutLandingPagesInput, LpContentTypeUncheckedCreateWithoutLandingPagesInput> | LpContentTypeCreateWithoutLandingPagesInput[] | LpContentTypeUncheckedCreateWithoutLandingPagesInput[]
    connectOrCreate?: LpContentTypeCreateOrConnectWithoutLandingPagesInput | LpContentTypeCreateOrConnectWithoutLandingPagesInput[]
    connect?: LpContentTypeWhereUniqueInput | LpContentTypeWhereUniqueInput[]
  }

  export type LpDesignStyleCreateNestedOneWithoutTemplatesInput = {
    create?: XOR<LpDesignStyleCreateWithoutTemplatesInput, LpDesignStyleUncheckedCreateWithoutTemplatesInput>
    connectOrCreate?: LpDesignStyleCreateOrConnectWithoutTemplatesInput
    connect?: LpDesignStyleWhereUniqueInput
  }

  export type LpForUncheckedCreateNestedManyWithoutLandingPagesInput = {
    create?: XOR<LpForCreateWithoutLandingPagesInput, LpForUncheckedCreateWithoutLandingPagesInput> | LpForCreateWithoutLandingPagesInput[] | LpForUncheckedCreateWithoutLandingPagesInput[]
    connectOrCreate?: LpForCreateOrConnectWithoutLandingPagesInput | LpForCreateOrConnectWithoutLandingPagesInput[]
    connect?: LpForWhereUniqueInput | LpForWhereUniqueInput[]
  }

  export type LpContentTypeUncheckedCreateNestedManyWithoutLandingPagesInput = {
    create?: XOR<LpContentTypeCreateWithoutLandingPagesInput, LpContentTypeUncheckedCreateWithoutLandingPagesInput> | LpContentTypeCreateWithoutLandingPagesInput[] | LpContentTypeUncheckedCreateWithoutLandingPagesInput[]
    connectOrCreate?: LpContentTypeCreateOrConnectWithoutLandingPagesInput | LpContentTypeCreateOrConnectWithoutLandingPagesInput[]
    connect?: LpContentTypeWhereUniqueInput | LpContentTypeWhereUniqueInput[]
  }

  export type LpForUpdateManyWithoutLandingPagesNestedInput = {
    create?: XOR<LpForCreateWithoutLandingPagesInput, LpForUncheckedCreateWithoutLandingPagesInput> | LpForCreateWithoutLandingPagesInput[] | LpForUncheckedCreateWithoutLandingPagesInput[]
    connectOrCreate?: LpForCreateOrConnectWithoutLandingPagesInput | LpForCreateOrConnectWithoutLandingPagesInput[]
    upsert?: LpForUpsertWithWhereUniqueWithoutLandingPagesInput | LpForUpsertWithWhereUniqueWithoutLandingPagesInput[]
    set?: LpForWhereUniqueInput | LpForWhereUniqueInput[]
    disconnect?: LpForWhereUniqueInput | LpForWhereUniqueInput[]
    delete?: LpForWhereUniqueInput | LpForWhereUniqueInput[]
    connect?: LpForWhereUniqueInput | LpForWhereUniqueInput[]
    update?: LpForUpdateWithWhereUniqueWithoutLandingPagesInput | LpForUpdateWithWhereUniqueWithoutLandingPagesInput[]
    updateMany?: LpForUpdateManyWithWhereWithoutLandingPagesInput | LpForUpdateManyWithWhereWithoutLandingPagesInput[]
    deleteMany?: LpForScalarWhereInput | LpForScalarWhereInput[]
  }

  export type LpContentTypeUpdateManyWithoutLandingPagesNestedInput = {
    create?: XOR<LpContentTypeCreateWithoutLandingPagesInput, LpContentTypeUncheckedCreateWithoutLandingPagesInput> | LpContentTypeCreateWithoutLandingPagesInput[] | LpContentTypeUncheckedCreateWithoutLandingPagesInput[]
    connectOrCreate?: LpContentTypeCreateOrConnectWithoutLandingPagesInput | LpContentTypeCreateOrConnectWithoutLandingPagesInput[]
    upsert?: LpContentTypeUpsertWithWhereUniqueWithoutLandingPagesInput | LpContentTypeUpsertWithWhereUniqueWithoutLandingPagesInput[]
    set?: LpContentTypeWhereUniqueInput | LpContentTypeWhereUniqueInput[]
    disconnect?: LpContentTypeWhereUniqueInput | LpContentTypeWhereUniqueInput[]
    delete?: LpContentTypeWhereUniqueInput | LpContentTypeWhereUniqueInput[]
    connect?: LpContentTypeWhereUniqueInput | LpContentTypeWhereUniqueInput[]
    update?: LpContentTypeUpdateWithWhereUniqueWithoutLandingPagesInput | LpContentTypeUpdateWithWhereUniqueWithoutLandingPagesInput[]
    updateMany?: LpContentTypeUpdateManyWithWhereWithoutLandingPagesInput | LpContentTypeUpdateManyWithWhereWithoutLandingPagesInput[]
    deleteMany?: LpContentTypeScalarWhereInput | LpContentTypeScalarWhereInput[]
  }

  export type LpDesignStyleUpdateOneWithoutTemplatesNestedInput = {
    create?: XOR<LpDesignStyleCreateWithoutTemplatesInput, LpDesignStyleUncheckedCreateWithoutTemplatesInput>
    connectOrCreate?: LpDesignStyleCreateOrConnectWithoutTemplatesInput
    upsert?: LpDesignStyleUpsertWithoutTemplatesInput
    disconnect?: LpDesignStyleWhereInput | boolean
    delete?: LpDesignStyleWhereInput | boolean
    connect?: LpDesignStyleWhereUniqueInput
    update?: XOR<XOR<LpDesignStyleUpdateToOneWithWhereWithoutTemplatesInput, LpDesignStyleUpdateWithoutTemplatesInput>, LpDesignStyleUncheckedUpdateWithoutTemplatesInput>
  }

  export type LpForUncheckedUpdateManyWithoutLandingPagesNestedInput = {
    create?: XOR<LpForCreateWithoutLandingPagesInput, LpForUncheckedCreateWithoutLandingPagesInput> | LpForCreateWithoutLandingPagesInput[] | LpForUncheckedCreateWithoutLandingPagesInput[]
    connectOrCreate?: LpForCreateOrConnectWithoutLandingPagesInput | LpForCreateOrConnectWithoutLandingPagesInput[]
    upsert?: LpForUpsertWithWhereUniqueWithoutLandingPagesInput | LpForUpsertWithWhereUniqueWithoutLandingPagesInput[]
    set?: LpForWhereUniqueInput | LpForWhereUniqueInput[]
    disconnect?: LpForWhereUniqueInput | LpForWhereUniqueInput[]
    delete?: LpForWhereUniqueInput | LpForWhereUniqueInput[]
    connect?: LpForWhereUniqueInput | LpForWhereUniqueInput[]
    update?: LpForUpdateWithWhereUniqueWithoutLandingPagesInput | LpForUpdateWithWhereUniqueWithoutLandingPagesInput[]
    updateMany?: LpForUpdateManyWithWhereWithoutLandingPagesInput | LpForUpdateManyWithWhereWithoutLandingPagesInput[]
    deleteMany?: LpForScalarWhereInput | LpForScalarWhereInput[]
  }

  export type LpContentTypeUncheckedUpdateManyWithoutLandingPagesNestedInput = {
    create?: XOR<LpContentTypeCreateWithoutLandingPagesInput, LpContentTypeUncheckedCreateWithoutLandingPagesInput> | LpContentTypeCreateWithoutLandingPagesInput[] | LpContentTypeUncheckedCreateWithoutLandingPagesInput[]
    connectOrCreate?: LpContentTypeCreateOrConnectWithoutLandingPagesInput | LpContentTypeCreateOrConnectWithoutLandingPagesInput[]
    upsert?: LpContentTypeUpsertWithWhereUniqueWithoutLandingPagesInput | LpContentTypeUpsertWithWhereUniqueWithoutLandingPagesInput[]
    set?: LpContentTypeWhereUniqueInput | LpContentTypeWhereUniqueInput[]
    disconnect?: LpContentTypeWhereUniqueInput | LpContentTypeWhereUniqueInput[]
    delete?: LpContentTypeWhereUniqueInput | LpContentTypeWhereUniqueInput[]
    connect?: LpContentTypeWhereUniqueInput | LpContentTypeWhereUniqueInput[]
    update?: LpContentTypeUpdateWithWhereUniqueWithoutLandingPagesInput | LpContentTypeUpdateWithWhereUniqueWithoutLandingPagesInput[]
    updateMany?: LpContentTypeUpdateManyWithWhereWithoutLandingPagesInput | LpContentTypeUpdateManyWithWhereWithoutLandingPagesInput[]
    deleteMany?: LpContentTypeScalarWhereInput | LpContentTypeScalarWhereInput[]
  }

  export type LandingPageCreateNestedManyWithoutLpForInput = {
    create?: XOR<LandingPageCreateWithoutLpForInput, LandingPageUncheckedCreateWithoutLpForInput> | LandingPageCreateWithoutLpForInput[] | LandingPageUncheckedCreateWithoutLpForInput[]
    connectOrCreate?: LandingPageCreateOrConnectWithoutLpForInput | LandingPageCreateOrConnectWithoutLpForInput[]
    connect?: LandingPageWhereUniqueInput | LandingPageWhereUniqueInput[]
  }

  export type LandingPageUncheckedCreateNestedManyWithoutLpForInput = {
    create?: XOR<LandingPageCreateWithoutLpForInput, LandingPageUncheckedCreateWithoutLpForInput> | LandingPageCreateWithoutLpForInput[] | LandingPageUncheckedCreateWithoutLpForInput[]
    connectOrCreate?: LandingPageCreateOrConnectWithoutLpForInput | LandingPageCreateOrConnectWithoutLpForInput[]
    connect?: LandingPageWhereUniqueInput | LandingPageWhereUniqueInput[]
  }

  export type LandingPageUpdateManyWithoutLpForNestedInput = {
    create?: XOR<LandingPageCreateWithoutLpForInput, LandingPageUncheckedCreateWithoutLpForInput> | LandingPageCreateWithoutLpForInput[] | LandingPageUncheckedCreateWithoutLpForInput[]
    connectOrCreate?: LandingPageCreateOrConnectWithoutLpForInput | LandingPageCreateOrConnectWithoutLpForInput[]
    upsert?: LandingPageUpsertWithWhereUniqueWithoutLpForInput | LandingPageUpsertWithWhereUniqueWithoutLpForInput[]
    set?: LandingPageWhereUniqueInput | LandingPageWhereUniqueInput[]
    disconnect?: LandingPageWhereUniqueInput | LandingPageWhereUniqueInput[]
    delete?: LandingPageWhereUniqueInput | LandingPageWhereUniqueInput[]
    connect?: LandingPageWhereUniqueInput | LandingPageWhereUniqueInput[]
    update?: LandingPageUpdateWithWhereUniqueWithoutLpForInput | LandingPageUpdateWithWhereUniqueWithoutLpForInput[]
    updateMany?: LandingPageUpdateManyWithWhereWithoutLpForInput | LandingPageUpdateManyWithWhereWithoutLpForInput[]
    deleteMany?: LandingPageScalarWhereInput | LandingPageScalarWhereInput[]
  }

  export type LandingPageUncheckedUpdateManyWithoutLpForNestedInput = {
    create?: XOR<LandingPageCreateWithoutLpForInput, LandingPageUncheckedCreateWithoutLpForInput> | LandingPageCreateWithoutLpForInput[] | LandingPageUncheckedCreateWithoutLpForInput[]
    connectOrCreate?: LandingPageCreateOrConnectWithoutLpForInput | LandingPageCreateOrConnectWithoutLpForInput[]
    upsert?: LandingPageUpsertWithWhereUniqueWithoutLpForInput | LandingPageUpsertWithWhereUniqueWithoutLpForInput[]
    set?: LandingPageWhereUniqueInput | LandingPageWhereUniqueInput[]
    disconnect?: LandingPageWhereUniqueInput | LandingPageWhereUniqueInput[]
    delete?: LandingPageWhereUniqueInput | LandingPageWhereUniqueInput[]
    connect?: LandingPageWhereUniqueInput | LandingPageWhereUniqueInput[]
    update?: LandingPageUpdateWithWhereUniqueWithoutLpForInput | LandingPageUpdateWithWhereUniqueWithoutLpForInput[]
    updateMany?: LandingPageUpdateManyWithWhereWithoutLpForInput | LandingPageUpdateManyWithWhereWithoutLpForInput[]
    deleteMany?: LandingPageScalarWhereInput | LandingPageScalarWhereInput[]
  }

  export type LandingPageCreateNestedManyWithoutLpContentTypesInput = {
    create?: XOR<LandingPageCreateWithoutLpContentTypesInput, LandingPageUncheckedCreateWithoutLpContentTypesInput> | LandingPageCreateWithoutLpContentTypesInput[] | LandingPageUncheckedCreateWithoutLpContentTypesInput[]
    connectOrCreate?: LandingPageCreateOrConnectWithoutLpContentTypesInput | LandingPageCreateOrConnectWithoutLpContentTypesInput[]
    connect?: LandingPageWhereUniqueInput | LandingPageWhereUniqueInput[]
  }

  export type LandingPageUncheckedCreateNestedManyWithoutLpContentTypesInput = {
    create?: XOR<LandingPageCreateWithoutLpContentTypesInput, LandingPageUncheckedCreateWithoutLpContentTypesInput> | LandingPageCreateWithoutLpContentTypesInput[] | LandingPageUncheckedCreateWithoutLpContentTypesInput[]
    connectOrCreate?: LandingPageCreateOrConnectWithoutLpContentTypesInput | LandingPageCreateOrConnectWithoutLpContentTypesInput[]
    connect?: LandingPageWhereUniqueInput | LandingPageWhereUniqueInput[]
  }

  export type LandingPageUpdateManyWithoutLpContentTypesNestedInput = {
    create?: XOR<LandingPageCreateWithoutLpContentTypesInput, LandingPageUncheckedCreateWithoutLpContentTypesInput> | LandingPageCreateWithoutLpContentTypesInput[] | LandingPageUncheckedCreateWithoutLpContentTypesInput[]
    connectOrCreate?: LandingPageCreateOrConnectWithoutLpContentTypesInput | LandingPageCreateOrConnectWithoutLpContentTypesInput[]
    upsert?: LandingPageUpsertWithWhereUniqueWithoutLpContentTypesInput | LandingPageUpsertWithWhereUniqueWithoutLpContentTypesInput[]
    set?: LandingPageWhereUniqueInput | LandingPageWhereUniqueInput[]
    disconnect?: LandingPageWhereUniqueInput | LandingPageWhereUniqueInput[]
    delete?: LandingPageWhereUniqueInput | LandingPageWhereUniqueInput[]
    connect?: LandingPageWhereUniqueInput | LandingPageWhereUniqueInput[]
    update?: LandingPageUpdateWithWhereUniqueWithoutLpContentTypesInput | LandingPageUpdateWithWhereUniqueWithoutLpContentTypesInput[]
    updateMany?: LandingPageUpdateManyWithWhereWithoutLpContentTypesInput | LandingPageUpdateManyWithWhereWithoutLpContentTypesInput[]
    deleteMany?: LandingPageScalarWhereInput | LandingPageScalarWhereInput[]
  }

  export type LandingPageUncheckedUpdateManyWithoutLpContentTypesNestedInput = {
    create?: XOR<LandingPageCreateWithoutLpContentTypesInput, LandingPageUncheckedCreateWithoutLpContentTypesInput> | LandingPageCreateWithoutLpContentTypesInput[] | LandingPageUncheckedCreateWithoutLpContentTypesInput[]
    connectOrCreate?: LandingPageCreateOrConnectWithoutLpContentTypesInput | LandingPageCreateOrConnectWithoutLpContentTypesInput[]
    upsert?: LandingPageUpsertWithWhereUniqueWithoutLpContentTypesInput | LandingPageUpsertWithWhereUniqueWithoutLpContentTypesInput[]
    set?: LandingPageWhereUniqueInput | LandingPageWhereUniqueInput[]
    disconnect?: LandingPageWhereUniqueInput | LandingPageWhereUniqueInput[]
    delete?: LandingPageWhereUniqueInput | LandingPageWhereUniqueInput[]
    connect?: LandingPageWhereUniqueInput | LandingPageWhereUniqueInput[]
    update?: LandingPageUpdateWithWhereUniqueWithoutLpContentTypesInput | LandingPageUpdateWithWhereUniqueWithoutLpContentTypesInput[]
    updateMany?: LandingPageUpdateManyWithWhereWithoutLpContentTypesInput | LandingPageUpdateManyWithWhereWithoutLpContentTypesInput[]
    deleteMany?: LandingPageScalarWhereInput | LandingPageScalarWhereInput[]
  }

  export type LandingPageCreateNestedManyWithoutLpDesignStyleInput = {
    create?: XOR<LandingPageCreateWithoutLpDesignStyleInput, LandingPageUncheckedCreateWithoutLpDesignStyleInput> | LandingPageCreateWithoutLpDesignStyleInput[] | LandingPageUncheckedCreateWithoutLpDesignStyleInput[]
    connectOrCreate?: LandingPageCreateOrConnectWithoutLpDesignStyleInput | LandingPageCreateOrConnectWithoutLpDesignStyleInput[]
    createMany?: LandingPageCreateManyLpDesignStyleInputEnvelope
    connect?: LandingPageWhereUniqueInput | LandingPageWhereUniqueInput[]
  }

  export type LandingPageUncheckedCreateNestedManyWithoutLpDesignStyleInput = {
    create?: XOR<LandingPageCreateWithoutLpDesignStyleInput, LandingPageUncheckedCreateWithoutLpDesignStyleInput> | LandingPageCreateWithoutLpDesignStyleInput[] | LandingPageUncheckedCreateWithoutLpDesignStyleInput[]
    connectOrCreate?: LandingPageCreateOrConnectWithoutLpDesignStyleInput | LandingPageCreateOrConnectWithoutLpDesignStyleInput[]
    createMany?: LandingPageCreateManyLpDesignStyleInputEnvelope
    connect?: LandingPageWhereUniqueInput | LandingPageWhereUniqueInput[]
  }

  export type LandingPageUpdateManyWithoutLpDesignStyleNestedInput = {
    create?: XOR<LandingPageCreateWithoutLpDesignStyleInput, LandingPageUncheckedCreateWithoutLpDesignStyleInput> | LandingPageCreateWithoutLpDesignStyleInput[] | LandingPageUncheckedCreateWithoutLpDesignStyleInput[]
    connectOrCreate?: LandingPageCreateOrConnectWithoutLpDesignStyleInput | LandingPageCreateOrConnectWithoutLpDesignStyleInput[]
    upsert?: LandingPageUpsertWithWhereUniqueWithoutLpDesignStyleInput | LandingPageUpsertWithWhereUniqueWithoutLpDesignStyleInput[]
    createMany?: LandingPageCreateManyLpDesignStyleInputEnvelope
    set?: LandingPageWhereUniqueInput | LandingPageWhereUniqueInput[]
    disconnect?: LandingPageWhereUniqueInput | LandingPageWhereUniqueInput[]
    delete?: LandingPageWhereUniqueInput | LandingPageWhereUniqueInput[]
    connect?: LandingPageWhereUniqueInput | LandingPageWhereUniqueInput[]
    update?: LandingPageUpdateWithWhereUniqueWithoutLpDesignStyleInput | LandingPageUpdateWithWhereUniqueWithoutLpDesignStyleInput[]
    updateMany?: LandingPageUpdateManyWithWhereWithoutLpDesignStyleInput | LandingPageUpdateManyWithWhereWithoutLpDesignStyleInput[]
    deleteMany?: LandingPageScalarWhereInput | LandingPageScalarWhereInput[]
  }

  export type LandingPageUncheckedUpdateManyWithoutLpDesignStyleNestedInput = {
    create?: XOR<LandingPageCreateWithoutLpDesignStyleInput, LandingPageUncheckedCreateWithoutLpDesignStyleInput> | LandingPageCreateWithoutLpDesignStyleInput[] | LandingPageUncheckedCreateWithoutLpDesignStyleInput[]
    connectOrCreate?: LandingPageCreateOrConnectWithoutLpDesignStyleInput | LandingPageCreateOrConnectWithoutLpDesignStyleInput[]
    upsert?: LandingPageUpsertWithWhereUniqueWithoutLpDesignStyleInput | LandingPageUpsertWithWhereUniqueWithoutLpDesignStyleInput[]
    createMany?: LandingPageCreateManyLpDesignStyleInputEnvelope
    set?: LandingPageWhereUniqueInput | LandingPageWhereUniqueInput[]
    disconnect?: LandingPageWhereUniqueInput | LandingPageWhereUniqueInput[]
    delete?: LandingPageWhereUniqueInput | LandingPageWhereUniqueInput[]
    connect?: LandingPageWhereUniqueInput | LandingPageWhereUniqueInput[]
    update?: LandingPageUpdateWithWhereUniqueWithoutLpDesignStyleInput | LandingPageUpdateWithWhereUniqueWithoutLpDesignStyleInput[]
    updateMany?: LandingPageUpdateManyWithWhereWithoutLpDesignStyleInput | LandingPageUpdateManyWithWhereWithoutLpDesignStyleInput[]
    deleteMany?: LandingPageScalarWhereInput | LandingPageScalarWhereInput[]
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumSectionTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.SectionType | EnumSectionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SectionType[]
    notIn?: $Enums.SectionType[]
    not?: NestedEnumSectionTypeFilter<$PrismaModel> | $Enums.SectionType
  }

  export type NestedEnumSectionTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SectionType | EnumSectionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SectionType[]
    notIn?: $Enums.SectionType[]
    not?: NestedEnumSectionTypeWithAggregatesFilter<$PrismaModel> | $Enums.SectionType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSectionTypeFilter<$PrismaModel>
    _max?: NestedEnumSectionTypeFilter<$PrismaModel>
  }

  export type NestedEnumListItemTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ListItemType | EnumListItemTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ListItemType[]
    notIn?: $Enums.ListItemType[]
    not?: NestedEnumListItemTypeFilter<$PrismaModel> | $Enums.ListItemType
  }

  export type NestedEnumListItemTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ListItemType | EnumListItemTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ListItemType[]
    notIn?: $Enums.ListItemType[]
    not?: NestedEnumListItemTypeWithAggregatesFilter<$PrismaModel> | $Enums.ListItemType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumListItemTypeFilter<$PrismaModel>
    _max?: NestedEnumListItemTypeFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumProductStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ProductStatus | EnumProductStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ProductStatus[]
    notIn?: $Enums.ProductStatus[]
    not?: NestedEnumProductStatusFilter<$PrismaModel> | $Enums.ProductStatus
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedEnumProductStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ProductStatus | EnumProductStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ProductStatus[]
    notIn?: $Enums.ProductStatus[]
    not?: NestedEnumProductStatusWithAggregatesFilter<$PrismaModel> | $Enums.ProductStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumProductStatusFilter<$PrismaModel>
    _max?: NestedEnumProductStatusFilter<$PrismaModel>
  }

  export type NestedEnumPromoTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.PromoType | EnumPromoTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PromoType[]
    notIn?: $Enums.PromoType[]
    not?: NestedEnumPromoTypeFilter<$PrismaModel> | $Enums.PromoType
  }

  export type NestedEnumPromoTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PromoType | EnumPromoTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PromoType[]
    notIn?: $Enums.PromoType[]
    not?: NestedEnumPromoTypeWithAggregatesFilter<$PrismaModel> | $Enums.PromoType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPromoTypeFilter<$PrismaModel>
    _max?: NestedEnumPromoTypeFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedEnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[]
    notIn?: $Enums.UserRole[]
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedEnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[]
    notIn?: $Enums.UserRole[]
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type NestedEnumOrderStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.OrderStatus | EnumOrderStatusFieldRefInput<$PrismaModel>
    in?: $Enums.OrderStatus[]
    notIn?: $Enums.OrderStatus[]
    not?: NestedEnumOrderStatusFilter<$PrismaModel> | $Enums.OrderStatus
  }

  export type NestedEnumOrderStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OrderStatus | EnumOrderStatusFieldRefInput<$PrismaModel>
    in?: $Enums.OrderStatus[]
    notIn?: $Enums.OrderStatus[]
    not?: NestedEnumOrderStatusWithAggregatesFilter<$PrismaModel> | $Enums.OrderStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumOrderStatusFilter<$PrismaModel>
    _max?: NestedEnumOrderStatusFilter<$PrismaModel>
  }

  export type NestedEnumMenuTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.MenuType | EnumMenuTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MenuType[]
    notIn?: $Enums.MenuType[]
    not?: NestedEnumMenuTypeFilter<$PrismaModel> | $Enums.MenuType
  }

  export type NestedEnumMenuTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MenuType | EnumMenuTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MenuType[]
    notIn?: $Enums.MenuType[]
    not?: NestedEnumMenuTypeWithAggregatesFilter<$PrismaModel> | $Enums.MenuType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMenuTypeFilter<$PrismaModel>
    _max?: NestedEnumMenuTypeFilter<$PrismaModel>
  }

  export type NestedEnumFooterInfoTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.FooterInfoType | EnumFooterInfoTypeFieldRefInput<$PrismaModel>
    in?: $Enums.FooterInfoType[]
    notIn?: $Enums.FooterInfoType[]
    not?: NestedEnumFooterInfoTypeFilter<$PrismaModel> | $Enums.FooterInfoType
  }

  export type NestedEnumFooterInfoTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FooterInfoType | EnumFooterInfoTypeFieldRefInput<$PrismaModel>
    in?: $Enums.FooterInfoType[]
    notIn?: $Enums.FooterInfoType[]
    not?: NestedEnumFooterInfoTypeWithAggregatesFilter<$PrismaModel> | $Enums.FooterInfoType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumFooterInfoTypeFilter<$PrismaModel>
    _max?: NestedEnumFooterInfoTypeFilter<$PrismaModel>
  }

  export type SocialLinksCreateWithoutIdentityInput = {
    id?: string
    platform?: string | null
    url?: string | null
    platformUsername?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SocialLinksUncheckedCreateWithoutIdentityInput = {
    id?: string
    platform?: string | null
    url?: string | null
    platformUsername?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SocialLinksCreateOrConnectWithoutIdentityInput = {
    where: SocialLinksWhereUniqueInput
    create: XOR<SocialLinksCreateWithoutIdentityInput, SocialLinksUncheckedCreateWithoutIdentityInput>
  }

  export type SocialLinksCreateManyIdentityInputEnvelope = {
    data: SocialLinksCreateManyIdentityInput | SocialLinksCreateManyIdentityInput[]
  }

  export type SocialLinksUpsertWithWhereUniqueWithoutIdentityInput = {
    where: SocialLinksWhereUniqueInput
    update: XOR<SocialLinksUpdateWithoutIdentityInput, SocialLinksUncheckedUpdateWithoutIdentityInput>
    create: XOR<SocialLinksCreateWithoutIdentityInput, SocialLinksUncheckedCreateWithoutIdentityInput>
  }

  export type SocialLinksUpdateWithWhereUniqueWithoutIdentityInput = {
    where: SocialLinksWhereUniqueInput
    data: XOR<SocialLinksUpdateWithoutIdentityInput, SocialLinksUncheckedUpdateWithoutIdentityInput>
  }

  export type SocialLinksUpdateManyWithWhereWithoutIdentityInput = {
    where: SocialLinksScalarWhereInput
    data: XOR<SocialLinksUpdateManyMutationInput, SocialLinksUncheckedUpdateManyWithoutIdentityInput>
  }

  export type SocialLinksScalarWhereInput = {
    AND?: SocialLinksScalarWhereInput | SocialLinksScalarWhereInput[]
    OR?: SocialLinksScalarWhereInput[]
    NOT?: SocialLinksScalarWhereInput | SocialLinksScalarWhereInput[]
    id?: StringFilter<"SocialLinks"> | string
    platform?: StringNullableFilter<"SocialLinks"> | string | null
    url?: StringNullableFilter<"SocialLinks"> | string | null
    platformUsername?: StringNullableFilter<"SocialLinks"> | string | null
    identityId?: StringNullableFilter<"SocialLinks"> | string | null
    createdAt?: DateTimeFilter<"SocialLinks"> | Date | string
    updatedAt?: DateTimeFilter<"SocialLinks"> | Date | string
  }

  export type SiteIdentityCreateWithoutSocialLinksInput = {
    id?: string
    siteName: string
    tagline?: string | null
    description?: string | null
    keywords?: NullableJsonNullValueInput | InputJsonValue
    logoUrl?: string
    ogImage?: string | null
    faviconUrl?: string
    email?: string | null
    phone?: string | null
    address?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SiteIdentityUncheckedCreateWithoutSocialLinksInput = {
    id?: string
    siteName: string
    tagline?: string | null
    description?: string | null
    keywords?: NullableJsonNullValueInput | InputJsonValue
    logoUrl?: string
    ogImage?: string | null
    faviconUrl?: string
    email?: string | null
    phone?: string | null
    address?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SiteIdentityCreateOrConnectWithoutSocialLinksInput = {
    where: SiteIdentityWhereUniqueInput
    create: XOR<SiteIdentityCreateWithoutSocialLinksInput, SiteIdentityUncheckedCreateWithoutSocialLinksInput>
  }

  export type SiteIdentityUpsertWithoutSocialLinksInput = {
    update: XOR<SiteIdentityUpdateWithoutSocialLinksInput, SiteIdentityUncheckedUpdateWithoutSocialLinksInput>
    create: XOR<SiteIdentityCreateWithoutSocialLinksInput, SiteIdentityUncheckedCreateWithoutSocialLinksInput>
    where?: SiteIdentityWhereInput
  }

  export type SiteIdentityUpdateToOneWithWhereWithoutSocialLinksInput = {
    where?: SiteIdentityWhereInput
    data: XOR<SiteIdentityUpdateWithoutSocialLinksInput, SiteIdentityUncheckedUpdateWithoutSocialLinksInput>
  }

  export type SiteIdentityUpdateWithoutSocialLinksInput = {
    id?: StringFieldUpdateOperationsInput | string
    siteName?: StringFieldUpdateOperationsInput | string
    tagline?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    keywords?: NullableJsonNullValueInput | InputJsonValue
    logoUrl?: StringFieldUpdateOperationsInput | string
    ogImage?: NullableStringFieldUpdateOperationsInput | string | null
    faviconUrl?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SiteIdentityUncheckedUpdateWithoutSocialLinksInput = {
    id?: StringFieldUpdateOperationsInput | string
    siteName?: StringFieldUpdateOperationsInput | string
    tagline?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    keywords?: NullableJsonNullValueInput | InputJsonValue
    logoUrl?: StringFieldUpdateOperationsInput | string
    ogImage?: NullableStringFieldUpdateOperationsInput | string | null
    faviconUrl?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SectionCreateWithoutPageInput = {
    id?: string
    name?: string | null
    type: $Enums.SectionType
    title: string
    subTitle?: string | null
    description?: string | null
    additionalText?: string | null
    image?: string | null
    video?: string | null
    icon?: string | null
    order: number
    listItems?: ListItemCreateNestedManyWithoutSectionInput
  }

  export type SectionUncheckedCreateWithoutPageInput = {
    id?: string
    name?: string | null
    type: $Enums.SectionType
    title: string
    subTitle?: string | null
    description?: string | null
    additionalText?: string | null
    image?: string | null
    video?: string | null
    icon?: string | null
    order: number
    listItems?: ListItemUncheckedCreateNestedManyWithoutSectionInput
  }

  export type SectionCreateOrConnectWithoutPageInput = {
    where: SectionWhereUniqueInput
    create: XOR<SectionCreateWithoutPageInput, SectionUncheckedCreateWithoutPageInput>
  }

  export type SectionCreateManyPageInputEnvelope = {
    data: SectionCreateManyPageInput | SectionCreateManyPageInput[]
  }

  export type SectionUpsertWithWhereUniqueWithoutPageInput = {
    where: SectionWhereUniqueInput
    update: XOR<SectionUpdateWithoutPageInput, SectionUncheckedUpdateWithoutPageInput>
    create: XOR<SectionCreateWithoutPageInput, SectionUncheckedCreateWithoutPageInput>
  }

  export type SectionUpdateWithWhereUniqueWithoutPageInput = {
    where: SectionWhereUniqueInput
    data: XOR<SectionUpdateWithoutPageInput, SectionUncheckedUpdateWithoutPageInput>
  }

  export type SectionUpdateManyWithWhereWithoutPageInput = {
    where: SectionScalarWhereInput
    data: XOR<SectionUpdateManyMutationInput, SectionUncheckedUpdateManyWithoutPageInput>
  }

  export type SectionScalarWhereInput = {
    AND?: SectionScalarWhereInput | SectionScalarWhereInput[]
    OR?: SectionScalarWhereInput[]
    NOT?: SectionScalarWhereInput | SectionScalarWhereInput[]
    id?: StringFilter<"Section"> | string
    name?: StringNullableFilter<"Section"> | string | null
    pageId?: StringFilter<"Section"> | string
    type?: EnumSectionTypeFilter<"Section"> | $Enums.SectionType
    title?: StringFilter<"Section"> | string
    subTitle?: StringNullableFilter<"Section"> | string | null
    description?: StringNullableFilter<"Section"> | string | null
    additionalText?: StringNullableFilter<"Section"> | string | null
    image?: StringNullableFilter<"Section"> | string | null
    video?: StringNullableFilter<"Section"> | string | null
    icon?: StringNullableFilter<"Section"> | string | null
    order?: IntFilter<"Section"> | number
  }

  export type PageCreateWithoutSectionsInput = {
    id?: string
    slug: string
    name: string
    title: string
    description?: string | null
    keywords?: NullableJsonNullValueInput | InputJsonValue
    ogTitle?: string | null
    ogDescription?: string | null
    ogImage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PageUncheckedCreateWithoutSectionsInput = {
    id?: string
    slug: string
    name: string
    title: string
    description?: string | null
    keywords?: NullableJsonNullValueInput | InputJsonValue
    ogTitle?: string | null
    ogDescription?: string | null
    ogImage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PageCreateOrConnectWithoutSectionsInput = {
    where: PageWhereUniqueInput
    create: XOR<PageCreateWithoutSectionsInput, PageUncheckedCreateWithoutSectionsInput>
  }

  export type ListItemCreateWithoutSectionInput = {
    id?: string
    type: $Enums.ListItemType
    title: string
    description?: string | null
    entries?: ListEntryCreateNestedManyWithoutListItemInput
  }

  export type ListItemUncheckedCreateWithoutSectionInput = {
    id?: string
    type: $Enums.ListItemType
    title: string
    description?: string | null
    entries?: ListEntryUncheckedCreateNestedManyWithoutListItemInput
  }

  export type ListItemCreateOrConnectWithoutSectionInput = {
    where: ListItemWhereUniqueInput
    create: XOR<ListItemCreateWithoutSectionInput, ListItemUncheckedCreateWithoutSectionInput>
  }

  export type ListItemCreateManySectionInputEnvelope = {
    data: ListItemCreateManySectionInput | ListItemCreateManySectionInput[]
  }

  export type PageUpsertWithoutSectionsInput = {
    update: XOR<PageUpdateWithoutSectionsInput, PageUncheckedUpdateWithoutSectionsInput>
    create: XOR<PageCreateWithoutSectionsInput, PageUncheckedCreateWithoutSectionsInput>
    where?: PageWhereInput
  }

  export type PageUpdateToOneWithWhereWithoutSectionsInput = {
    where?: PageWhereInput
    data: XOR<PageUpdateWithoutSectionsInput, PageUncheckedUpdateWithoutSectionsInput>
  }

  export type PageUpdateWithoutSectionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    keywords?: NullableJsonNullValueInput | InputJsonValue
    ogTitle?: NullableStringFieldUpdateOperationsInput | string | null
    ogDescription?: NullableStringFieldUpdateOperationsInput | string | null
    ogImage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PageUncheckedUpdateWithoutSectionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    keywords?: NullableJsonNullValueInput | InputJsonValue
    ogTitle?: NullableStringFieldUpdateOperationsInput | string | null
    ogDescription?: NullableStringFieldUpdateOperationsInput | string | null
    ogImage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ListItemUpsertWithWhereUniqueWithoutSectionInput = {
    where: ListItemWhereUniqueInput
    update: XOR<ListItemUpdateWithoutSectionInput, ListItemUncheckedUpdateWithoutSectionInput>
    create: XOR<ListItemCreateWithoutSectionInput, ListItemUncheckedCreateWithoutSectionInput>
  }

  export type ListItemUpdateWithWhereUniqueWithoutSectionInput = {
    where: ListItemWhereUniqueInput
    data: XOR<ListItemUpdateWithoutSectionInput, ListItemUncheckedUpdateWithoutSectionInput>
  }

  export type ListItemUpdateManyWithWhereWithoutSectionInput = {
    where: ListItemScalarWhereInput
    data: XOR<ListItemUpdateManyMutationInput, ListItemUncheckedUpdateManyWithoutSectionInput>
  }

  export type ListItemScalarWhereInput = {
    AND?: ListItemScalarWhereInput | ListItemScalarWhereInput[]
    OR?: ListItemScalarWhereInput[]
    NOT?: ListItemScalarWhereInput | ListItemScalarWhereInput[]
    id?: StringFilter<"ListItem"> | string
    sectionId?: StringFilter<"ListItem"> | string
    type?: EnumListItemTypeFilter<"ListItem"> | $Enums.ListItemType
    title?: StringFilter<"ListItem"> | string
    description?: StringNullableFilter<"ListItem"> | string | null
  }

  export type SectionCreateWithoutListItemsInput = {
    id?: string
    name?: string | null
    type: $Enums.SectionType
    title: string
    subTitle?: string | null
    description?: string | null
    additionalText?: string | null
    image?: string | null
    video?: string | null
    icon?: string | null
    order: number
    page: PageCreateNestedOneWithoutSectionsInput
  }

  export type SectionUncheckedCreateWithoutListItemsInput = {
    id?: string
    name?: string | null
    pageId: string
    type: $Enums.SectionType
    title: string
    subTitle?: string | null
    description?: string | null
    additionalText?: string | null
    image?: string | null
    video?: string | null
    icon?: string | null
    order: number
  }

  export type SectionCreateOrConnectWithoutListItemsInput = {
    where: SectionWhereUniqueInput
    create: XOR<SectionCreateWithoutListItemsInput, SectionUncheckedCreateWithoutListItemsInput>
  }

  export type ListEntryCreateWithoutListItemInput = {
    id?: string
    title: string
    price?: number | null
    description?: string | null
    icon?: string | null
    image?: string | null
  }

  export type ListEntryUncheckedCreateWithoutListItemInput = {
    id?: string
    title: string
    price?: number | null
    description?: string | null
    icon?: string | null
    image?: string | null
  }

  export type ListEntryCreateOrConnectWithoutListItemInput = {
    where: ListEntryWhereUniqueInput
    create: XOR<ListEntryCreateWithoutListItemInput, ListEntryUncheckedCreateWithoutListItemInput>
  }

  export type ListEntryCreateManyListItemInputEnvelope = {
    data: ListEntryCreateManyListItemInput | ListEntryCreateManyListItemInput[]
  }

  export type SectionUpsertWithoutListItemsInput = {
    update: XOR<SectionUpdateWithoutListItemsInput, SectionUncheckedUpdateWithoutListItemsInput>
    create: XOR<SectionCreateWithoutListItemsInput, SectionUncheckedCreateWithoutListItemsInput>
    where?: SectionWhereInput
  }

  export type SectionUpdateToOneWithWhereWithoutListItemsInput = {
    where?: SectionWhereInput
    data: XOR<SectionUpdateWithoutListItemsInput, SectionUncheckedUpdateWithoutListItemsInput>
  }

  export type SectionUpdateWithoutListItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumSectionTypeFieldUpdateOperationsInput | $Enums.SectionType
    title?: StringFieldUpdateOperationsInput | string
    subTitle?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    additionalText?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    video?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    page?: PageUpdateOneRequiredWithoutSectionsNestedInput
  }

  export type SectionUncheckedUpdateWithoutListItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    pageId?: StringFieldUpdateOperationsInput | string
    type?: EnumSectionTypeFieldUpdateOperationsInput | $Enums.SectionType
    title?: StringFieldUpdateOperationsInput | string
    subTitle?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    additionalText?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    video?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
  }

  export type ListEntryUpsertWithWhereUniqueWithoutListItemInput = {
    where: ListEntryWhereUniqueInput
    update: XOR<ListEntryUpdateWithoutListItemInput, ListEntryUncheckedUpdateWithoutListItemInput>
    create: XOR<ListEntryCreateWithoutListItemInput, ListEntryUncheckedCreateWithoutListItemInput>
  }

  export type ListEntryUpdateWithWhereUniqueWithoutListItemInput = {
    where: ListEntryWhereUniqueInput
    data: XOR<ListEntryUpdateWithoutListItemInput, ListEntryUncheckedUpdateWithoutListItemInput>
  }

  export type ListEntryUpdateManyWithWhereWithoutListItemInput = {
    where: ListEntryScalarWhereInput
    data: XOR<ListEntryUpdateManyMutationInput, ListEntryUncheckedUpdateManyWithoutListItemInput>
  }

  export type ListEntryScalarWhereInput = {
    AND?: ListEntryScalarWhereInput | ListEntryScalarWhereInput[]
    OR?: ListEntryScalarWhereInput[]
    NOT?: ListEntryScalarWhereInput | ListEntryScalarWhereInput[]
    id?: StringFilter<"ListEntry"> | string
    listItemId?: StringFilter<"ListEntry"> | string
    title?: StringFilter<"ListEntry"> | string
    price?: IntNullableFilter<"ListEntry"> | number | null
    description?: StringNullableFilter<"ListEntry"> | string | null
    icon?: StringNullableFilter<"ListEntry"> | string | null
    image?: StringNullableFilter<"ListEntry"> | string | null
  }

  export type ListItemCreateWithoutEntriesInput = {
    id?: string
    type: $Enums.ListItemType
    title: string
    description?: string | null
    section: SectionCreateNestedOneWithoutListItemsInput
  }

  export type ListItemUncheckedCreateWithoutEntriesInput = {
    id?: string
    sectionId: string
    type: $Enums.ListItemType
    title: string
    description?: string | null
  }

  export type ListItemCreateOrConnectWithoutEntriesInput = {
    where: ListItemWhereUniqueInput
    create: XOR<ListItemCreateWithoutEntriesInput, ListItemUncheckedCreateWithoutEntriesInput>
  }

  export type ListItemUpsertWithoutEntriesInput = {
    update: XOR<ListItemUpdateWithoutEntriesInput, ListItemUncheckedUpdateWithoutEntriesInput>
    create: XOR<ListItemCreateWithoutEntriesInput, ListItemUncheckedCreateWithoutEntriesInput>
    where?: ListItemWhereInput
  }

  export type ListItemUpdateToOneWithWhereWithoutEntriesInput = {
    where?: ListItemWhereInput
    data: XOR<ListItemUpdateWithoutEntriesInput, ListItemUncheckedUpdateWithoutEntriesInput>
  }

  export type ListItemUpdateWithoutEntriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumListItemTypeFieldUpdateOperationsInput | $Enums.ListItemType
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    section?: SectionUpdateOneRequiredWithoutListItemsNestedInput
  }

  export type ListItemUncheckedUpdateWithoutEntriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    sectionId?: StringFieldUpdateOperationsInput | string
    type?: EnumListItemTypeFieldUpdateOperationsInput | $Enums.ListItemType
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CategoryCreateWithoutProductsInput = {
    id?: string
    name: string
    slug: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CategoryUncheckedCreateWithoutProductsInput = {
    id?: string
    name: string
    slug: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CategoryCreateOrConnectWithoutProductsInput = {
    where: CategoryWhereUniqueInput
    create: XOR<CategoryCreateWithoutProductsInput, CategoryUncheckedCreateWithoutProductsInput>
  }

  export type TagCreateWithoutProductsInput = {
    id?: string
    name: string
    slug: string
  }

  export type TagUncheckedCreateWithoutProductsInput = {
    id?: string
    name: string
    slug: string
  }

  export type TagCreateOrConnectWithoutProductsInput = {
    where: TagWhereUniqueInput
    create: XOR<TagCreateWithoutProductsInput, TagUncheckedCreateWithoutProductsInput>
  }

  export type ProductGalleryCreateWithoutProductInput = {
    id?: string
    imageUrl: string
    order: number
    createdAt?: Date | string
  }

  export type ProductGalleryUncheckedCreateWithoutProductInput = {
    id?: string
    imageUrl: string
    order: number
    createdAt?: Date | string
  }

  export type ProductGalleryCreateOrConnectWithoutProductInput = {
    where: ProductGalleryWhereUniqueInput
    create: XOR<ProductGalleryCreateWithoutProductInput, ProductGalleryUncheckedCreateWithoutProductInput>
  }

  export type ProductGalleryCreateManyProductInputEnvelope = {
    data: ProductGalleryCreateManyProductInput | ProductGalleryCreateManyProductInput[]
  }

  export type ProductBenefitCreateWithoutProductInput = {
    id?: string
    isActive?: boolean
    order?: number
    benefit: BenefitCreateNestedOneWithoutProductsInput
  }

  export type ProductBenefitUncheckedCreateWithoutProductInput = {
    id?: string
    benefitId: string
    isActive?: boolean
    order?: number
  }

  export type ProductBenefitCreateOrConnectWithoutProductInput = {
    where: ProductBenefitWhereUniqueInput
    create: XOR<ProductBenefitCreateWithoutProductInput, ProductBenefitUncheckedCreateWithoutProductInput>
  }

  export type ProductBenefitCreateManyProductInputEnvelope = {
    data: ProductBenefitCreateManyProductInput | ProductBenefitCreateManyProductInput[]
  }

  export type ProductBenefitPointCreateWithoutProductInput = {
    id?: string
    text: string
    order: number
    icon?: string | null
  }

  export type ProductBenefitPointUncheckedCreateWithoutProductInput = {
    id?: string
    text: string
    order: number
    icon?: string | null
  }

  export type ProductBenefitPointCreateOrConnectWithoutProductInput = {
    where: ProductBenefitPointWhereUniqueInput
    create: XOR<ProductBenefitPointCreateWithoutProductInput, ProductBenefitPointUncheckedCreateWithoutProductInput>
  }

  export type ProductBenefitPointCreateManyProductInputEnvelope = {
    data: ProductBenefitPointCreateManyProductInput | ProductBenefitPointCreateManyProductInput[]
  }

  export type PromotionCreateWithoutProductsInput = {
    id?: string
    name: string
    description?: string | null
    type: $Enums.PromoType
    value?: number | null
    isActive?: boolean
    startDate: Date | string
    endDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PromotionUncheckedCreateWithoutProductsInput = {
    id?: string
    name: string
    description?: string | null
    type: $Enums.PromoType
    value?: number | null
    isActive?: boolean
    startDate: Date | string
    endDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PromotionCreateOrConnectWithoutProductsInput = {
    where: PromotionWhereUniqueInput
    create: XOR<PromotionCreateWithoutProductsInput, PromotionUncheckedCreateWithoutProductsInput>
  }

  export type VoucherCreateWithoutProductsInput = {
    id?: string
    code: string
    description?: string | null
    type: $Enums.PromoType
    value: number
    usageLimit?: number | null
    usedCount?: number
    isActive?: boolean
    startDate: Date | string
    endDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    usages?: VoucherUsageCreateNestedManyWithoutVoucherInput
    orders?: OrderCreateNestedManyWithoutVoucherInput
  }

  export type VoucherUncheckedCreateWithoutProductsInput = {
    id?: string
    code: string
    description?: string | null
    type: $Enums.PromoType
    value: number
    usageLimit?: number | null
    usedCount?: number
    isActive?: boolean
    startDate: Date | string
    endDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    usages?: VoucherUsageUncheckedCreateNestedManyWithoutVoucherInput
    orders?: OrderUncheckedCreateNestedManyWithoutVoucherInput
  }

  export type VoucherCreateOrConnectWithoutProductsInput = {
    where: VoucherWhereUniqueInput
    create: XOR<VoucherCreateWithoutProductsInput, VoucherUncheckedCreateWithoutProductsInput>
  }

  export type OrderCreateWithoutProductsInput = {
    id?: string
    email: string
    name?: string | null
    totalPrice: number
    status?: $Enums.OrderStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutOrdersInput
    voucher?: VoucherCreateNestedOneWithoutOrdersInput
  }

  export type OrderUncheckedCreateWithoutProductsInput = {
    id?: string
    email: string
    name?: string | null
    userId?: string | null
    voucherId?: string | null
    totalPrice: number
    status?: $Enums.OrderStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrderCreateOrConnectWithoutProductsInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutProductsInput, OrderUncheckedCreateWithoutProductsInput>
  }

  export type CategoryUpsertWithoutProductsInput = {
    update: XOR<CategoryUpdateWithoutProductsInput, CategoryUncheckedUpdateWithoutProductsInput>
    create: XOR<CategoryCreateWithoutProductsInput, CategoryUncheckedCreateWithoutProductsInput>
    where?: CategoryWhereInput
  }

  export type CategoryUpdateToOneWithWhereWithoutProductsInput = {
    where?: CategoryWhereInput
    data: XOR<CategoryUpdateWithoutProductsInput, CategoryUncheckedUpdateWithoutProductsInput>
  }

  export type CategoryUpdateWithoutProductsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CategoryUncheckedUpdateWithoutProductsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TagUpsertWithWhereUniqueWithoutProductsInput = {
    where: TagWhereUniqueInput
    update: XOR<TagUpdateWithoutProductsInput, TagUncheckedUpdateWithoutProductsInput>
    create: XOR<TagCreateWithoutProductsInput, TagUncheckedCreateWithoutProductsInput>
  }

  export type TagUpdateWithWhereUniqueWithoutProductsInput = {
    where: TagWhereUniqueInput
    data: XOR<TagUpdateWithoutProductsInput, TagUncheckedUpdateWithoutProductsInput>
  }

  export type TagUpdateManyWithWhereWithoutProductsInput = {
    where: TagScalarWhereInput
    data: XOR<TagUpdateManyMutationInput, TagUncheckedUpdateManyWithoutProductsInput>
  }

  export type TagScalarWhereInput = {
    AND?: TagScalarWhereInput | TagScalarWhereInput[]
    OR?: TagScalarWhereInput[]
    NOT?: TagScalarWhereInput | TagScalarWhereInput[]
    id?: StringFilter<"Tag"> | string
    name?: StringFilter<"Tag"> | string
    slug?: StringFilter<"Tag"> | string
  }

  export type ProductGalleryUpsertWithWhereUniqueWithoutProductInput = {
    where: ProductGalleryWhereUniqueInput
    update: XOR<ProductGalleryUpdateWithoutProductInput, ProductGalleryUncheckedUpdateWithoutProductInput>
    create: XOR<ProductGalleryCreateWithoutProductInput, ProductGalleryUncheckedCreateWithoutProductInput>
  }

  export type ProductGalleryUpdateWithWhereUniqueWithoutProductInput = {
    where: ProductGalleryWhereUniqueInput
    data: XOR<ProductGalleryUpdateWithoutProductInput, ProductGalleryUncheckedUpdateWithoutProductInput>
  }

  export type ProductGalleryUpdateManyWithWhereWithoutProductInput = {
    where: ProductGalleryScalarWhereInput
    data: XOR<ProductGalleryUpdateManyMutationInput, ProductGalleryUncheckedUpdateManyWithoutProductInput>
  }

  export type ProductGalleryScalarWhereInput = {
    AND?: ProductGalleryScalarWhereInput | ProductGalleryScalarWhereInput[]
    OR?: ProductGalleryScalarWhereInput[]
    NOT?: ProductGalleryScalarWhereInput | ProductGalleryScalarWhereInput[]
    id?: StringFilter<"ProductGallery"> | string
    productId?: StringFilter<"ProductGallery"> | string
    imageUrl?: StringFilter<"ProductGallery"> | string
    order?: IntFilter<"ProductGallery"> | number
    createdAt?: DateTimeFilter<"ProductGallery"> | Date | string
  }

  export type ProductBenefitUpsertWithWhereUniqueWithoutProductInput = {
    where: ProductBenefitWhereUniqueInput
    update: XOR<ProductBenefitUpdateWithoutProductInput, ProductBenefitUncheckedUpdateWithoutProductInput>
    create: XOR<ProductBenefitCreateWithoutProductInput, ProductBenefitUncheckedCreateWithoutProductInput>
  }

  export type ProductBenefitUpdateWithWhereUniqueWithoutProductInput = {
    where: ProductBenefitWhereUniqueInput
    data: XOR<ProductBenefitUpdateWithoutProductInput, ProductBenefitUncheckedUpdateWithoutProductInput>
  }

  export type ProductBenefitUpdateManyWithWhereWithoutProductInput = {
    where: ProductBenefitScalarWhereInput
    data: XOR<ProductBenefitUpdateManyMutationInput, ProductBenefitUncheckedUpdateManyWithoutProductInput>
  }

  export type ProductBenefitScalarWhereInput = {
    AND?: ProductBenefitScalarWhereInput | ProductBenefitScalarWhereInput[]
    OR?: ProductBenefitScalarWhereInput[]
    NOT?: ProductBenefitScalarWhereInput | ProductBenefitScalarWhereInput[]
    id?: StringFilter<"ProductBenefit"> | string
    productId?: StringFilter<"ProductBenefit"> | string
    benefitId?: StringFilter<"ProductBenefit"> | string
    isActive?: BoolFilter<"ProductBenefit"> | boolean
    order?: IntFilter<"ProductBenefit"> | number
  }

  export type ProductBenefitPointUpsertWithWhereUniqueWithoutProductInput = {
    where: ProductBenefitPointWhereUniqueInput
    update: XOR<ProductBenefitPointUpdateWithoutProductInput, ProductBenefitPointUncheckedUpdateWithoutProductInput>
    create: XOR<ProductBenefitPointCreateWithoutProductInput, ProductBenefitPointUncheckedCreateWithoutProductInput>
  }

  export type ProductBenefitPointUpdateWithWhereUniqueWithoutProductInput = {
    where: ProductBenefitPointWhereUniqueInput
    data: XOR<ProductBenefitPointUpdateWithoutProductInput, ProductBenefitPointUncheckedUpdateWithoutProductInput>
  }

  export type ProductBenefitPointUpdateManyWithWhereWithoutProductInput = {
    where: ProductBenefitPointScalarWhereInput
    data: XOR<ProductBenefitPointUpdateManyMutationInput, ProductBenefitPointUncheckedUpdateManyWithoutProductInput>
  }

  export type ProductBenefitPointScalarWhereInput = {
    AND?: ProductBenefitPointScalarWhereInput | ProductBenefitPointScalarWhereInput[]
    OR?: ProductBenefitPointScalarWhereInput[]
    NOT?: ProductBenefitPointScalarWhereInput | ProductBenefitPointScalarWhereInput[]
    id?: StringFilter<"ProductBenefitPoint"> | string
    productId?: StringFilter<"ProductBenefitPoint"> | string
    text?: StringFilter<"ProductBenefitPoint"> | string
    order?: IntFilter<"ProductBenefitPoint"> | number
    icon?: StringNullableFilter<"ProductBenefitPoint"> | string | null
  }

  export type PromotionUpsertWithWhereUniqueWithoutProductsInput = {
    where: PromotionWhereUniqueInput
    update: XOR<PromotionUpdateWithoutProductsInput, PromotionUncheckedUpdateWithoutProductsInput>
    create: XOR<PromotionCreateWithoutProductsInput, PromotionUncheckedCreateWithoutProductsInput>
  }

  export type PromotionUpdateWithWhereUniqueWithoutProductsInput = {
    where: PromotionWhereUniqueInput
    data: XOR<PromotionUpdateWithoutProductsInput, PromotionUncheckedUpdateWithoutProductsInput>
  }

  export type PromotionUpdateManyWithWhereWithoutProductsInput = {
    where: PromotionScalarWhereInput
    data: XOR<PromotionUpdateManyMutationInput, PromotionUncheckedUpdateManyWithoutProductsInput>
  }

  export type PromotionScalarWhereInput = {
    AND?: PromotionScalarWhereInput | PromotionScalarWhereInput[]
    OR?: PromotionScalarWhereInput[]
    NOT?: PromotionScalarWhereInput | PromotionScalarWhereInput[]
    id?: StringFilter<"Promotion"> | string
    name?: StringFilter<"Promotion"> | string
    description?: StringNullableFilter<"Promotion"> | string | null
    type?: EnumPromoTypeFilter<"Promotion"> | $Enums.PromoType
    value?: FloatNullableFilter<"Promotion"> | number | null
    isActive?: BoolFilter<"Promotion"> | boolean
    startDate?: DateTimeFilter<"Promotion"> | Date | string
    endDate?: DateTimeFilter<"Promotion"> | Date | string
    createdAt?: DateTimeFilter<"Promotion"> | Date | string
    updatedAt?: DateTimeFilter<"Promotion"> | Date | string
  }

  export type VoucherUpsertWithWhereUniqueWithoutProductsInput = {
    where: VoucherWhereUniqueInput
    update: XOR<VoucherUpdateWithoutProductsInput, VoucherUncheckedUpdateWithoutProductsInput>
    create: XOR<VoucherCreateWithoutProductsInput, VoucherUncheckedCreateWithoutProductsInput>
  }

  export type VoucherUpdateWithWhereUniqueWithoutProductsInput = {
    where: VoucherWhereUniqueInput
    data: XOR<VoucherUpdateWithoutProductsInput, VoucherUncheckedUpdateWithoutProductsInput>
  }

  export type VoucherUpdateManyWithWhereWithoutProductsInput = {
    where: VoucherScalarWhereInput
    data: XOR<VoucherUpdateManyMutationInput, VoucherUncheckedUpdateManyWithoutProductsInput>
  }

  export type VoucherScalarWhereInput = {
    AND?: VoucherScalarWhereInput | VoucherScalarWhereInput[]
    OR?: VoucherScalarWhereInput[]
    NOT?: VoucherScalarWhereInput | VoucherScalarWhereInput[]
    id?: StringFilter<"Voucher"> | string
    code?: StringFilter<"Voucher"> | string
    description?: StringNullableFilter<"Voucher"> | string | null
    type?: EnumPromoTypeFilter<"Voucher"> | $Enums.PromoType
    value?: FloatFilter<"Voucher"> | number
    usageLimit?: IntNullableFilter<"Voucher"> | number | null
    usedCount?: IntFilter<"Voucher"> | number
    isActive?: BoolFilter<"Voucher"> | boolean
    startDate?: DateTimeFilter<"Voucher"> | Date | string
    endDate?: DateTimeFilter<"Voucher"> | Date | string
    createdAt?: DateTimeFilter<"Voucher"> | Date | string
    updatedAt?: DateTimeFilter<"Voucher"> | Date | string
  }

  export type OrderUpsertWithWhereUniqueWithoutProductsInput = {
    where: OrderWhereUniqueInput
    update: XOR<OrderUpdateWithoutProductsInput, OrderUncheckedUpdateWithoutProductsInput>
    create: XOR<OrderCreateWithoutProductsInput, OrderUncheckedCreateWithoutProductsInput>
  }

  export type OrderUpdateWithWhereUniqueWithoutProductsInput = {
    where: OrderWhereUniqueInput
    data: XOR<OrderUpdateWithoutProductsInput, OrderUncheckedUpdateWithoutProductsInput>
  }

  export type OrderUpdateManyWithWhereWithoutProductsInput = {
    where: OrderScalarWhereInput
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyWithoutProductsInput>
  }

  export type OrderScalarWhereInput = {
    AND?: OrderScalarWhereInput | OrderScalarWhereInput[]
    OR?: OrderScalarWhereInput[]
    NOT?: OrderScalarWhereInput | OrderScalarWhereInput[]
    id?: StringFilter<"Order"> | string
    email?: StringFilter<"Order"> | string
    name?: StringNullableFilter<"Order"> | string | null
    userId?: StringNullableFilter<"Order"> | string | null
    voucherId?: StringNullableFilter<"Order"> | string | null
    totalPrice?: FloatFilter<"Order"> | number
    status?: EnumOrderStatusFilter<"Order"> | $Enums.OrderStatus
    createdAt?: DateTimeFilter<"Order"> | Date | string
    updatedAt?: DateTimeFilter<"Order"> | Date | string
  }

  export type ProductCreateWithoutCategoryInput = {
    id?: string
    sku: string
    name: string
    slug: string
    description?: string | null
    bestFor?: string | null
    image?: string | null
    price: number
    proccessTime?: number | null
    inStock?: boolean
    status?: $Enums.ProductStatus
    keywords?: NullableJsonNullValueInput | InputJsonValue
    quality: number
    isBest?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    tags?: TagCreateNestedManyWithoutProductsInput
    gallery?: ProductGalleryCreateNestedManyWithoutProductInput
    benefits?: ProductBenefitCreateNestedManyWithoutProductInput
    benefitPoints?: ProductBenefitPointCreateNestedManyWithoutProductInput
    promotions?: PromotionCreateNestedManyWithoutProductsInput
    vouchers?: VoucherCreateNestedManyWithoutProductsInput
    orders?: OrderCreateNestedManyWithoutProductsInput
  }

  export type ProductUncheckedCreateWithoutCategoryInput = {
    id?: string
    sku: string
    name: string
    slug: string
    description?: string | null
    bestFor?: string | null
    image?: string | null
    price: number
    proccessTime?: number | null
    inStock?: boolean
    status?: $Enums.ProductStatus
    keywords?: NullableJsonNullValueInput | InputJsonValue
    quality: number
    isBest?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    tags?: TagUncheckedCreateNestedManyWithoutProductsInput
    gallery?: ProductGalleryUncheckedCreateNestedManyWithoutProductInput
    benefits?: ProductBenefitUncheckedCreateNestedManyWithoutProductInput
    benefitPoints?: ProductBenefitPointUncheckedCreateNestedManyWithoutProductInput
    promotions?: PromotionUncheckedCreateNestedManyWithoutProductsInput
    vouchers?: VoucherUncheckedCreateNestedManyWithoutProductsInput
    orders?: OrderUncheckedCreateNestedManyWithoutProductsInput
  }

  export type ProductCreateOrConnectWithoutCategoryInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutCategoryInput, ProductUncheckedCreateWithoutCategoryInput>
  }

  export type ProductCreateManyCategoryInputEnvelope = {
    data: ProductCreateManyCategoryInput | ProductCreateManyCategoryInput[]
  }

  export type ProductUpsertWithWhereUniqueWithoutCategoryInput = {
    where: ProductWhereUniqueInput
    update: XOR<ProductUpdateWithoutCategoryInput, ProductUncheckedUpdateWithoutCategoryInput>
    create: XOR<ProductCreateWithoutCategoryInput, ProductUncheckedCreateWithoutCategoryInput>
  }

  export type ProductUpdateWithWhereUniqueWithoutCategoryInput = {
    where: ProductWhereUniqueInput
    data: XOR<ProductUpdateWithoutCategoryInput, ProductUncheckedUpdateWithoutCategoryInput>
  }

  export type ProductUpdateManyWithWhereWithoutCategoryInput = {
    where: ProductScalarWhereInput
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyWithoutCategoryInput>
  }

  export type ProductScalarWhereInput = {
    AND?: ProductScalarWhereInput | ProductScalarWhereInput[]
    OR?: ProductScalarWhereInput[]
    NOT?: ProductScalarWhereInput | ProductScalarWhereInput[]
    id?: StringFilter<"Product"> | string
    sku?: StringFilter<"Product"> | string
    name?: StringFilter<"Product"> | string
    slug?: StringFilter<"Product"> | string
    description?: StringNullableFilter<"Product"> | string | null
    bestFor?: StringNullableFilter<"Product"> | string | null
    image?: StringNullableFilter<"Product"> | string | null
    price?: FloatFilter<"Product"> | number
    proccessTime?: IntNullableFilter<"Product"> | number | null
    inStock?: BoolFilter<"Product"> | boolean
    status?: EnumProductStatusFilter<"Product"> | $Enums.ProductStatus
    categoryId?: StringFilter<"Product"> | string
    keywords?: JsonNullableFilter<"Product">
    quality?: IntFilter<"Product"> | number
    isBest?: BoolFilter<"Product"> | boolean
    createdAt?: DateTimeFilter<"Product"> | Date | string
    updatedAt?: DateTimeFilter<"Product"> | Date | string
  }

  export type ProductCreateWithoutTagsInput = {
    id?: string
    sku: string
    name: string
    slug: string
    description?: string | null
    bestFor?: string | null
    image?: string | null
    price: number
    proccessTime?: number | null
    inStock?: boolean
    status?: $Enums.ProductStatus
    keywords?: NullableJsonNullValueInput | InputJsonValue
    quality: number
    isBest?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    category: CategoryCreateNestedOneWithoutProductsInput
    gallery?: ProductGalleryCreateNestedManyWithoutProductInput
    benefits?: ProductBenefitCreateNestedManyWithoutProductInput
    benefitPoints?: ProductBenefitPointCreateNestedManyWithoutProductInput
    promotions?: PromotionCreateNestedManyWithoutProductsInput
    vouchers?: VoucherCreateNestedManyWithoutProductsInput
    orders?: OrderCreateNestedManyWithoutProductsInput
  }

  export type ProductUncheckedCreateWithoutTagsInput = {
    id?: string
    sku: string
    name: string
    slug: string
    description?: string | null
    bestFor?: string | null
    image?: string | null
    price: number
    proccessTime?: number | null
    inStock?: boolean
    status?: $Enums.ProductStatus
    categoryId: string
    keywords?: NullableJsonNullValueInput | InputJsonValue
    quality: number
    isBest?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    gallery?: ProductGalleryUncheckedCreateNestedManyWithoutProductInput
    benefits?: ProductBenefitUncheckedCreateNestedManyWithoutProductInput
    benefitPoints?: ProductBenefitPointUncheckedCreateNestedManyWithoutProductInput
    promotions?: PromotionUncheckedCreateNestedManyWithoutProductsInput
    vouchers?: VoucherUncheckedCreateNestedManyWithoutProductsInput
    orders?: OrderUncheckedCreateNestedManyWithoutProductsInput
  }

  export type ProductCreateOrConnectWithoutTagsInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutTagsInput, ProductUncheckedCreateWithoutTagsInput>
  }

  export type ProductUpsertWithWhereUniqueWithoutTagsInput = {
    where: ProductWhereUniqueInput
    update: XOR<ProductUpdateWithoutTagsInput, ProductUncheckedUpdateWithoutTagsInput>
    create: XOR<ProductCreateWithoutTagsInput, ProductUncheckedCreateWithoutTagsInput>
  }

  export type ProductUpdateWithWhereUniqueWithoutTagsInput = {
    where: ProductWhereUniqueInput
    data: XOR<ProductUpdateWithoutTagsInput, ProductUncheckedUpdateWithoutTagsInput>
  }

  export type ProductUpdateManyWithWhereWithoutTagsInput = {
    where: ProductScalarWhereInput
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyWithoutTagsInput>
  }

  export type ProductCreateWithoutGalleryInput = {
    id?: string
    sku: string
    name: string
    slug: string
    description?: string | null
    bestFor?: string | null
    image?: string | null
    price: number
    proccessTime?: number | null
    inStock?: boolean
    status?: $Enums.ProductStatus
    keywords?: NullableJsonNullValueInput | InputJsonValue
    quality: number
    isBest?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    category: CategoryCreateNestedOneWithoutProductsInput
    tags?: TagCreateNestedManyWithoutProductsInput
    benefits?: ProductBenefitCreateNestedManyWithoutProductInput
    benefitPoints?: ProductBenefitPointCreateNestedManyWithoutProductInput
    promotions?: PromotionCreateNestedManyWithoutProductsInput
    vouchers?: VoucherCreateNestedManyWithoutProductsInput
    orders?: OrderCreateNestedManyWithoutProductsInput
  }

  export type ProductUncheckedCreateWithoutGalleryInput = {
    id?: string
    sku: string
    name: string
    slug: string
    description?: string | null
    bestFor?: string | null
    image?: string | null
    price: number
    proccessTime?: number | null
    inStock?: boolean
    status?: $Enums.ProductStatus
    categoryId: string
    keywords?: NullableJsonNullValueInput | InputJsonValue
    quality: number
    isBest?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    tags?: TagUncheckedCreateNestedManyWithoutProductsInput
    benefits?: ProductBenefitUncheckedCreateNestedManyWithoutProductInput
    benefitPoints?: ProductBenefitPointUncheckedCreateNestedManyWithoutProductInput
    promotions?: PromotionUncheckedCreateNestedManyWithoutProductsInput
    vouchers?: VoucherUncheckedCreateNestedManyWithoutProductsInput
    orders?: OrderUncheckedCreateNestedManyWithoutProductsInput
  }

  export type ProductCreateOrConnectWithoutGalleryInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutGalleryInput, ProductUncheckedCreateWithoutGalleryInput>
  }

  export type ProductUpsertWithoutGalleryInput = {
    update: XOR<ProductUpdateWithoutGalleryInput, ProductUncheckedUpdateWithoutGalleryInput>
    create: XOR<ProductCreateWithoutGalleryInput, ProductUncheckedCreateWithoutGalleryInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutGalleryInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutGalleryInput, ProductUncheckedUpdateWithoutGalleryInput>
  }

  export type ProductUpdateWithoutGalleryInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    bestFor?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    proccessTime?: NullableIntFieldUpdateOperationsInput | number | null
    inStock?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumProductStatusFieldUpdateOperationsInput | $Enums.ProductStatus
    keywords?: NullableJsonNullValueInput | InputJsonValue
    quality?: IntFieldUpdateOperationsInput | number
    isBest?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: CategoryUpdateOneRequiredWithoutProductsNestedInput
    tags?: TagUpdateManyWithoutProductsNestedInput
    benefits?: ProductBenefitUpdateManyWithoutProductNestedInput
    benefitPoints?: ProductBenefitPointUpdateManyWithoutProductNestedInput
    promotions?: PromotionUpdateManyWithoutProductsNestedInput
    vouchers?: VoucherUpdateManyWithoutProductsNestedInput
    orders?: OrderUpdateManyWithoutProductsNestedInput
  }

  export type ProductUncheckedUpdateWithoutGalleryInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    bestFor?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    proccessTime?: NullableIntFieldUpdateOperationsInput | number | null
    inStock?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumProductStatusFieldUpdateOperationsInput | $Enums.ProductStatus
    categoryId?: StringFieldUpdateOperationsInput | string
    keywords?: NullableJsonNullValueInput | InputJsonValue
    quality?: IntFieldUpdateOperationsInput | number
    isBest?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tags?: TagUncheckedUpdateManyWithoutProductsNestedInput
    benefits?: ProductBenefitUncheckedUpdateManyWithoutProductNestedInput
    benefitPoints?: ProductBenefitPointUncheckedUpdateManyWithoutProductNestedInput
    promotions?: PromotionUncheckedUpdateManyWithoutProductsNestedInput
    vouchers?: VoucherUncheckedUpdateManyWithoutProductsNestedInput
    orders?: OrderUncheckedUpdateManyWithoutProductsNestedInput
  }

  export type ProductBenefitCreateWithoutBenefitInput = {
    id?: string
    isActive?: boolean
    order?: number
    product: ProductCreateNestedOneWithoutBenefitsInput
  }

  export type ProductBenefitUncheckedCreateWithoutBenefitInput = {
    id?: string
    productId: string
    isActive?: boolean
    order?: number
  }

  export type ProductBenefitCreateOrConnectWithoutBenefitInput = {
    where: ProductBenefitWhereUniqueInput
    create: XOR<ProductBenefitCreateWithoutBenefitInput, ProductBenefitUncheckedCreateWithoutBenefitInput>
  }

  export type ProductBenefitCreateManyBenefitInputEnvelope = {
    data: ProductBenefitCreateManyBenefitInput | ProductBenefitCreateManyBenefitInput[]
  }

  export type ProductBenefitUpsertWithWhereUniqueWithoutBenefitInput = {
    where: ProductBenefitWhereUniqueInput
    update: XOR<ProductBenefitUpdateWithoutBenefitInput, ProductBenefitUncheckedUpdateWithoutBenefitInput>
    create: XOR<ProductBenefitCreateWithoutBenefitInput, ProductBenefitUncheckedCreateWithoutBenefitInput>
  }

  export type ProductBenefitUpdateWithWhereUniqueWithoutBenefitInput = {
    where: ProductBenefitWhereUniqueInput
    data: XOR<ProductBenefitUpdateWithoutBenefitInput, ProductBenefitUncheckedUpdateWithoutBenefitInput>
  }

  export type ProductBenefitUpdateManyWithWhereWithoutBenefitInput = {
    where: ProductBenefitScalarWhereInput
    data: XOR<ProductBenefitUpdateManyMutationInput, ProductBenefitUncheckedUpdateManyWithoutBenefitInput>
  }

  export type ProductCreateWithoutBenefitsInput = {
    id?: string
    sku: string
    name: string
    slug: string
    description?: string | null
    bestFor?: string | null
    image?: string | null
    price: number
    proccessTime?: number | null
    inStock?: boolean
    status?: $Enums.ProductStatus
    keywords?: NullableJsonNullValueInput | InputJsonValue
    quality: number
    isBest?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    category: CategoryCreateNestedOneWithoutProductsInput
    tags?: TagCreateNestedManyWithoutProductsInput
    gallery?: ProductGalleryCreateNestedManyWithoutProductInput
    benefitPoints?: ProductBenefitPointCreateNestedManyWithoutProductInput
    promotions?: PromotionCreateNestedManyWithoutProductsInput
    vouchers?: VoucherCreateNestedManyWithoutProductsInput
    orders?: OrderCreateNestedManyWithoutProductsInput
  }

  export type ProductUncheckedCreateWithoutBenefitsInput = {
    id?: string
    sku: string
    name: string
    slug: string
    description?: string | null
    bestFor?: string | null
    image?: string | null
    price: number
    proccessTime?: number | null
    inStock?: boolean
    status?: $Enums.ProductStatus
    categoryId: string
    keywords?: NullableJsonNullValueInput | InputJsonValue
    quality: number
    isBest?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    tags?: TagUncheckedCreateNestedManyWithoutProductsInput
    gallery?: ProductGalleryUncheckedCreateNestedManyWithoutProductInput
    benefitPoints?: ProductBenefitPointUncheckedCreateNestedManyWithoutProductInput
    promotions?: PromotionUncheckedCreateNestedManyWithoutProductsInput
    vouchers?: VoucherUncheckedCreateNestedManyWithoutProductsInput
    orders?: OrderUncheckedCreateNestedManyWithoutProductsInput
  }

  export type ProductCreateOrConnectWithoutBenefitsInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutBenefitsInput, ProductUncheckedCreateWithoutBenefitsInput>
  }

  export type BenefitCreateWithoutProductsInput = {
    id?: string
    title: string
    description?: string | null
    icon?: string | null
  }

  export type BenefitUncheckedCreateWithoutProductsInput = {
    id?: string
    title: string
    description?: string | null
    icon?: string | null
  }

  export type BenefitCreateOrConnectWithoutProductsInput = {
    where: BenefitWhereUniqueInput
    create: XOR<BenefitCreateWithoutProductsInput, BenefitUncheckedCreateWithoutProductsInput>
  }

  export type ProductUpsertWithoutBenefitsInput = {
    update: XOR<ProductUpdateWithoutBenefitsInput, ProductUncheckedUpdateWithoutBenefitsInput>
    create: XOR<ProductCreateWithoutBenefitsInput, ProductUncheckedCreateWithoutBenefitsInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutBenefitsInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutBenefitsInput, ProductUncheckedUpdateWithoutBenefitsInput>
  }

  export type ProductUpdateWithoutBenefitsInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    bestFor?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    proccessTime?: NullableIntFieldUpdateOperationsInput | number | null
    inStock?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumProductStatusFieldUpdateOperationsInput | $Enums.ProductStatus
    keywords?: NullableJsonNullValueInput | InputJsonValue
    quality?: IntFieldUpdateOperationsInput | number
    isBest?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: CategoryUpdateOneRequiredWithoutProductsNestedInput
    tags?: TagUpdateManyWithoutProductsNestedInput
    gallery?: ProductGalleryUpdateManyWithoutProductNestedInput
    benefitPoints?: ProductBenefitPointUpdateManyWithoutProductNestedInput
    promotions?: PromotionUpdateManyWithoutProductsNestedInput
    vouchers?: VoucherUpdateManyWithoutProductsNestedInput
    orders?: OrderUpdateManyWithoutProductsNestedInput
  }

  export type ProductUncheckedUpdateWithoutBenefitsInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    bestFor?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    proccessTime?: NullableIntFieldUpdateOperationsInput | number | null
    inStock?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumProductStatusFieldUpdateOperationsInput | $Enums.ProductStatus
    categoryId?: StringFieldUpdateOperationsInput | string
    keywords?: NullableJsonNullValueInput | InputJsonValue
    quality?: IntFieldUpdateOperationsInput | number
    isBest?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tags?: TagUncheckedUpdateManyWithoutProductsNestedInput
    gallery?: ProductGalleryUncheckedUpdateManyWithoutProductNestedInput
    benefitPoints?: ProductBenefitPointUncheckedUpdateManyWithoutProductNestedInput
    promotions?: PromotionUncheckedUpdateManyWithoutProductsNestedInput
    vouchers?: VoucherUncheckedUpdateManyWithoutProductsNestedInput
    orders?: OrderUncheckedUpdateManyWithoutProductsNestedInput
  }

  export type BenefitUpsertWithoutProductsInput = {
    update: XOR<BenefitUpdateWithoutProductsInput, BenefitUncheckedUpdateWithoutProductsInput>
    create: XOR<BenefitCreateWithoutProductsInput, BenefitUncheckedCreateWithoutProductsInput>
    where?: BenefitWhereInput
  }

  export type BenefitUpdateToOneWithWhereWithoutProductsInput = {
    where?: BenefitWhereInput
    data: XOR<BenefitUpdateWithoutProductsInput, BenefitUncheckedUpdateWithoutProductsInput>
  }

  export type BenefitUpdateWithoutProductsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BenefitUncheckedUpdateWithoutProductsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProductCreateWithoutBenefitPointsInput = {
    id?: string
    sku: string
    name: string
    slug: string
    description?: string | null
    bestFor?: string | null
    image?: string | null
    price: number
    proccessTime?: number | null
    inStock?: boolean
    status?: $Enums.ProductStatus
    keywords?: NullableJsonNullValueInput | InputJsonValue
    quality: number
    isBest?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    category: CategoryCreateNestedOneWithoutProductsInput
    tags?: TagCreateNestedManyWithoutProductsInput
    gallery?: ProductGalleryCreateNestedManyWithoutProductInput
    benefits?: ProductBenefitCreateNestedManyWithoutProductInput
    promotions?: PromotionCreateNestedManyWithoutProductsInput
    vouchers?: VoucherCreateNestedManyWithoutProductsInput
    orders?: OrderCreateNestedManyWithoutProductsInput
  }

  export type ProductUncheckedCreateWithoutBenefitPointsInput = {
    id?: string
    sku: string
    name: string
    slug: string
    description?: string | null
    bestFor?: string | null
    image?: string | null
    price: number
    proccessTime?: number | null
    inStock?: boolean
    status?: $Enums.ProductStatus
    categoryId: string
    keywords?: NullableJsonNullValueInput | InputJsonValue
    quality: number
    isBest?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    tags?: TagUncheckedCreateNestedManyWithoutProductsInput
    gallery?: ProductGalleryUncheckedCreateNestedManyWithoutProductInput
    benefits?: ProductBenefitUncheckedCreateNestedManyWithoutProductInput
    promotions?: PromotionUncheckedCreateNestedManyWithoutProductsInput
    vouchers?: VoucherUncheckedCreateNestedManyWithoutProductsInput
    orders?: OrderUncheckedCreateNestedManyWithoutProductsInput
  }

  export type ProductCreateOrConnectWithoutBenefitPointsInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutBenefitPointsInput, ProductUncheckedCreateWithoutBenefitPointsInput>
  }

  export type ProductUpsertWithoutBenefitPointsInput = {
    update: XOR<ProductUpdateWithoutBenefitPointsInput, ProductUncheckedUpdateWithoutBenefitPointsInput>
    create: XOR<ProductCreateWithoutBenefitPointsInput, ProductUncheckedCreateWithoutBenefitPointsInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutBenefitPointsInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutBenefitPointsInput, ProductUncheckedUpdateWithoutBenefitPointsInput>
  }

  export type ProductUpdateWithoutBenefitPointsInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    bestFor?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    proccessTime?: NullableIntFieldUpdateOperationsInput | number | null
    inStock?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumProductStatusFieldUpdateOperationsInput | $Enums.ProductStatus
    keywords?: NullableJsonNullValueInput | InputJsonValue
    quality?: IntFieldUpdateOperationsInput | number
    isBest?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: CategoryUpdateOneRequiredWithoutProductsNestedInput
    tags?: TagUpdateManyWithoutProductsNestedInput
    gallery?: ProductGalleryUpdateManyWithoutProductNestedInput
    benefits?: ProductBenefitUpdateManyWithoutProductNestedInput
    promotions?: PromotionUpdateManyWithoutProductsNestedInput
    vouchers?: VoucherUpdateManyWithoutProductsNestedInput
    orders?: OrderUpdateManyWithoutProductsNestedInput
  }

  export type ProductUncheckedUpdateWithoutBenefitPointsInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    bestFor?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    proccessTime?: NullableIntFieldUpdateOperationsInput | number | null
    inStock?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumProductStatusFieldUpdateOperationsInput | $Enums.ProductStatus
    categoryId?: StringFieldUpdateOperationsInput | string
    keywords?: NullableJsonNullValueInput | InputJsonValue
    quality?: IntFieldUpdateOperationsInput | number
    isBest?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tags?: TagUncheckedUpdateManyWithoutProductsNestedInput
    gallery?: ProductGalleryUncheckedUpdateManyWithoutProductNestedInput
    benefits?: ProductBenefitUncheckedUpdateManyWithoutProductNestedInput
    promotions?: PromotionUncheckedUpdateManyWithoutProductsNestedInput
    vouchers?: VoucherUncheckedUpdateManyWithoutProductsNestedInput
    orders?: OrderUncheckedUpdateManyWithoutProductsNestedInput
  }

  export type ProductCreateWithoutPromotionsInput = {
    id?: string
    sku: string
    name: string
    slug: string
    description?: string | null
    bestFor?: string | null
    image?: string | null
    price: number
    proccessTime?: number | null
    inStock?: boolean
    status?: $Enums.ProductStatus
    keywords?: NullableJsonNullValueInput | InputJsonValue
    quality: number
    isBest?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    category: CategoryCreateNestedOneWithoutProductsInput
    tags?: TagCreateNestedManyWithoutProductsInput
    gallery?: ProductGalleryCreateNestedManyWithoutProductInput
    benefits?: ProductBenefitCreateNestedManyWithoutProductInput
    benefitPoints?: ProductBenefitPointCreateNestedManyWithoutProductInput
    vouchers?: VoucherCreateNestedManyWithoutProductsInput
    orders?: OrderCreateNestedManyWithoutProductsInput
  }

  export type ProductUncheckedCreateWithoutPromotionsInput = {
    id?: string
    sku: string
    name: string
    slug: string
    description?: string | null
    bestFor?: string | null
    image?: string | null
    price: number
    proccessTime?: number | null
    inStock?: boolean
    status?: $Enums.ProductStatus
    categoryId: string
    keywords?: NullableJsonNullValueInput | InputJsonValue
    quality: number
    isBest?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    tags?: TagUncheckedCreateNestedManyWithoutProductsInput
    gallery?: ProductGalleryUncheckedCreateNestedManyWithoutProductInput
    benefits?: ProductBenefitUncheckedCreateNestedManyWithoutProductInput
    benefitPoints?: ProductBenefitPointUncheckedCreateNestedManyWithoutProductInput
    vouchers?: VoucherUncheckedCreateNestedManyWithoutProductsInput
    orders?: OrderUncheckedCreateNestedManyWithoutProductsInput
  }

  export type ProductCreateOrConnectWithoutPromotionsInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutPromotionsInput, ProductUncheckedCreateWithoutPromotionsInput>
  }

  export type ProductUpsertWithWhereUniqueWithoutPromotionsInput = {
    where: ProductWhereUniqueInput
    update: XOR<ProductUpdateWithoutPromotionsInput, ProductUncheckedUpdateWithoutPromotionsInput>
    create: XOR<ProductCreateWithoutPromotionsInput, ProductUncheckedCreateWithoutPromotionsInput>
  }

  export type ProductUpdateWithWhereUniqueWithoutPromotionsInput = {
    where: ProductWhereUniqueInput
    data: XOR<ProductUpdateWithoutPromotionsInput, ProductUncheckedUpdateWithoutPromotionsInput>
  }

  export type ProductUpdateManyWithWhereWithoutPromotionsInput = {
    where: ProductScalarWhereInput
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyWithoutPromotionsInput>
  }

  export type ProductCreateWithoutVouchersInput = {
    id?: string
    sku: string
    name: string
    slug: string
    description?: string | null
    bestFor?: string | null
    image?: string | null
    price: number
    proccessTime?: number | null
    inStock?: boolean
    status?: $Enums.ProductStatus
    keywords?: NullableJsonNullValueInput | InputJsonValue
    quality: number
    isBest?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    category: CategoryCreateNestedOneWithoutProductsInput
    tags?: TagCreateNestedManyWithoutProductsInput
    gallery?: ProductGalleryCreateNestedManyWithoutProductInput
    benefits?: ProductBenefitCreateNestedManyWithoutProductInput
    benefitPoints?: ProductBenefitPointCreateNestedManyWithoutProductInput
    promotions?: PromotionCreateNestedManyWithoutProductsInput
    orders?: OrderCreateNestedManyWithoutProductsInput
  }

  export type ProductUncheckedCreateWithoutVouchersInput = {
    id?: string
    sku: string
    name: string
    slug: string
    description?: string | null
    bestFor?: string | null
    image?: string | null
    price: number
    proccessTime?: number | null
    inStock?: boolean
    status?: $Enums.ProductStatus
    categoryId: string
    keywords?: NullableJsonNullValueInput | InputJsonValue
    quality: number
    isBest?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    tags?: TagUncheckedCreateNestedManyWithoutProductsInput
    gallery?: ProductGalleryUncheckedCreateNestedManyWithoutProductInput
    benefits?: ProductBenefitUncheckedCreateNestedManyWithoutProductInput
    benefitPoints?: ProductBenefitPointUncheckedCreateNestedManyWithoutProductInput
    promotions?: PromotionUncheckedCreateNestedManyWithoutProductsInput
    orders?: OrderUncheckedCreateNestedManyWithoutProductsInput
  }

  export type ProductCreateOrConnectWithoutVouchersInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutVouchersInput, ProductUncheckedCreateWithoutVouchersInput>
  }

  export type VoucherUsageCreateWithoutVoucherInput = {
    id?: string
    usedAt?: Date | string
    user: UserCreateNestedOneWithoutVouchersInput
  }

  export type VoucherUsageUncheckedCreateWithoutVoucherInput = {
    id?: string
    userId: string
    usedAt?: Date | string
  }

  export type VoucherUsageCreateOrConnectWithoutVoucherInput = {
    where: VoucherUsageWhereUniqueInput
    create: XOR<VoucherUsageCreateWithoutVoucherInput, VoucherUsageUncheckedCreateWithoutVoucherInput>
  }

  export type VoucherUsageCreateManyVoucherInputEnvelope = {
    data: VoucherUsageCreateManyVoucherInput | VoucherUsageCreateManyVoucherInput[]
  }

  export type OrderCreateWithoutVoucherInput = {
    id?: string
    email: string
    name?: string | null
    totalPrice: number
    status?: $Enums.OrderStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutOrdersInput
    products?: ProductCreateNestedManyWithoutOrdersInput
  }

  export type OrderUncheckedCreateWithoutVoucherInput = {
    id?: string
    email: string
    name?: string | null
    userId?: string | null
    totalPrice: number
    status?: $Enums.OrderStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    products?: ProductUncheckedCreateNestedManyWithoutOrdersInput
  }

  export type OrderCreateOrConnectWithoutVoucherInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutVoucherInput, OrderUncheckedCreateWithoutVoucherInput>
  }

  export type OrderCreateManyVoucherInputEnvelope = {
    data: OrderCreateManyVoucherInput | OrderCreateManyVoucherInput[]
  }

  export type ProductUpsertWithWhereUniqueWithoutVouchersInput = {
    where: ProductWhereUniqueInput
    update: XOR<ProductUpdateWithoutVouchersInput, ProductUncheckedUpdateWithoutVouchersInput>
    create: XOR<ProductCreateWithoutVouchersInput, ProductUncheckedCreateWithoutVouchersInput>
  }

  export type ProductUpdateWithWhereUniqueWithoutVouchersInput = {
    where: ProductWhereUniqueInput
    data: XOR<ProductUpdateWithoutVouchersInput, ProductUncheckedUpdateWithoutVouchersInput>
  }

  export type ProductUpdateManyWithWhereWithoutVouchersInput = {
    where: ProductScalarWhereInput
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyWithoutVouchersInput>
  }

  export type VoucherUsageUpsertWithWhereUniqueWithoutVoucherInput = {
    where: VoucherUsageWhereUniqueInput
    update: XOR<VoucherUsageUpdateWithoutVoucherInput, VoucherUsageUncheckedUpdateWithoutVoucherInput>
    create: XOR<VoucherUsageCreateWithoutVoucherInput, VoucherUsageUncheckedCreateWithoutVoucherInput>
  }

  export type VoucherUsageUpdateWithWhereUniqueWithoutVoucherInput = {
    where: VoucherUsageWhereUniqueInput
    data: XOR<VoucherUsageUpdateWithoutVoucherInput, VoucherUsageUncheckedUpdateWithoutVoucherInput>
  }

  export type VoucherUsageUpdateManyWithWhereWithoutVoucherInput = {
    where: VoucherUsageScalarWhereInput
    data: XOR<VoucherUsageUpdateManyMutationInput, VoucherUsageUncheckedUpdateManyWithoutVoucherInput>
  }

  export type VoucherUsageScalarWhereInput = {
    AND?: VoucherUsageScalarWhereInput | VoucherUsageScalarWhereInput[]
    OR?: VoucherUsageScalarWhereInput[]
    NOT?: VoucherUsageScalarWhereInput | VoucherUsageScalarWhereInput[]
    id?: StringFilter<"VoucherUsage"> | string
    voucherId?: StringFilter<"VoucherUsage"> | string
    userId?: StringFilter<"VoucherUsage"> | string
    usedAt?: DateTimeFilter<"VoucherUsage"> | Date | string
  }

  export type OrderUpsertWithWhereUniqueWithoutVoucherInput = {
    where: OrderWhereUniqueInput
    update: XOR<OrderUpdateWithoutVoucherInput, OrderUncheckedUpdateWithoutVoucherInput>
    create: XOR<OrderCreateWithoutVoucherInput, OrderUncheckedCreateWithoutVoucherInput>
  }

  export type OrderUpdateWithWhereUniqueWithoutVoucherInput = {
    where: OrderWhereUniqueInput
    data: XOR<OrderUpdateWithoutVoucherInput, OrderUncheckedUpdateWithoutVoucherInput>
  }

  export type OrderUpdateManyWithWhereWithoutVoucherInput = {
    where: OrderScalarWhereInput
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyWithoutVoucherInput>
  }

  export type VoucherCreateWithoutUsagesInput = {
    id?: string
    code: string
    description?: string | null
    type: $Enums.PromoType
    value: number
    usageLimit?: number | null
    usedCount?: number
    isActive?: boolean
    startDate: Date | string
    endDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    products?: ProductCreateNestedManyWithoutVouchersInput
    orders?: OrderCreateNestedManyWithoutVoucherInput
  }

  export type VoucherUncheckedCreateWithoutUsagesInput = {
    id?: string
    code: string
    description?: string | null
    type: $Enums.PromoType
    value: number
    usageLimit?: number | null
    usedCount?: number
    isActive?: boolean
    startDate: Date | string
    endDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    products?: ProductUncheckedCreateNestedManyWithoutVouchersInput
    orders?: OrderUncheckedCreateNestedManyWithoutVoucherInput
  }

  export type VoucherCreateOrConnectWithoutUsagesInput = {
    where: VoucherWhereUniqueInput
    create: XOR<VoucherCreateWithoutUsagesInput, VoucherUncheckedCreateWithoutUsagesInput>
  }

  export type UserCreateWithoutVouchersInput = {
    id?: string
    firstName?: string | null
    lastName?: string | null
    name?: string | null
    userName?: string | null
    email: string
    password?: string
    emailVerified?: Date | string | null
    image?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    orders?: OrderCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    Authenticator?: AuthenticatorCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutVouchersInput = {
    id?: string
    firstName?: string | null
    lastName?: string | null
    name?: string | null
    userName?: string | null
    email: string
    password?: string
    emailVerified?: Date | string | null
    image?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    Authenticator?: AuthenticatorUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutVouchersInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutVouchersInput, UserUncheckedCreateWithoutVouchersInput>
  }

  export type VoucherUpsertWithoutUsagesInput = {
    update: XOR<VoucherUpdateWithoutUsagesInput, VoucherUncheckedUpdateWithoutUsagesInput>
    create: XOR<VoucherCreateWithoutUsagesInput, VoucherUncheckedCreateWithoutUsagesInput>
    where?: VoucherWhereInput
  }

  export type VoucherUpdateToOneWithWhereWithoutUsagesInput = {
    where?: VoucherWhereInput
    data: XOR<VoucherUpdateWithoutUsagesInput, VoucherUncheckedUpdateWithoutUsagesInput>
  }

  export type VoucherUpdateWithoutUsagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumPromoTypeFieldUpdateOperationsInput | $Enums.PromoType
    value?: FloatFieldUpdateOperationsInput | number
    usageLimit?: NullableIntFieldUpdateOperationsInput | number | null
    usedCount?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    products?: ProductUpdateManyWithoutVouchersNestedInput
    orders?: OrderUpdateManyWithoutVoucherNestedInput
  }

  export type VoucherUncheckedUpdateWithoutUsagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumPromoTypeFieldUpdateOperationsInput | $Enums.PromoType
    value?: FloatFieldUpdateOperationsInput | number
    usageLimit?: NullableIntFieldUpdateOperationsInput | number | null
    usedCount?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    products?: ProductUncheckedUpdateManyWithoutVouchersNestedInput
    orders?: OrderUncheckedUpdateManyWithoutVoucherNestedInput
  }

  export type UserUpsertWithoutVouchersInput = {
    update: XOR<UserUpdateWithoutVouchersInput, UserUncheckedUpdateWithoutVouchersInput>
    create: XOR<UserCreateWithoutVouchersInput, UserUncheckedCreateWithoutVouchersInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutVouchersInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutVouchersInput, UserUncheckedUpdateWithoutVouchersInput>
  }

  export type UserUpdateWithoutVouchersInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    userName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orders?: OrderUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    Authenticator?: AuthenticatorUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutVouchersInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    userName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    Authenticator?: AuthenticatorUncheckedUpdateManyWithoutUserNestedInput
  }

  export type OrderCreateWithoutUserInput = {
    id?: string
    email: string
    name?: string | null
    totalPrice: number
    status?: $Enums.OrderStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    products?: ProductCreateNestedManyWithoutOrdersInput
    voucher?: VoucherCreateNestedOneWithoutOrdersInput
  }

  export type OrderUncheckedCreateWithoutUserInput = {
    id?: string
    email: string
    name?: string | null
    voucherId?: string | null
    totalPrice: number
    status?: $Enums.OrderStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    products?: ProductUncheckedCreateNestedManyWithoutOrdersInput
  }

  export type OrderCreateOrConnectWithoutUserInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutUserInput, OrderUncheckedCreateWithoutUserInput>
  }

  export type OrderCreateManyUserInputEnvelope = {
    data: OrderCreateManyUserInput | OrderCreateManyUserInput[]
  }

  export type AccountCreateWithoutUserInput = {
    id?: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
  }

  export type AccountUncheckedCreateWithoutUserInput = {
    id?: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
  }

  export type AccountCreateOrConnectWithoutUserInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput>
  }

  export type AccountCreateManyUserInputEnvelope = {
    data: AccountCreateManyUserInput | AccountCreateManyUserInput[]
  }

  export type SessionCreateWithoutUserInput = {
    id?: string
    sessionToken: string
    expires: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SessionUncheckedCreateWithoutUserInput = {
    id?: string
    sessionToken: string
    expires: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SessionCreateOrConnectWithoutUserInput = {
    where: SessionWhereUniqueInput
    create: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
  }

  export type SessionCreateManyUserInputEnvelope = {
    data: SessionCreateManyUserInput | SessionCreateManyUserInput[]
  }

  export type VoucherUsageCreateWithoutUserInput = {
    id?: string
    usedAt?: Date | string
    voucher: VoucherCreateNestedOneWithoutUsagesInput
  }

  export type VoucherUsageUncheckedCreateWithoutUserInput = {
    id?: string
    voucherId: string
    usedAt?: Date | string
  }

  export type VoucherUsageCreateOrConnectWithoutUserInput = {
    where: VoucherUsageWhereUniqueInput
    create: XOR<VoucherUsageCreateWithoutUserInput, VoucherUsageUncheckedCreateWithoutUserInput>
  }

  export type VoucherUsageCreateManyUserInputEnvelope = {
    data: VoucherUsageCreateManyUserInput | VoucherUsageCreateManyUserInput[]
  }

  export type AuthenticatorCreateWithoutUserInput = {
    credentialID: string
    providerAccountId: string
    credentialPublicKey: string
    counter: number
    credentialDeviceType: string
    credentialBackedUp: boolean
    transports?: string | null
  }

  export type AuthenticatorUncheckedCreateWithoutUserInput = {
    credentialID: string
    providerAccountId: string
    credentialPublicKey: string
    counter: number
    credentialDeviceType: string
    credentialBackedUp: boolean
    transports?: string | null
  }

  export type AuthenticatorCreateOrConnectWithoutUserInput = {
    where: AuthenticatorWhereUniqueInput
    create: XOR<AuthenticatorCreateWithoutUserInput, AuthenticatorUncheckedCreateWithoutUserInput>
  }

  export type AuthenticatorCreateManyUserInputEnvelope = {
    data: AuthenticatorCreateManyUserInput | AuthenticatorCreateManyUserInput[]
  }

  export type OrderUpsertWithWhereUniqueWithoutUserInput = {
    where: OrderWhereUniqueInput
    update: XOR<OrderUpdateWithoutUserInput, OrderUncheckedUpdateWithoutUserInput>
    create: XOR<OrderCreateWithoutUserInput, OrderUncheckedCreateWithoutUserInput>
  }

  export type OrderUpdateWithWhereUniqueWithoutUserInput = {
    where: OrderWhereUniqueInput
    data: XOR<OrderUpdateWithoutUserInput, OrderUncheckedUpdateWithoutUserInput>
  }

  export type OrderUpdateManyWithWhereWithoutUserInput = {
    where: OrderScalarWhereInput
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyWithoutUserInput>
  }

  export type AccountUpsertWithWhereUniqueWithoutUserInput = {
    where: AccountWhereUniqueInput
    update: XOR<AccountUpdateWithoutUserInput, AccountUncheckedUpdateWithoutUserInput>
    create: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput>
  }

  export type AccountUpdateWithWhereUniqueWithoutUserInput = {
    where: AccountWhereUniqueInput
    data: XOR<AccountUpdateWithoutUserInput, AccountUncheckedUpdateWithoutUserInput>
  }

  export type AccountUpdateManyWithWhereWithoutUserInput = {
    where: AccountScalarWhereInput
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyWithoutUserInput>
  }

  export type AccountScalarWhereInput = {
    AND?: AccountScalarWhereInput | AccountScalarWhereInput[]
    OR?: AccountScalarWhereInput[]
    NOT?: AccountScalarWhereInput | AccountScalarWhereInput[]
    id?: StringFilter<"Account"> | string
    userId?: StringFilter<"Account"> | string
    type?: StringFilter<"Account"> | string
    provider?: StringFilter<"Account"> | string
    providerAccountId?: StringFilter<"Account"> | string
    refresh_token?: StringNullableFilter<"Account"> | string | null
    access_token?: StringNullableFilter<"Account"> | string | null
    expires_at?: IntNullableFilter<"Account"> | number | null
    token_type?: StringNullableFilter<"Account"> | string | null
    scope?: StringNullableFilter<"Account"> | string | null
    id_token?: StringNullableFilter<"Account"> | string | null
    session_state?: StringNullableFilter<"Account"> | string | null
  }

  export type SessionUpsertWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput
    update: XOR<SessionUpdateWithoutUserInput, SessionUncheckedUpdateWithoutUserInput>
    create: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
  }

  export type SessionUpdateWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput
    data: XOR<SessionUpdateWithoutUserInput, SessionUncheckedUpdateWithoutUserInput>
  }

  export type SessionUpdateManyWithWhereWithoutUserInput = {
    where: SessionScalarWhereInput
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyWithoutUserInput>
  }

  export type SessionScalarWhereInput = {
    AND?: SessionScalarWhereInput | SessionScalarWhereInput[]
    OR?: SessionScalarWhereInput[]
    NOT?: SessionScalarWhereInput | SessionScalarWhereInput[]
    id?: StringFilter<"Session"> | string
    sessionToken?: StringFilter<"Session"> | string
    userId?: StringFilter<"Session"> | string
    expires?: DateTimeFilter<"Session"> | Date | string
    createdAt?: DateTimeFilter<"Session"> | Date | string
    updatedAt?: DateTimeFilter<"Session"> | Date | string
  }

  export type VoucherUsageUpsertWithWhereUniqueWithoutUserInput = {
    where: VoucherUsageWhereUniqueInput
    update: XOR<VoucherUsageUpdateWithoutUserInput, VoucherUsageUncheckedUpdateWithoutUserInput>
    create: XOR<VoucherUsageCreateWithoutUserInput, VoucherUsageUncheckedCreateWithoutUserInput>
  }

  export type VoucherUsageUpdateWithWhereUniqueWithoutUserInput = {
    where: VoucherUsageWhereUniqueInput
    data: XOR<VoucherUsageUpdateWithoutUserInput, VoucherUsageUncheckedUpdateWithoutUserInput>
  }

  export type VoucherUsageUpdateManyWithWhereWithoutUserInput = {
    where: VoucherUsageScalarWhereInput
    data: XOR<VoucherUsageUpdateManyMutationInput, VoucherUsageUncheckedUpdateManyWithoutUserInput>
  }

  export type AuthenticatorUpsertWithWhereUniqueWithoutUserInput = {
    where: AuthenticatorWhereUniqueInput
    update: XOR<AuthenticatorUpdateWithoutUserInput, AuthenticatorUncheckedUpdateWithoutUserInput>
    create: XOR<AuthenticatorCreateWithoutUserInput, AuthenticatorUncheckedCreateWithoutUserInput>
  }

  export type AuthenticatorUpdateWithWhereUniqueWithoutUserInput = {
    where: AuthenticatorWhereUniqueInput
    data: XOR<AuthenticatorUpdateWithoutUserInput, AuthenticatorUncheckedUpdateWithoutUserInput>
  }

  export type AuthenticatorUpdateManyWithWhereWithoutUserInput = {
    where: AuthenticatorScalarWhereInput
    data: XOR<AuthenticatorUpdateManyMutationInput, AuthenticatorUncheckedUpdateManyWithoutUserInput>
  }

  export type AuthenticatorScalarWhereInput = {
    AND?: AuthenticatorScalarWhereInput | AuthenticatorScalarWhereInput[]
    OR?: AuthenticatorScalarWhereInput[]
    NOT?: AuthenticatorScalarWhereInput | AuthenticatorScalarWhereInput[]
    credentialID?: StringFilter<"Authenticator"> | string
    userId?: StringFilter<"Authenticator"> | string
    providerAccountId?: StringFilter<"Authenticator"> | string
    credentialPublicKey?: StringFilter<"Authenticator"> | string
    counter?: IntFilter<"Authenticator"> | number
    credentialDeviceType?: StringFilter<"Authenticator"> | string
    credentialBackedUp?: BoolFilter<"Authenticator"> | boolean
    transports?: StringNullableFilter<"Authenticator"> | string | null
  }

  export type UserCreateWithoutAuthenticatorInput = {
    id?: string
    firstName?: string | null
    lastName?: string | null
    name?: string | null
    userName?: string | null
    email: string
    password?: string
    emailVerified?: Date | string | null
    image?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    orders?: OrderCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    vouchers?: VoucherUsageCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAuthenticatorInput = {
    id?: string
    firstName?: string | null
    lastName?: string | null
    name?: string | null
    userName?: string | null
    email: string
    password?: string
    emailVerified?: Date | string | null
    image?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    vouchers?: VoucherUsageUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAuthenticatorInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAuthenticatorInput, UserUncheckedCreateWithoutAuthenticatorInput>
  }

  export type UserUpsertWithoutAuthenticatorInput = {
    update: XOR<UserUpdateWithoutAuthenticatorInput, UserUncheckedUpdateWithoutAuthenticatorInput>
    create: XOR<UserCreateWithoutAuthenticatorInput, UserUncheckedCreateWithoutAuthenticatorInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAuthenticatorInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAuthenticatorInput, UserUncheckedUpdateWithoutAuthenticatorInput>
  }

  export type UserUpdateWithoutAuthenticatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    userName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orders?: OrderUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    vouchers?: VoucherUsageUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAuthenticatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    userName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    vouchers?: VoucherUsageUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutOrdersInput = {
    id?: string
    firstName?: string | null
    lastName?: string | null
    name?: string | null
    userName?: string | null
    email: string
    password?: string
    emailVerified?: Date | string | null
    image?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    vouchers?: VoucherUsageCreateNestedManyWithoutUserInput
    Authenticator?: AuthenticatorCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutOrdersInput = {
    id?: string
    firstName?: string | null
    lastName?: string | null
    name?: string | null
    userName?: string | null
    email: string
    password?: string
    emailVerified?: Date | string | null
    image?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    vouchers?: VoucherUsageUncheckedCreateNestedManyWithoutUserInput
    Authenticator?: AuthenticatorUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutOrdersInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutOrdersInput, UserUncheckedCreateWithoutOrdersInput>
  }

  export type ProductCreateWithoutOrdersInput = {
    id?: string
    sku: string
    name: string
    slug: string
    description?: string | null
    bestFor?: string | null
    image?: string | null
    price: number
    proccessTime?: number | null
    inStock?: boolean
    status?: $Enums.ProductStatus
    keywords?: NullableJsonNullValueInput | InputJsonValue
    quality: number
    isBest?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    category: CategoryCreateNestedOneWithoutProductsInput
    tags?: TagCreateNestedManyWithoutProductsInput
    gallery?: ProductGalleryCreateNestedManyWithoutProductInput
    benefits?: ProductBenefitCreateNestedManyWithoutProductInput
    benefitPoints?: ProductBenefitPointCreateNestedManyWithoutProductInput
    promotions?: PromotionCreateNestedManyWithoutProductsInput
    vouchers?: VoucherCreateNestedManyWithoutProductsInput
  }

  export type ProductUncheckedCreateWithoutOrdersInput = {
    id?: string
    sku: string
    name: string
    slug: string
    description?: string | null
    bestFor?: string | null
    image?: string | null
    price: number
    proccessTime?: number | null
    inStock?: boolean
    status?: $Enums.ProductStatus
    categoryId: string
    keywords?: NullableJsonNullValueInput | InputJsonValue
    quality: number
    isBest?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    tags?: TagUncheckedCreateNestedManyWithoutProductsInput
    gallery?: ProductGalleryUncheckedCreateNestedManyWithoutProductInput
    benefits?: ProductBenefitUncheckedCreateNestedManyWithoutProductInput
    benefitPoints?: ProductBenefitPointUncheckedCreateNestedManyWithoutProductInput
    promotions?: PromotionUncheckedCreateNestedManyWithoutProductsInput
    vouchers?: VoucherUncheckedCreateNestedManyWithoutProductsInput
  }

  export type ProductCreateOrConnectWithoutOrdersInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutOrdersInput, ProductUncheckedCreateWithoutOrdersInput>
  }

  export type VoucherCreateWithoutOrdersInput = {
    id?: string
    code: string
    description?: string | null
    type: $Enums.PromoType
    value: number
    usageLimit?: number | null
    usedCount?: number
    isActive?: boolean
    startDate: Date | string
    endDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    products?: ProductCreateNestedManyWithoutVouchersInput
    usages?: VoucherUsageCreateNestedManyWithoutVoucherInput
  }

  export type VoucherUncheckedCreateWithoutOrdersInput = {
    id?: string
    code: string
    description?: string | null
    type: $Enums.PromoType
    value: number
    usageLimit?: number | null
    usedCount?: number
    isActive?: boolean
    startDate: Date | string
    endDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    products?: ProductUncheckedCreateNestedManyWithoutVouchersInput
    usages?: VoucherUsageUncheckedCreateNestedManyWithoutVoucherInput
  }

  export type VoucherCreateOrConnectWithoutOrdersInput = {
    where: VoucherWhereUniqueInput
    create: XOR<VoucherCreateWithoutOrdersInput, VoucherUncheckedCreateWithoutOrdersInput>
  }

  export type UserUpsertWithoutOrdersInput = {
    update: XOR<UserUpdateWithoutOrdersInput, UserUncheckedUpdateWithoutOrdersInput>
    create: XOR<UserCreateWithoutOrdersInput, UserUncheckedCreateWithoutOrdersInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutOrdersInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutOrdersInput, UserUncheckedUpdateWithoutOrdersInput>
  }

  export type UserUpdateWithoutOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    userName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    vouchers?: VoucherUsageUpdateManyWithoutUserNestedInput
    Authenticator?: AuthenticatorUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    userName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    vouchers?: VoucherUsageUncheckedUpdateManyWithoutUserNestedInput
    Authenticator?: AuthenticatorUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ProductUpsertWithWhereUniqueWithoutOrdersInput = {
    where: ProductWhereUniqueInput
    update: XOR<ProductUpdateWithoutOrdersInput, ProductUncheckedUpdateWithoutOrdersInput>
    create: XOR<ProductCreateWithoutOrdersInput, ProductUncheckedCreateWithoutOrdersInput>
  }

  export type ProductUpdateWithWhereUniqueWithoutOrdersInput = {
    where: ProductWhereUniqueInput
    data: XOR<ProductUpdateWithoutOrdersInput, ProductUncheckedUpdateWithoutOrdersInput>
  }

  export type ProductUpdateManyWithWhereWithoutOrdersInput = {
    where: ProductScalarWhereInput
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyWithoutOrdersInput>
  }

  export type VoucherUpsertWithoutOrdersInput = {
    update: XOR<VoucherUpdateWithoutOrdersInput, VoucherUncheckedUpdateWithoutOrdersInput>
    create: XOR<VoucherCreateWithoutOrdersInput, VoucherUncheckedCreateWithoutOrdersInput>
    where?: VoucherWhereInput
  }

  export type VoucherUpdateToOneWithWhereWithoutOrdersInput = {
    where?: VoucherWhereInput
    data: XOR<VoucherUpdateWithoutOrdersInput, VoucherUncheckedUpdateWithoutOrdersInput>
  }

  export type VoucherUpdateWithoutOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumPromoTypeFieldUpdateOperationsInput | $Enums.PromoType
    value?: FloatFieldUpdateOperationsInput | number
    usageLimit?: NullableIntFieldUpdateOperationsInput | number | null
    usedCount?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    products?: ProductUpdateManyWithoutVouchersNestedInput
    usages?: VoucherUsageUpdateManyWithoutVoucherNestedInput
  }

  export type VoucherUncheckedUpdateWithoutOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumPromoTypeFieldUpdateOperationsInput | $Enums.PromoType
    value?: FloatFieldUpdateOperationsInput | number
    usageLimit?: NullableIntFieldUpdateOperationsInput | number | null
    usedCount?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    products?: ProductUncheckedUpdateManyWithoutVouchersNestedInput
    usages?: VoucherUsageUncheckedUpdateManyWithoutVoucherNestedInput
  }

  export type MenuCreateWithoutChildrenInput = {
    id?: string
    title: string
    slug: string
    type: $Enums.MenuType
    order: number
    icon?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    parent?: MenuCreateNestedOneWithoutChildrenInput
  }

  export type MenuUncheckedCreateWithoutChildrenInput = {
    id?: string
    title: string
    slug: string
    type: $Enums.MenuType
    order: number
    icon?: string | null
    parentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MenuCreateOrConnectWithoutChildrenInput = {
    where: MenuWhereUniqueInput
    create: XOR<MenuCreateWithoutChildrenInput, MenuUncheckedCreateWithoutChildrenInput>
  }

  export type MenuCreateWithoutParentInput = {
    id?: string
    title: string
    slug: string
    type: $Enums.MenuType
    order: number
    icon?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    children?: MenuCreateNestedManyWithoutParentInput
  }

  export type MenuUncheckedCreateWithoutParentInput = {
    id?: string
    title: string
    slug: string
    type: $Enums.MenuType
    order: number
    icon?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    children?: MenuUncheckedCreateNestedManyWithoutParentInput
  }

  export type MenuCreateOrConnectWithoutParentInput = {
    where: MenuWhereUniqueInput
    create: XOR<MenuCreateWithoutParentInput, MenuUncheckedCreateWithoutParentInput>
  }

  export type MenuCreateManyParentInputEnvelope = {
    data: MenuCreateManyParentInput | MenuCreateManyParentInput[]
  }

  export type MenuUpsertWithoutChildrenInput = {
    update: XOR<MenuUpdateWithoutChildrenInput, MenuUncheckedUpdateWithoutChildrenInput>
    create: XOR<MenuCreateWithoutChildrenInput, MenuUncheckedCreateWithoutChildrenInput>
    where?: MenuWhereInput
  }

  export type MenuUpdateToOneWithWhereWithoutChildrenInput = {
    where?: MenuWhereInput
    data: XOR<MenuUpdateWithoutChildrenInput, MenuUncheckedUpdateWithoutChildrenInput>
  }

  export type MenuUpdateWithoutChildrenInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    type?: EnumMenuTypeFieldUpdateOperationsInput | $Enums.MenuType
    order?: IntFieldUpdateOperationsInput | number
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parent?: MenuUpdateOneWithoutChildrenNestedInput
  }

  export type MenuUncheckedUpdateWithoutChildrenInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    type?: EnumMenuTypeFieldUpdateOperationsInput | $Enums.MenuType
    order?: IntFieldUpdateOperationsInput | number
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MenuUpsertWithWhereUniqueWithoutParentInput = {
    where: MenuWhereUniqueInput
    update: XOR<MenuUpdateWithoutParentInput, MenuUncheckedUpdateWithoutParentInput>
    create: XOR<MenuCreateWithoutParentInput, MenuUncheckedCreateWithoutParentInput>
  }

  export type MenuUpdateWithWhereUniqueWithoutParentInput = {
    where: MenuWhereUniqueInput
    data: XOR<MenuUpdateWithoutParentInput, MenuUncheckedUpdateWithoutParentInput>
  }

  export type MenuUpdateManyWithWhereWithoutParentInput = {
    where: MenuScalarWhereInput
    data: XOR<MenuUpdateManyMutationInput, MenuUncheckedUpdateManyWithoutParentInput>
  }

  export type MenuScalarWhereInput = {
    AND?: MenuScalarWhereInput | MenuScalarWhereInput[]
    OR?: MenuScalarWhereInput[]
    NOT?: MenuScalarWhereInput | MenuScalarWhereInput[]
    id?: StringFilter<"Menu"> | string
    title?: StringFilter<"Menu"> | string
    slug?: StringFilter<"Menu"> | string
    type?: EnumMenuTypeFilter<"Menu"> | $Enums.MenuType
    order?: IntFilter<"Menu"> | number
    icon?: StringNullableFilter<"Menu"> | string | null
    parentId?: StringNullableFilter<"Menu"> | string | null
    createdAt?: DateTimeFilter<"Menu"> | Date | string
    updatedAt?: DateTimeFilter<"Menu"> | Date | string
  }

  export type UserCreateWithoutAccountsInput = {
    id?: string
    firstName?: string | null
    lastName?: string | null
    name?: string | null
    userName?: string | null
    email: string
    password?: string
    emailVerified?: Date | string | null
    image?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    orders?: OrderCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    vouchers?: VoucherUsageCreateNestedManyWithoutUserInput
    Authenticator?: AuthenticatorCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAccountsInput = {
    id?: string
    firstName?: string | null
    lastName?: string | null
    name?: string | null
    userName?: string | null
    email: string
    password?: string
    emailVerified?: Date | string | null
    image?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    vouchers?: VoucherUsageUncheckedCreateNestedManyWithoutUserInput
    Authenticator?: AuthenticatorUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAccountsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
  }

  export type UserUpsertWithoutAccountsInput = {
    update: XOR<UserUpdateWithoutAccountsInput, UserUncheckedUpdateWithoutAccountsInput>
    create: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAccountsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAccountsInput, UserUncheckedUpdateWithoutAccountsInput>
  }

  export type UserUpdateWithoutAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    userName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orders?: OrderUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    vouchers?: VoucherUsageUpdateManyWithoutUserNestedInput
    Authenticator?: AuthenticatorUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    userName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    vouchers?: VoucherUsageUncheckedUpdateManyWithoutUserNestedInput
    Authenticator?: AuthenticatorUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutSessionsInput = {
    id?: string
    firstName?: string | null
    lastName?: string | null
    name?: string | null
    userName?: string | null
    email: string
    password?: string
    emailVerified?: Date | string | null
    image?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    orders?: OrderCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    vouchers?: VoucherUsageCreateNestedManyWithoutUserInput
    Authenticator?: AuthenticatorCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSessionsInput = {
    id?: string
    firstName?: string | null
    lastName?: string | null
    name?: string | null
    userName?: string | null
    email: string
    password?: string
    emailVerified?: Date | string | null
    image?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    vouchers?: VoucherUsageUncheckedCreateNestedManyWithoutUserInput
    Authenticator?: AuthenticatorUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSessionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
  }

  export type UserUpsertWithoutSessionsInput = {
    update: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSessionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type UserUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    userName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orders?: OrderUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    vouchers?: VoucherUsageUpdateManyWithoutUserNestedInput
    Authenticator?: AuthenticatorUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    userName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    vouchers?: VoucherUsageUncheckedUpdateManyWithoutUserNestedInput
    Authenticator?: AuthenticatorUncheckedUpdateManyWithoutUserNestedInput
  }

  export type LpForCreateWithoutLandingPagesInput = {
    id?: string
    description?: string | null
  }

  export type LpForUncheckedCreateWithoutLandingPagesInput = {
    id?: string
    description?: string | null
  }

  export type LpForCreateOrConnectWithoutLandingPagesInput = {
    where: LpForWhereUniqueInput
    create: XOR<LpForCreateWithoutLandingPagesInput, LpForUncheckedCreateWithoutLandingPagesInput>
  }

  export type LpContentTypeCreateWithoutLandingPagesInput = {
    id?: string
    type: string
  }

  export type LpContentTypeUncheckedCreateWithoutLandingPagesInput = {
    id?: string
    type: string
  }

  export type LpContentTypeCreateOrConnectWithoutLandingPagesInput = {
    where: LpContentTypeWhereUniqueInput
    create: XOR<LpContentTypeCreateWithoutLandingPagesInput, LpContentTypeUncheckedCreateWithoutLandingPagesInput>
  }

  export type LpDesignStyleCreateWithoutTemplatesInput = {
    id?: string
    name: string
    description: string
  }

  export type LpDesignStyleUncheckedCreateWithoutTemplatesInput = {
    id?: string
    name: string
    description: string
  }

  export type LpDesignStyleCreateOrConnectWithoutTemplatesInput = {
    where: LpDesignStyleWhereUniqueInput
    create: XOR<LpDesignStyleCreateWithoutTemplatesInput, LpDesignStyleUncheckedCreateWithoutTemplatesInput>
  }

  export type LpForUpsertWithWhereUniqueWithoutLandingPagesInput = {
    where: LpForWhereUniqueInput
    update: XOR<LpForUpdateWithoutLandingPagesInput, LpForUncheckedUpdateWithoutLandingPagesInput>
    create: XOR<LpForCreateWithoutLandingPagesInput, LpForUncheckedCreateWithoutLandingPagesInput>
  }

  export type LpForUpdateWithWhereUniqueWithoutLandingPagesInput = {
    where: LpForWhereUniqueInput
    data: XOR<LpForUpdateWithoutLandingPagesInput, LpForUncheckedUpdateWithoutLandingPagesInput>
  }

  export type LpForUpdateManyWithWhereWithoutLandingPagesInput = {
    where: LpForScalarWhereInput
    data: XOR<LpForUpdateManyMutationInput, LpForUncheckedUpdateManyWithoutLandingPagesInput>
  }

  export type LpForScalarWhereInput = {
    AND?: LpForScalarWhereInput | LpForScalarWhereInput[]
    OR?: LpForScalarWhereInput[]
    NOT?: LpForScalarWhereInput | LpForScalarWhereInput[]
    id?: StringFilter<"LpFor"> | string
    description?: StringNullableFilter<"LpFor"> | string | null
  }

  export type LpContentTypeUpsertWithWhereUniqueWithoutLandingPagesInput = {
    where: LpContentTypeWhereUniqueInput
    update: XOR<LpContentTypeUpdateWithoutLandingPagesInput, LpContentTypeUncheckedUpdateWithoutLandingPagesInput>
    create: XOR<LpContentTypeCreateWithoutLandingPagesInput, LpContentTypeUncheckedCreateWithoutLandingPagesInput>
  }

  export type LpContentTypeUpdateWithWhereUniqueWithoutLandingPagesInput = {
    where: LpContentTypeWhereUniqueInput
    data: XOR<LpContentTypeUpdateWithoutLandingPagesInput, LpContentTypeUncheckedUpdateWithoutLandingPagesInput>
  }

  export type LpContentTypeUpdateManyWithWhereWithoutLandingPagesInput = {
    where: LpContentTypeScalarWhereInput
    data: XOR<LpContentTypeUpdateManyMutationInput, LpContentTypeUncheckedUpdateManyWithoutLandingPagesInput>
  }

  export type LpContentTypeScalarWhereInput = {
    AND?: LpContentTypeScalarWhereInput | LpContentTypeScalarWhereInput[]
    OR?: LpContentTypeScalarWhereInput[]
    NOT?: LpContentTypeScalarWhereInput | LpContentTypeScalarWhereInput[]
    id?: StringFilter<"LpContentType"> | string
    type?: StringFilter<"LpContentType"> | string
  }

  export type LpDesignStyleUpsertWithoutTemplatesInput = {
    update: XOR<LpDesignStyleUpdateWithoutTemplatesInput, LpDesignStyleUncheckedUpdateWithoutTemplatesInput>
    create: XOR<LpDesignStyleCreateWithoutTemplatesInput, LpDesignStyleUncheckedCreateWithoutTemplatesInput>
    where?: LpDesignStyleWhereInput
  }

  export type LpDesignStyleUpdateToOneWithWhereWithoutTemplatesInput = {
    where?: LpDesignStyleWhereInput
    data: XOR<LpDesignStyleUpdateWithoutTemplatesInput, LpDesignStyleUncheckedUpdateWithoutTemplatesInput>
  }

  export type LpDesignStyleUpdateWithoutTemplatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
  }

  export type LpDesignStyleUncheckedUpdateWithoutTemplatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
  }

  export type LandingPageCreateWithoutLpForInput = {
    id?: string
    name: string
    slug: string
    description: string
    image: string
    marketingTools?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lpContentTypes?: LpContentTypeCreateNestedManyWithoutLandingPagesInput
    lpDesignStyle?: LpDesignStyleCreateNestedOneWithoutTemplatesInput
  }

  export type LandingPageUncheckedCreateWithoutLpForInput = {
    id?: string
    name: string
    slug: string
    description: string
    image: string
    lpDesignStyleId?: string | null
    marketingTools?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lpContentTypes?: LpContentTypeUncheckedCreateNestedManyWithoutLandingPagesInput
  }

  export type LandingPageCreateOrConnectWithoutLpForInput = {
    where: LandingPageWhereUniqueInput
    create: XOR<LandingPageCreateWithoutLpForInput, LandingPageUncheckedCreateWithoutLpForInput>
  }

  export type LandingPageUpsertWithWhereUniqueWithoutLpForInput = {
    where: LandingPageWhereUniqueInput
    update: XOR<LandingPageUpdateWithoutLpForInput, LandingPageUncheckedUpdateWithoutLpForInput>
    create: XOR<LandingPageCreateWithoutLpForInput, LandingPageUncheckedCreateWithoutLpForInput>
  }

  export type LandingPageUpdateWithWhereUniqueWithoutLpForInput = {
    where: LandingPageWhereUniqueInput
    data: XOR<LandingPageUpdateWithoutLpForInput, LandingPageUncheckedUpdateWithoutLpForInput>
  }

  export type LandingPageUpdateManyWithWhereWithoutLpForInput = {
    where: LandingPageScalarWhereInput
    data: XOR<LandingPageUpdateManyMutationInput, LandingPageUncheckedUpdateManyWithoutLpForInput>
  }

  export type LandingPageScalarWhereInput = {
    AND?: LandingPageScalarWhereInput | LandingPageScalarWhereInput[]
    OR?: LandingPageScalarWhereInput[]
    NOT?: LandingPageScalarWhereInput | LandingPageScalarWhereInput[]
    id?: StringFilter<"LandingPage"> | string
    name?: StringFilter<"LandingPage"> | string
    slug?: StringFilter<"LandingPage"> | string
    description?: StringFilter<"LandingPage"> | string
    image?: StringFilter<"LandingPage"> | string
    lpDesignStyleId?: StringNullableFilter<"LandingPage"> | string | null
    marketingTools?: StringNullableFilter<"LandingPage"> | string | null
    isActive?: BoolFilter<"LandingPage"> | boolean
    createdAt?: DateTimeFilter<"LandingPage"> | Date | string
    updatedAt?: DateTimeFilter<"LandingPage"> | Date | string
  }

  export type LandingPageCreateWithoutLpContentTypesInput = {
    id?: string
    name: string
    slug: string
    description: string
    image: string
    marketingTools?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lpFor?: LpForCreateNestedManyWithoutLandingPagesInput
    lpDesignStyle?: LpDesignStyleCreateNestedOneWithoutTemplatesInput
  }

  export type LandingPageUncheckedCreateWithoutLpContentTypesInput = {
    id?: string
    name: string
    slug: string
    description: string
    image: string
    lpDesignStyleId?: string | null
    marketingTools?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lpFor?: LpForUncheckedCreateNestedManyWithoutLandingPagesInput
  }

  export type LandingPageCreateOrConnectWithoutLpContentTypesInput = {
    where: LandingPageWhereUniqueInput
    create: XOR<LandingPageCreateWithoutLpContentTypesInput, LandingPageUncheckedCreateWithoutLpContentTypesInput>
  }

  export type LandingPageUpsertWithWhereUniqueWithoutLpContentTypesInput = {
    where: LandingPageWhereUniqueInput
    update: XOR<LandingPageUpdateWithoutLpContentTypesInput, LandingPageUncheckedUpdateWithoutLpContentTypesInput>
    create: XOR<LandingPageCreateWithoutLpContentTypesInput, LandingPageUncheckedCreateWithoutLpContentTypesInput>
  }

  export type LandingPageUpdateWithWhereUniqueWithoutLpContentTypesInput = {
    where: LandingPageWhereUniqueInput
    data: XOR<LandingPageUpdateWithoutLpContentTypesInput, LandingPageUncheckedUpdateWithoutLpContentTypesInput>
  }

  export type LandingPageUpdateManyWithWhereWithoutLpContentTypesInput = {
    where: LandingPageScalarWhereInput
    data: XOR<LandingPageUpdateManyMutationInput, LandingPageUncheckedUpdateManyWithoutLpContentTypesInput>
  }

  export type LandingPageCreateWithoutLpDesignStyleInput = {
    id?: string
    name: string
    slug: string
    description: string
    image: string
    marketingTools?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lpFor?: LpForCreateNestedManyWithoutLandingPagesInput
    lpContentTypes?: LpContentTypeCreateNestedManyWithoutLandingPagesInput
  }

  export type LandingPageUncheckedCreateWithoutLpDesignStyleInput = {
    id?: string
    name: string
    slug: string
    description: string
    image: string
    marketingTools?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lpFor?: LpForUncheckedCreateNestedManyWithoutLandingPagesInput
    lpContentTypes?: LpContentTypeUncheckedCreateNestedManyWithoutLandingPagesInput
  }

  export type LandingPageCreateOrConnectWithoutLpDesignStyleInput = {
    where: LandingPageWhereUniqueInput
    create: XOR<LandingPageCreateWithoutLpDesignStyleInput, LandingPageUncheckedCreateWithoutLpDesignStyleInput>
  }

  export type LandingPageCreateManyLpDesignStyleInputEnvelope = {
    data: LandingPageCreateManyLpDesignStyleInput | LandingPageCreateManyLpDesignStyleInput[]
  }

  export type LandingPageUpsertWithWhereUniqueWithoutLpDesignStyleInput = {
    where: LandingPageWhereUniqueInput
    update: XOR<LandingPageUpdateWithoutLpDesignStyleInput, LandingPageUncheckedUpdateWithoutLpDesignStyleInput>
    create: XOR<LandingPageCreateWithoutLpDesignStyleInput, LandingPageUncheckedCreateWithoutLpDesignStyleInput>
  }

  export type LandingPageUpdateWithWhereUniqueWithoutLpDesignStyleInput = {
    where: LandingPageWhereUniqueInput
    data: XOR<LandingPageUpdateWithoutLpDesignStyleInput, LandingPageUncheckedUpdateWithoutLpDesignStyleInput>
  }

  export type LandingPageUpdateManyWithWhereWithoutLpDesignStyleInput = {
    where: LandingPageScalarWhereInput
    data: XOR<LandingPageUpdateManyMutationInput, LandingPageUncheckedUpdateManyWithoutLpDesignStyleInput>
  }

  export type SocialLinksCreateManyIdentityInput = {
    id?: string
    platform?: string | null
    url?: string | null
    platformUsername?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SocialLinksUpdateWithoutIdentityInput = {
    id?: StringFieldUpdateOperationsInput | string
    platform?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    platformUsername?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SocialLinksUncheckedUpdateWithoutIdentityInput = {
    id?: StringFieldUpdateOperationsInput | string
    platform?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    platformUsername?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SocialLinksUncheckedUpdateManyWithoutIdentityInput = {
    id?: StringFieldUpdateOperationsInput | string
    platform?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    platformUsername?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SectionCreateManyPageInput = {
    id?: string
    name?: string | null
    type: $Enums.SectionType
    title: string
    subTitle?: string | null
    description?: string | null
    additionalText?: string | null
    image?: string | null
    video?: string | null
    icon?: string | null
    order: number
  }

  export type SectionUpdateWithoutPageInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumSectionTypeFieldUpdateOperationsInput | $Enums.SectionType
    title?: StringFieldUpdateOperationsInput | string
    subTitle?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    additionalText?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    video?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    listItems?: ListItemUpdateManyWithoutSectionNestedInput
  }

  export type SectionUncheckedUpdateWithoutPageInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumSectionTypeFieldUpdateOperationsInput | $Enums.SectionType
    title?: StringFieldUpdateOperationsInput | string
    subTitle?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    additionalText?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    video?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    listItems?: ListItemUncheckedUpdateManyWithoutSectionNestedInput
  }

  export type SectionUncheckedUpdateManyWithoutPageInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumSectionTypeFieldUpdateOperationsInput | $Enums.SectionType
    title?: StringFieldUpdateOperationsInput | string
    subTitle?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    additionalText?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    video?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
  }

  export type ListItemCreateManySectionInput = {
    id?: string
    type: $Enums.ListItemType
    title: string
    description?: string | null
  }

  export type ListItemUpdateWithoutSectionInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumListItemTypeFieldUpdateOperationsInput | $Enums.ListItemType
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    entries?: ListEntryUpdateManyWithoutListItemNestedInput
  }

  export type ListItemUncheckedUpdateWithoutSectionInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumListItemTypeFieldUpdateOperationsInput | $Enums.ListItemType
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    entries?: ListEntryUncheckedUpdateManyWithoutListItemNestedInput
  }

  export type ListItemUncheckedUpdateManyWithoutSectionInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumListItemTypeFieldUpdateOperationsInput | $Enums.ListItemType
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ListEntryCreateManyListItemInput = {
    id?: string
    title: string
    price?: number | null
    description?: string | null
    icon?: string | null
    image?: string | null
  }

  export type ListEntryUpdateWithoutListItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    price?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ListEntryUncheckedUpdateWithoutListItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    price?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ListEntryUncheckedUpdateManyWithoutListItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    price?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProductGalleryCreateManyProductInput = {
    id?: string
    imageUrl: string
    order: number
    createdAt?: Date | string
  }

  export type ProductBenefitCreateManyProductInput = {
    id?: string
    benefitId: string
    isActive?: boolean
    order?: number
  }

  export type ProductBenefitPointCreateManyProductInput = {
    id?: string
    text: string
    order: number
    icon?: string | null
  }

  export type TagUpdateWithoutProductsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
  }

  export type TagUncheckedUpdateWithoutProductsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
  }

  export type TagUncheckedUpdateManyWithoutProductsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
  }

  export type ProductGalleryUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductGalleryUncheckedUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductGalleryUncheckedUpdateManyWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductBenefitUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
    benefit?: BenefitUpdateOneRequiredWithoutProductsNestedInput
  }

  export type ProductBenefitUncheckedUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    benefitId?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
  }

  export type ProductBenefitUncheckedUpdateManyWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    benefitId?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
  }

  export type ProductBenefitPointUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    icon?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProductBenefitPointUncheckedUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    icon?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProductBenefitPointUncheckedUpdateManyWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    icon?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PromotionUpdateWithoutProductsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumPromoTypeFieldUpdateOperationsInput | $Enums.PromoType
    value?: NullableFloatFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PromotionUncheckedUpdateWithoutProductsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumPromoTypeFieldUpdateOperationsInput | $Enums.PromoType
    value?: NullableFloatFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PromotionUncheckedUpdateManyWithoutProductsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumPromoTypeFieldUpdateOperationsInput | $Enums.PromoType
    value?: NullableFloatFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VoucherUpdateWithoutProductsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumPromoTypeFieldUpdateOperationsInput | $Enums.PromoType
    value?: FloatFieldUpdateOperationsInput | number
    usageLimit?: NullableIntFieldUpdateOperationsInput | number | null
    usedCount?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    usages?: VoucherUsageUpdateManyWithoutVoucherNestedInput
    orders?: OrderUpdateManyWithoutVoucherNestedInput
  }

  export type VoucherUncheckedUpdateWithoutProductsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumPromoTypeFieldUpdateOperationsInput | $Enums.PromoType
    value?: FloatFieldUpdateOperationsInput | number
    usageLimit?: NullableIntFieldUpdateOperationsInput | number | null
    usedCount?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    usages?: VoucherUsageUncheckedUpdateManyWithoutVoucherNestedInput
    orders?: OrderUncheckedUpdateManyWithoutVoucherNestedInput
  }

  export type VoucherUncheckedUpdateManyWithoutProductsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumPromoTypeFieldUpdateOperationsInput | $Enums.PromoType
    value?: FloatFieldUpdateOperationsInput | number
    usageLimit?: NullableIntFieldUpdateOperationsInput | number | null
    usedCount?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderUpdateWithoutProductsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    totalPrice?: FloatFieldUpdateOperationsInput | number
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutOrdersNestedInput
    voucher?: VoucherUpdateOneWithoutOrdersNestedInput
  }

  export type OrderUncheckedUpdateWithoutProductsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    voucherId?: NullableStringFieldUpdateOperationsInput | string | null
    totalPrice?: FloatFieldUpdateOperationsInput | number
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderUncheckedUpdateManyWithoutProductsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    voucherId?: NullableStringFieldUpdateOperationsInput | string | null
    totalPrice?: FloatFieldUpdateOperationsInput | number
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductCreateManyCategoryInput = {
    id?: string
    sku: string
    name: string
    slug: string
    description?: string | null
    bestFor?: string | null
    image?: string | null
    price: number
    proccessTime?: number | null
    inStock?: boolean
    status?: $Enums.ProductStatus
    keywords?: NullableJsonNullValueInput | InputJsonValue
    quality: number
    isBest?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductUpdateWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    bestFor?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    proccessTime?: NullableIntFieldUpdateOperationsInput | number | null
    inStock?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumProductStatusFieldUpdateOperationsInput | $Enums.ProductStatus
    keywords?: NullableJsonNullValueInput | InputJsonValue
    quality?: IntFieldUpdateOperationsInput | number
    isBest?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tags?: TagUpdateManyWithoutProductsNestedInput
    gallery?: ProductGalleryUpdateManyWithoutProductNestedInput
    benefits?: ProductBenefitUpdateManyWithoutProductNestedInput
    benefitPoints?: ProductBenefitPointUpdateManyWithoutProductNestedInput
    promotions?: PromotionUpdateManyWithoutProductsNestedInput
    vouchers?: VoucherUpdateManyWithoutProductsNestedInput
    orders?: OrderUpdateManyWithoutProductsNestedInput
  }

  export type ProductUncheckedUpdateWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    bestFor?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    proccessTime?: NullableIntFieldUpdateOperationsInput | number | null
    inStock?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumProductStatusFieldUpdateOperationsInput | $Enums.ProductStatus
    keywords?: NullableJsonNullValueInput | InputJsonValue
    quality?: IntFieldUpdateOperationsInput | number
    isBest?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tags?: TagUncheckedUpdateManyWithoutProductsNestedInput
    gallery?: ProductGalleryUncheckedUpdateManyWithoutProductNestedInput
    benefits?: ProductBenefitUncheckedUpdateManyWithoutProductNestedInput
    benefitPoints?: ProductBenefitPointUncheckedUpdateManyWithoutProductNestedInput
    promotions?: PromotionUncheckedUpdateManyWithoutProductsNestedInput
    vouchers?: VoucherUncheckedUpdateManyWithoutProductsNestedInput
    orders?: OrderUncheckedUpdateManyWithoutProductsNestedInput
  }

  export type ProductUncheckedUpdateManyWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    bestFor?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    proccessTime?: NullableIntFieldUpdateOperationsInput | number | null
    inStock?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumProductStatusFieldUpdateOperationsInput | $Enums.ProductStatus
    keywords?: NullableJsonNullValueInput | InputJsonValue
    quality?: IntFieldUpdateOperationsInput | number
    isBest?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductUpdateWithoutTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    bestFor?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    proccessTime?: NullableIntFieldUpdateOperationsInput | number | null
    inStock?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumProductStatusFieldUpdateOperationsInput | $Enums.ProductStatus
    keywords?: NullableJsonNullValueInput | InputJsonValue
    quality?: IntFieldUpdateOperationsInput | number
    isBest?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: CategoryUpdateOneRequiredWithoutProductsNestedInput
    gallery?: ProductGalleryUpdateManyWithoutProductNestedInput
    benefits?: ProductBenefitUpdateManyWithoutProductNestedInput
    benefitPoints?: ProductBenefitPointUpdateManyWithoutProductNestedInput
    promotions?: PromotionUpdateManyWithoutProductsNestedInput
    vouchers?: VoucherUpdateManyWithoutProductsNestedInput
    orders?: OrderUpdateManyWithoutProductsNestedInput
  }

  export type ProductUncheckedUpdateWithoutTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    bestFor?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    proccessTime?: NullableIntFieldUpdateOperationsInput | number | null
    inStock?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumProductStatusFieldUpdateOperationsInput | $Enums.ProductStatus
    categoryId?: StringFieldUpdateOperationsInput | string
    keywords?: NullableJsonNullValueInput | InputJsonValue
    quality?: IntFieldUpdateOperationsInput | number
    isBest?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    gallery?: ProductGalleryUncheckedUpdateManyWithoutProductNestedInput
    benefits?: ProductBenefitUncheckedUpdateManyWithoutProductNestedInput
    benefitPoints?: ProductBenefitPointUncheckedUpdateManyWithoutProductNestedInput
    promotions?: PromotionUncheckedUpdateManyWithoutProductsNestedInput
    vouchers?: VoucherUncheckedUpdateManyWithoutProductsNestedInput
    orders?: OrderUncheckedUpdateManyWithoutProductsNestedInput
  }

  export type ProductUncheckedUpdateManyWithoutTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    bestFor?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    proccessTime?: NullableIntFieldUpdateOperationsInput | number | null
    inStock?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumProductStatusFieldUpdateOperationsInput | $Enums.ProductStatus
    categoryId?: StringFieldUpdateOperationsInput | string
    keywords?: NullableJsonNullValueInput | InputJsonValue
    quality?: IntFieldUpdateOperationsInput | number
    isBest?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductBenefitCreateManyBenefitInput = {
    id?: string
    productId: string
    isActive?: boolean
    order?: number
  }

  export type ProductBenefitUpdateWithoutBenefitInput = {
    id?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
    product?: ProductUpdateOneRequiredWithoutBenefitsNestedInput
  }

  export type ProductBenefitUncheckedUpdateWithoutBenefitInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
  }

  export type ProductBenefitUncheckedUpdateManyWithoutBenefitInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
  }

  export type ProductUpdateWithoutPromotionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    bestFor?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    proccessTime?: NullableIntFieldUpdateOperationsInput | number | null
    inStock?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumProductStatusFieldUpdateOperationsInput | $Enums.ProductStatus
    keywords?: NullableJsonNullValueInput | InputJsonValue
    quality?: IntFieldUpdateOperationsInput | number
    isBest?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: CategoryUpdateOneRequiredWithoutProductsNestedInput
    tags?: TagUpdateManyWithoutProductsNestedInput
    gallery?: ProductGalleryUpdateManyWithoutProductNestedInput
    benefits?: ProductBenefitUpdateManyWithoutProductNestedInput
    benefitPoints?: ProductBenefitPointUpdateManyWithoutProductNestedInput
    vouchers?: VoucherUpdateManyWithoutProductsNestedInput
    orders?: OrderUpdateManyWithoutProductsNestedInput
  }

  export type ProductUncheckedUpdateWithoutPromotionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    bestFor?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    proccessTime?: NullableIntFieldUpdateOperationsInput | number | null
    inStock?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumProductStatusFieldUpdateOperationsInput | $Enums.ProductStatus
    categoryId?: StringFieldUpdateOperationsInput | string
    keywords?: NullableJsonNullValueInput | InputJsonValue
    quality?: IntFieldUpdateOperationsInput | number
    isBest?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tags?: TagUncheckedUpdateManyWithoutProductsNestedInput
    gallery?: ProductGalleryUncheckedUpdateManyWithoutProductNestedInput
    benefits?: ProductBenefitUncheckedUpdateManyWithoutProductNestedInput
    benefitPoints?: ProductBenefitPointUncheckedUpdateManyWithoutProductNestedInput
    vouchers?: VoucherUncheckedUpdateManyWithoutProductsNestedInput
    orders?: OrderUncheckedUpdateManyWithoutProductsNestedInput
  }

  export type ProductUncheckedUpdateManyWithoutPromotionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    bestFor?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    proccessTime?: NullableIntFieldUpdateOperationsInput | number | null
    inStock?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumProductStatusFieldUpdateOperationsInput | $Enums.ProductStatus
    categoryId?: StringFieldUpdateOperationsInput | string
    keywords?: NullableJsonNullValueInput | InputJsonValue
    quality?: IntFieldUpdateOperationsInput | number
    isBest?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VoucherUsageCreateManyVoucherInput = {
    id?: string
    userId: string
    usedAt?: Date | string
  }

  export type OrderCreateManyVoucherInput = {
    id?: string
    email: string
    name?: string | null
    userId?: string | null
    totalPrice: number
    status?: $Enums.OrderStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductUpdateWithoutVouchersInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    bestFor?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    proccessTime?: NullableIntFieldUpdateOperationsInput | number | null
    inStock?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumProductStatusFieldUpdateOperationsInput | $Enums.ProductStatus
    keywords?: NullableJsonNullValueInput | InputJsonValue
    quality?: IntFieldUpdateOperationsInput | number
    isBest?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: CategoryUpdateOneRequiredWithoutProductsNestedInput
    tags?: TagUpdateManyWithoutProductsNestedInput
    gallery?: ProductGalleryUpdateManyWithoutProductNestedInput
    benefits?: ProductBenefitUpdateManyWithoutProductNestedInput
    benefitPoints?: ProductBenefitPointUpdateManyWithoutProductNestedInput
    promotions?: PromotionUpdateManyWithoutProductsNestedInput
    orders?: OrderUpdateManyWithoutProductsNestedInput
  }

  export type ProductUncheckedUpdateWithoutVouchersInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    bestFor?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    proccessTime?: NullableIntFieldUpdateOperationsInput | number | null
    inStock?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumProductStatusFieldUpdateOperationsInput | $Enums.ProductStatus
    categoryId?: StringFieldUpdateOperationsInput | string
    keywords?: NullableJsonNullValueInput | InputJsonValue
    quality?: IntFieldUpdateOperationsInput | number
    isBest?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tags?: TagUncheckedUpdateManyWithoutProductsNestedInput
    gallery?: ProductGalleryUncheckedUpdateManyWithoutProductNestedInput
    benefits?: ProductBenefitUncheckedUpdateManyWithoutProductNestedInput
    benefitPoints?: ProductBenefitPointUncheckedUpdateManyWithoutProductNestedInput
    promotions?: PromotionUncheckedUpdateManyWithoutProductsNestedInput
    orders?: OrderUncheckedUpdateManyWithoutProductsNestedInput
  }

  export type ProductUncheckedUpdateManyWithoutVouchersInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    bestFor?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    proccessTime?: NullableIntFieldUpdateOperationsInput | number | null
    inStock?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumProductStatusFieldUpdateOperationsInput | $Enums.ProductStatus
    categoryId?: StringFieldUpdateOperationsInput | string
    keywords?: NullableJsonNullValueInput | InputJsonValue
    quality?: IntFieldUpdateOperationsInput | number
    isBest?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VoucherUsageUpdateWithoutVoucherInput = {
    id?: StringFieldUpdateOperationsInput | string
    usedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutVouchersNestedInput
  }

  export type VoucherUsageUncheckedUpdateWithoutVoucherInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    usedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VoucherUsageUncheckedUpdateManyWithoutVoucherInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    usedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderUpdateWithoutVoucherInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    totalPrice?: FloatFieldUpdateOperationsInput | number
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutOrdersNestedInput
    products?: ProductUpdateManyWithoutOrdersNestedInput
  }

  export type OrderUncheckedUpdateWithoutVoucherInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    totalPrice?: FloatFieldUpdateOperationsInput | number
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    products?: ProductUncheckedUpdateManyWithoutOrdersNestedInput
  }

  export type OrderUncheckedUpdateManyWithoutVoucherInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    totalPrice?: FloatFieldUpdateOperationsInput | number
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderCreateManyUserInput = {
    id?: string
    email: string
    name?: string | null
    voucherId?: string | null
    totalPrice: number
    status?: $Enums.OrderStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AccountCreateManyUserInput = {
    id?: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
  }

  export type SessionCreateManyUserInput = {
    id?: string
    sessionToken: string
    expires: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VoucherUsageCreateManyUserInput = {
    id?: string
    voucherId: string
    usedAt?: Date | string
  }

  export type AuthenticatorCreateManyUserInput = {
    credentialID: string
    providerAccountId: string
    credentialPublicKey: string
    counter: number
    credentialDeviceType: string
    credentialBackedUp: boolean
    transports?: string | null
  }

  export type OrderUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    totalPrice?: FloatFieldUpdateOperationsInput | number
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    products?: ProductUpdateManyWithoutOrdersNestedInput
    voucher?: VoucherUpdateOneWithoutOrdersNestedInput
  }

  export type OrderUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    voucherId?: NullableStringFieldUpdateOperationsInput | string | null
    totalPrice?: FloatFieldUpdateOperationsInput | number
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    products?: ProductUncheckedUpdateManyWithoutOrdersNestedInput
  }

  export type OrderUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    voucherId?: NullableStringFieldUpdateOperationsInput | string | null
    totalPrice?: FloatFieldUpdateOperationsInput | number
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SessionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VoucherUsageUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    usedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    voucher?: VoucherUpdateOneRequiredWithoutUsagesNestedInput
  }

  export type VoucherUsageUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    voucherId?: StringFieldUpdateOperationsInput | string
    usedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VoucherUsageUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    voucherId?: StringFieldUpdateOperationsInput | string
    usedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuthenticatorUpdateWithoutUserInput = {
    credentialID?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    credentialPublicKey?: StringFieldUpdateOperationsInput | string
    counter?: IntFieldUpdateOperationsInput | number
    credentialDeviceType?: StringFieldUpdateOperationsInput | string
    credentialBackedUp?: BoolFieldUpdateOperationsInput | boolean
    transports?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AuthenticatorUncheckedUpdateWithoutUserInput = {
    credentialID?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    credentialPublicKey?: StringFieldUpdateOperationsInput | string
    counter?: IntFieldUpdateOperationsInput | number
    credentialDeviceType?: StringFieldUpdateOperationsInput | string
    credentialBackedUp?: BoolFieldUpdateOperationsInput | boolean
    transports?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AuthenticatorUncheckedUpdateManyWithoutUserInput = {
    credentialID?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    credentialPublicKey?: StringFieldUpdateOperationsInput | string
    counter?: IntFieldUpdateOperationsInput | number
    credentialDeviceType?: StringFieldUpdateOperationsInput | string
    credentialBackedUp?: BoolFieldUpdateOperationsInput | boolean
    transports?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProductUpdateWithoutOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    bestFor?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    proccessTime?: NullableIntFieldUpdateOperationsInput | number | null
    inStock?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumProductStatusFieldUpdateOperationsInput | $Enums.ProductStatus
    keywords?: NullableJsonNullValueInput | InputJsonValue
    quality?: IntFieldUpdateOperationsInput | number
    isBest?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: CategoryUpdateOneRequiredWithoutProductsNestedInput
    tags?: TagUpdateManyWithoutProductsNestedInput
    gallery?: ProductGalleryUpdateManyWithoutProductNestedInput
    benefits?: ProductBenefitUpdateManyWithoutProductNestedInput
    benefitPoints?: ProductBenefitPointUpdateManyWithoutProductNestedInput
    promotions?: PromotionUpdateManyWithoutProductsNestedInput
    vouchers?: VoucherUpdateManyWithoutProductsNestedInput
  }

  export type ProductUncheckedUpdateWithoutOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    bestFor?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    proccessTime?: NullableIntFieldUpdateOperationsInput | number | null
    inStock?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumProductStatusFieldUpdateOperationsInput | $Enums.ProductStatus
    categoryId?: StringFieldUpdateOperationsInput | string
    keywords?: NullableJsonNullValueInput | InputJsonValue
    quality?: IntFieldUpdateOperationsInput | number
    isBest?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tags?: TagUncheckedUpdateManyWithoutProductsNestedInput
    gallery?: ProductGalleryUncheckedUpdateManyWithoutProductNestedInput
    benefits?: ProductBenefitUncheckedUpdateManyWithoutProductNestedInput
    benefitPoints?: ProductBenefitPointUncheckedUpdateManyWithoutProductNestedInput
    promotions?: PromotionUncheckedUpdateManyWithoutProductsNestedInput
    vouchers?: VoucherUncheckedUpdateManyWithoutProductsNestedInput
  }

  export type ProductUncheckedUpdateManyWithoutOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    bestFor?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    proccessTime?: NullableIntFieldUpdateOperationsInput | number | null
    inStock?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumProductStatusFieldUpdateOperationsInput | $Enums.ProductStatus
    categoryId?: StringFieldUpdateOperationsInput | string
    keywords?: NullableJsonNullValueInput | InputJsonValue
    quality?: IntFieldUpdateOperationsInput | number
    isBest?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MenuCreateManyParentInput = {
    id?: string
    title: string
    slug: string
    type: $Enums.MenuType
    order: number
    icon?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MenuUpdateWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    type?: EnumMenuTypeFieldUpdateOperationsInput | $Enums.MenuType
    order?: IntFieldUpdateOperationsInput | number
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: MenuUpdateManyWithoutParentNestedInput
  }

  export type MenuUncheckedUpdateWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    type?: EnumMenuTypeFieldUpdateOperationsInput | $Enums.MenuType
    order?: IntFieldUpdateOperationsInput | number
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: MenuUncheckedUpdateManyWithoutParentNestedInput
  }

  export type MenuUncheckedUpdateManyWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    type?: EnumMenuTypeFieldUpdateOperationsInput | $Enums.MenuType
    order?: IntFieldUpdateOperationsInput | number
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LpForUpdateWithoutLandingPagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type LpForUncheckedUpdateWithoutLandingPagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type LpForUncheckedUpdateManyWithoutLandingPagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type LpContentTypeUpdateWithoutLandingPagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
  }

  export type LpContentTypeUncheckedUpdateWithoutLandingPagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
  }

  export type LpContentTypeUncheckedUpdateManyWithoutLandingPagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
  }

  export type LandingPageUpdateWithoutLpForInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    marketingTools?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lpContentTypes?: LpContentTypeUpdateManyWithoutLandingPagesNestedInput
    lpDesignStyle?: LpDesignStyleUpdateOneWithoutTemplatesNestedInput
  }

  export type LandingPageUncheckedUpdateWithoutLpForInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    lpDesignStyleId?: NullableStringFieldUpdateOperationsInput | string | null
    marketingTools?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lpContentTypes?: LpContentTypeUncheckedUpdateManyWithoutLandingPagesNestedInput
  }

  export type LandingPageUncheckedUpdateManyWithoutLpForInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    lpDesignStyleId?: NullableStringFieldUpdateOperationsInput | string | null
    marketingTools?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LandingPageUpdateWithoutLpContentTypesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    marketingTools?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lpFor?: LpForUpdateManyWithoutLandingPagesNestedInput
    lpDesignStyle?: LpDesignStyleUpdateOneWithoutTemplatesNestedInput
  }

  export type LandingPageUncheckedUpdateWithoutLpContentTypesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    lpDesignStyleId?: NullableStringFieldUpdateOperationsInput | string | null
    marketingTools?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lpFor?: LpForUncheckedUpdateManyWithoutLandingPagesNestedInput
  }

  export type LandingPageUncheckedUpdateManyWithoutLpContentTypesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    lpDesignStyleId?: NullableStringFieldUpdateOperationsInput | string | null
    marketingTools?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LandingPageCreateManyLpDesignStyleInput = {
    id?: string
    name: string
    slug: string
    description: string
    image: string
    marketingTools?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LandingPageUpdateWithoutLpDesignStyleInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    marketingTools?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lpFor?: LpForUpdateManyWithoutLandingPagesNestedInput
    lpContentTypes?: LpContentTypeUpdateManyWithoutLandingPagesNestedInput
  }

  export type LandingPageUncheckedUpdateWithoutLpDesignStyleInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    marketingTools?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lpFor?: LpForUncheckedUpdateManyWithoutLandingPagesNestedInput
    lpContentTypes?: LpContentTypeUncheckedUpdateManyWithoutLandingPagesNestedInput
  }

  export type LandingPageUncheckedUpdateManyWithoutLpDesignStyleInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    marketingTools?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}